<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ManagedBass.PInvoke</name>
    </assembly>
    <members>
        <member name="T:ManagedBass.BassException">
            <summary>
            An Exception wrapping <see cref="P:ManagedBass.Bass.LastError"/> or BassAsio.LastError.
            </summary>
        </member>
        <member name="M:ManagedBass.BassException.#ctor">
            <summary>
            Creates a new instance of <see cref="T:ManagedBass.BassException"/> with <see cref="P:ManagedBass.Bass.LastError"/>.
            </summary>
        </member>
        <member name="M:ManagedBass.BassException.#ctor(ManagedBass.Errors)">
            <summary>
            Creates a new instance of <see cref="T:ManagedBass.BassException"/> with provided Error code.
            </summary>
        </member>
        <member name="P:ManagedBass.BassException.ErrorCode">
            <summary>
            Gets the Bass Error Code.
            </summary>
        </member>
        <member name="T:ManagedBass.DownloadProcedure">
            <summary>
            Internet stream download callback function (to be used with <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" />).
            </summary>
            <param name="Buffer">The pointer to the Buffer containing the downloaded data... <see cref="F:System.IntPtr.Zero" /> = finished downloading.</param>
            <param name="Length">The number of bytes in the Buffer... 0 = HTTP or ICY tags.</param>
            <param name="User">The User instance data given when <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" /> was called.</param>
            <remarks>
            <para>
            The callback will be called before the <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" /> call returns (if it's successful), with the initial downloaded data.
            So any initialization (eg. creating the file if writing to disk) needs to be done either before the call, or in the callback function.
            </para>
            <para>
            When the <see cref="F:ManagedBass.BassFlags.StreamStatus"/> flag is specified in the <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" /> call,
            HTTP and ICY tags may be passed to the callback during connection, before any stream data is received.
            The tags are given exactly as would be returned by <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)" />.
            You can destinguish between HTTP and ICY tags by checking what the first string starts with ("HTTP" or "ICY").
            </para>
            <para>
            A download callback function could be used in conjunction with a <see cref="F:ManagedBass.SyncFlags.MetadataReceived"/> sync set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />,
            to save individual tracks to disk from a Shoutcast stream.
            </para>
            </remarks>
        </member>
        <member name="T:ManagedBass.DSPProcedure">
            <summary>
            User defined DSP callback function (to be used with <see cref="M:ManagedBass.Bass.ChannelSetDSP(System.Int32,ManagedBass.DSPProcedure,System.IntPtr,System.Int32)" />).
            </summary>
            <param name="Handle">The DSP Handle (as returned by <see cref="M:ManagedBass.Bass.ChannelSetDSP(System.Int32,ManagedBass.DSPProcedure,System.IntPtr,System.Int32)" />).</param>
            <param name="Channel">Channel that the DSP is being applied to.</param>
            <param name="Buffer">
            The pointer to the Buffer to apply the DSP to.
            The sample data is in standard Windows PCM format - 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to 1 (not clipped, so can actually be outside this range).
            </param>
            <param name="Length">The number of bytes to process.</param>
            <param name="User">The User instance data given when <see cref="M:ManagedBass.Bass.ChannelSetDSP(System.Int32,ManagedBass.DSPProcedure,System.IntPtr,System.Int32)" /> was called.</param>
            <remarks>
            <para>A DSP function should obviously be as quick as possible... playing streams, MOD musics and other DSP functions can not be processed until it has finished.</para>
            <para>
            Some functions can cause problems if called from within a DSP (or stream) function.
            Do not call these functions from within a DSP callback:
            </para>
            <para>
            <see cref="M:ManagedBass.Bass.Stop" />, <see cref="M:ManagedBass.Bass.Free" />, <see cref="M:ManagedBass.Bass.MusicLoad(System.String,System.Int64,System.Int32,ManagedBass.BassFlags,System.Int32)" />,
            <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedure,System.IntPtr)" /> (or any other stream creation functions).
            </para>
            <para>Also, do not call <see cref="M:ManagedBass.Bass.ChannelRemoveDSP(System.Int32,System.Int32)" /> with the same DSP Handle as received by the callback,
            or <see cref="M:ManagedBass.Bass.ChannelStop(System.Int32)" />, <see cref="M:ManagedBass.Bass.MusicFree(System.Int32)" />, <see cref="M:ManagedBass.Bass.StreamFree(System.Int32)" /> with the same channel Handle as received by the callback.</para>
            <para>If the <see cref="P:ManagedBass.Bass.FloatingPointDSP"/> config option is set, then DSP callback functions will always be passed 32-bit floating-point sample data, regardless of what the channels' actual sample format is.</para>
            </remarks>
        </member>
        <member name="T:ManagedBass.FileCloseProcedure">
            <summary>
            User file stream close callback function (to be used with <see cref="T:ManagedBass.FileProcedures" />).
            </summary>
            <param name="User">The User instance data given when <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> was called.</param>
            <remarks>With a buffered file stream, this function is called as soon as reading reaches the end of the file.
            If the stream is freed before then, this function could be called while its <see cref="T:ManagedBass.FileReadProcedure" /> function is in progress.
            If that happens, the <see cref="T:ManagedBass.FileReadProcedure" /> function call should be immediately cancelled.
            </remarks>
        </member>
        <member name="T:ManagedBass.FileLengthProcedure">
            <summary>
            User file stream Length callback function (to be used with <see cref="T:ManagedBass.FileProcedures" />).
            </summary>
            <param name="User">The User instance data given when <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> was called.</param>
            <returns>The Length of the file in bytes.
            Returning 0 for a buffered file stream, makes BASS stream the file in blocks, and is equivalent to using the <see cref="F:ManagedBass.BassFlags.StreamDownloadBlocks"/> flag
            in the <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> call.</returns>
            <remarks>This function is called first thing, and is only used the once with buffered streams.
            With unbuffered streams, it may be used again when testing for EOF (end of file),
            allowing the file to grow in size.
            </remarks>
        </member>
        <member name="T:ManagedBass.FileReadProcedure">
            <summary>
            User file stream read callback function (to be used with <see cref="T:ManagedBass.FileProcedures" />).
            </summary>
            <param name="Buffer">Pointer to the Buffer to put the data in.</param>
            <param name="Length">Maximum number of bytes to read.</param>
            <param name="User">The User instance data given when <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> was called.</param>
            <returns>The number of bytes read... -1 = end of file, 0 = end of file (buffered file stream only).</returns>
            <remarks>During creation of the stream, this function should try to return the amount of data requested.
            After that, it can just return whatever is available up to the requested amount.
            <para>For an unbuffered file stream during playback, this function should be as quick as possible -
            any delays will not only affect the decoding of the current stream, but also all other streams and MOD musics that are playing.
            It is better to return less data (even none) rather than wait for more data.
            A buffered file stream isn't affected by delays like this, as this function runs in its own thread then.</para>
            </remarks>
        </member>
        <member name="T:ManagedBass.FileSeekProcedure">
            <summary>
            User file stream seek callback function (to be used with <see cref="T:ManagedBass.FileProcedures" />).
            </summary>
            <param name="Offset">Position in bytes to seek to.</param>
            <param name="User">The User instance data given when <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> was called.</param>
            <returns><see langword="true" /> if successful, else <see langword="false" />.</returns>
        </member>
        <member name="T:ManagedBass.RecordProcedure">
            <summary>
            User defined callback function to process recorded sample data.
            </summary>
            <param name="Handle">The recording Handle that the data is from.</param>
            <param name="Buffer">
            The pointer to the Buffer containing the recorded sample data.
            The sample data is in standard Windows PCM format, that is 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1.
            </param>
            <param name="Length">The number of bytes in the Buffer.</param>
            <param name="User">The User instance data given when <see cref="M:ManagedBass.Bass.RecordStart(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.RecordProcedure,System.IntPtr)" /> was called.</param>
            <returns>Return <see langword="true" /> to stop recording, and anything else to continue recording.</returns>
            <remarks>
            <see cref="M:ManagedBass.Bass.RecordFree" /> should not be used to free the recording device within a recording callback function.
            Nor should <see cref="M:ManagedBass.Bass.ChannelStop(System.Int32)" /> be used to stop the recording; return <see langword="false" /> to do that instead.
            </remarks>
        </member>
        <member name="T:ManagedBass.StreamProcedure">
            <summary>
            User stream writing callback delegate (to be used with <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedure,System.IntPtr)" />).
            </summary>
            <param name="Handle">The stream that needs writing.</param>
            <param name="Buffer">The pointer to the Buffer to write the sample data in. The sample data must be written in standard Windows PCM format - 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to 1.</param>
            <param name="Length">The number of bytes to write.</param>
            <param name="User">The User instance data given when <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedure,System.IntPtr)" /> was called.</param>
            <returns>The number of bytes written by the function, optionally using the <see cref="F:ManagedBass.StreamProcedureType.End"/> (<see cref="T:ManagedBass.StreamProcedure" />) flag to signify that the end of the stream is reached.</returns>
            <remarks>
            <para>A stream writing function should obviously be as quick as possible, because other streams (and MOD musics) can't be updated until it's finished.</para>
            <para>It is better to return less data quickly, rather than spending a long time delivering the amount BASS requested.</para>
            <para>Although a STREAMPROC may return less data than BASS requests, be careful not to do so by too much, too often. If the Buffer level gets too low, BASS will automatically stall playback of the stream, until the whole Buffer has refilled.</para>
            <para><see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> <see cref="T:ManagedBass.DataFlags"/> can be used to check the Buffer level, and <see cref="M:ManagedBass.Bass.ChannelIsActive(System.Int32)" /> can be used to check if playback has stalled.</para>
            <para>A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can also be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.</para>
            <para>If you do return less than the requested amount of data, the number of bytes should still equate to a whole number of samples.</para>
            <para>Some functions can cause problems if called from within a stream (or DSP) function. Do not call these functions from within a stream callback:</para>
            <para><see cref="M:ManagedBass.Bass.ChannelStop(System.Int32)" />, <see cref="M:ManagedBass.Bass.Free" />, <see cref="M:ManagedBass.Bass.MusicLoad(System.String,System.Int64,System.Int32,ManagedBass.BassFlags,System.Int32)" />, <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedure,System.IntPtr)" /> or any other stream creation functions.</para>
            <para>Also, do not call <see cref="M:ManagedBass.Bass.StreamFree(System.Int32)" /> or <see cref="M:ManagedBass.Bass.ChannelStop(System.Int32)" /> with the same Handle as received by the callback.</para>
            <para>When streaming multi-channel sample data, the channel order of each sample is as follows:</para>
            <para>3 channels: left-front, right-front, center.</para>
            <para>4 channels: left-front, right-front, left-rear/side, right-rear/side.</para>
            <para>6 channels(5.1): left-front, right-front, center, LFE, left-rear/side, right-rear/side.</para>
            <para>8 channels(7.1): left-front, right-front, center, LFE, left-rear/side, right-rear/side, left-rear center, right-rear center.</para>
            </remarks>
        </member>
        <member name="T:ManagedBass.SyncProcedure">
            <summary>
            User defined synchronizer callback function (see <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> for details).
            </summary>
            <param name="Handle">The sync Handle that has occured (as returned by <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />).</param>
            <param name="Channel">The channel that the sync occured on.</param>
            <param name="Data">Additional data associated with the sync's occurance.</param>
            <param name="User">The User instance data given when <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> was called.</param>
            <remarks>
            <para>
            BASS creates a single thread dedicated to executing sync callback functions, so a callback function should be quick as other syncs cannot be processed until it has finished.
            Attribute slides (<see cref="M:ManagedBass.Bass.ChannelSlideAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single,System.Int32)" />) are also performed by the sync thread, so are also affected if a sync callback takes a long time.</para>
            <para>"Mixtime" syncs <see cref="F:ManagedBass.SyncFlags.Mixtime"/> are not executed in the sync thread, but immediately in whichever thread triggers them.
            In most cases that will be an update thread, and so the same restrictions that apply to stream callbacks (<see cref="T:ManagedBass.StreamProcedure" />) also apply here.</para>
            <para>
            <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> can be used in a mixtime sync to implement custom looping,
            eg. set a <see cref="F:ManagedBass.SyncFlags.Position"/> sync at the loop end position and seek to the loop start position in the callback.
            </para>
            </remarks>
        </member>
        <member name="T:ManagedBass.Algorithm3D">
            <summary>
            Software 3D mixing algorithm modes to be used with <see cref="P:ManagedBass.Bass.Algorithm3D"/>.
            <remarks>
            On Windows, DirectX 7 or above is required for this option to have effect.
            On other platforms, only the <see cref="F:ManagedBass.Algorithm3D.Default"/> and <see cref="F:ManagedBass.Algorithm3D.Off"/> options are available.
            </remarks>
            </summary>
        </member>
        <member name="F:ManagedBass.Algorithm3D.Default">
            <summary>
            Default algorithm (currently translates to <see cref="F:ManagedBass.Algorithm3D.Off"/>)
            </summary>
        </member>
        <member name="F:ManagedBass.Algorithm3D.Off">
            <summary>
            Uses normal left and right panning.
            The vertical axis is ignored except for scaling of volume due to distance.
            <para>
            Doppler shift and volume scaling are still applied, but the 3D filtering is not performed.
            This is the most CPU efficient software implementation, but provides no virtual 3D audio effect.
            Head Related Transfer Function processing will not be done.
            Since only normal stereo panning is used, a channel using this algorithm may be accelerated by a 2D hardware voice if no free 3D hardware voices are available.
            </para>
            </summary>
        </member>
        <member name="T:ManagedBass.BassFlags">
            <summary>
            Stream/Sample/Music/Recording/AddOn create flags to be used with Stream Creation functions.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Default">
            <summary>
            0 = default create stream: 16 Bit, stereo, no Float, hardware mixing, no Loop, no 3D, no speaker assignments...
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Byte">
            <summary>
            Use 8-bit resolution. If neither this or the <see cref="F:ManagedBass.BassFlags.Float"/> flags are specified, then the stream is 16-bit.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Mono">
            <summary>
            Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo).
            This flag is automatically applied if <see cref="F:ManagedBass.DeviceInitFlags.Mono"/> was specified when calling <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Loop">
            <summary>
            Loop the file. This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Bass3D">
            <summary>
            Use 3D functionality.
            This is ignored if <see cref="F:ManagedBass.DeviceInitFlags.Device3D"/> wasn't specified when calling <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/>.
            3D streams must be mono (chans=1).
            The Speaker flags can not be used together with this flag.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Float">
            <summary>
            Use 32-bit floating-point sample data (see Floating-Point Channels for details).
            WDM drivers or the <see cref="F:ManagedBass.BassFlags.Decode"/> flag are required to use this flag.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Prescan">
            <summary>
            Enable pin-point accurate seeking (to the exact byte) on the MP3/MP2/MP1 stream or MOD music.
            This also increases the time taken to create the stream,
            due to the entire file being pre-scanned for the seek points.
            Note: This flag is ONLY needed for files with a VBR, files with a CBR are always accurate.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.AutoFree">
            <summary>
            Automatically free the music or stream's resources when it has reached the end,
            or when <see cref="M:ManagedBass.Bass.ChannelStop(System.Int32)"/> or <see cref="M:ManagedBass.Bass.Stop"/> is called.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.RestrictDownloadRate">
            <summary>
            Restrict the download rate of the file to the rate required to sustain playback.
            If this flag is not used, then the file will be downloaded as quickly as possible.
            This flag has no effect on "unbuffered" streams (Buffer=false).
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.StreamDownloadBlocks">
            <summary>
            Download and play the file in smaller chunks.
            Uses a lot less memory than otherwise,
            but it's not possible to seek or loop the stream - once it's ended,
            the file must be opened again to play it again.
            This flag will automatically be applied when the file Length is unknown.
            This flag also has the effect of resticting the download rate.
            This flag has no effect on "unbuffered" streams (Buffer=false).
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Decode">
            <summary>
            Decode the sample data, without outputting it.
            Use <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data.
            Bass.SoftwareMixing/<see cref="F:ManagedBass.BassFlags.Bass3D"/>/BassFlags.FX/<see cref="F:ManagedBass.BassFlags.AutoFree"/> are all ignored when using this flag, as are the Speaker flags.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.StreamStatus">
            <summary>
            Pass status info (HTTP/ICY tags) from the server to the <see cref="T:ManagedBass.DownloadProcedure"/> callback during connection.
            This can be useful to determine the reason for a failure.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.AsyncFile">
            <summary>
            Use an async look-ahead cache.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Unicode">
            <summary>
            File is a Unicode (16-bit characters) filename
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.FxBpmBackground">
            <summary>
            BassFx add-on: If in use, then you can do other stuff while detection's in process.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.FXBpmMult2">
            <summary>
            BassFx add-on: If in use, then will auto multiply bpm by 2 (if BPM &lt; MinBPM*2)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.FxTempoAlgorithmLinear">
            <summary>
            BassFx add-on (<see cref="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)"/>): Uses a linear interpolation mode (simple).
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.FxTempoAlgorithmCubic">
            <summary>
            BassFx add-on (<see cref="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)"/>): Uses a cubic interpolation mode (recommended, default).
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.FxTempoAlgorithmShannon">
            <summary>
            BassFx add-on (<see cref="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)"/>):
            Uses a 8-tap band-limited Shannon interpolation (complex, but not much better than cubic).
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.FxFreeSource">
            <summary>
            BassFx add-on: Free the source Handle as well?
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MidiNoHeader">
            <summary>
            BASSMIDI add-on: Don't send a WAVE header to the encoder.
            If this flag is used then the sample format (mono 16-bit)
            must be passed to the encoder some other way, eg. via the command-line.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Midi16Bit">
            <summary>
            BASSMIDI add-on: Reduce 24-bit sample data to 16-bit before encoding.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MidiNoSystemReset">
            <summary>
            BASSMIDI add-on: Ignore system reset events (<see cref="F:ManagedBass.Midi.MidiEventType.System"/>) when the system mode is unchanged.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MidiDecayEnd">
            <summary>
            BASSMIDI add-on: Let the sound decay naturally (including reverb) instead of stopping it abruptly at the end of the file.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/> methods.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MidiNoFx">
            <summary>
            BASSMIDI add-on: Disable the MIDI reverb/chorus processing.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MidiDecaySeek">
            <summary>
            BASSMIDI add-on: Let the old sound decay naturally (including reverb) when changing the position, including looping.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>, and can also be used in <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)"/>
            calls to have it apply to particular position changes.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MidiNoCrop">
            <summary>
            BASSMIDI add-on: Do not remove empty space (containing no events) from the end of the file.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MidiNoteOff1">
            <summary>
            BASSMIDI add-on: Only release the oldest instance upon a note off event (<see cref="F:ManagedBass.Midi.MidiEventType.Note"/> with velocity=0)
            when there are overlapping instances of the note.
            Otherwise all instances are released.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MidiFontMemoryMap">
            <summary>
            BASSMIDI add-on: Map the file into memory.
            This flag is ignored if the soundfont is packed as the sample data cannot be played directly from a mapping;
            it needs to be decoded.
            This flag is also ignored if the file is too large to be mapped into memory.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MidiFontXGDRUMS">
            <summary>
            Use bank 127 in the soundfont for XG drum kits.
            When an XG drum kit is needed, bank 127 in soundfonts that have this flag set will be checked first,
            before falling back to bank 128 (the standard SF2 drum kit bank) if it is not available there.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SincInterpolation">
            <summary>
            Music and BASSMIDI add-on: Use sinc interpolated sample mixing.
            This increases the sound quality, but also requires more CPU.
            Otherwise linear interpolation is used.
            Music: If neither this or the <see cref="F:ManagedBass.BassFlags.MusicNonInterpolated"/> flag is specified, linear interpolation is used.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicRamp">
            <summary>
            Music: Use "normal" ramping (as used in FastTracker 2).
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicSensitiveRamping">
            <summary>
            Music: Use "sensitive" ramping.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicSurround">
            <summary>
            Music: Apply XMPlay's surround sound to the music (ignored in mono).
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicSurround2">
            <summary>
            Music: Apply XMPlay's surround sound mode 2 to the music (ignored in mono).
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicFT2Mod">
            <summary>
            Music: Play .MOD file as FastTracker 2 would.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicFT2PAN">
            <summary>
            Apply FastTracker 2 panning to XM files.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicPT1Mod">
            <summary>
            Music: Play .MOD file as ProTracker 1 would.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicPositionReset">
            <summary>
            Music: Stop all notes when seeking (using <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)"/>).
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicNonInterpolated">
            <summary>
            Music: Use non-interpolated mixing.
            This generally reduces the sound quality, but can be good for chip-tunes.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicStopBack">
            <summary>
            Music: Stop the music when a backward jump effect is played.
            This stops musics that never reach the end from going into endless loops.
            Some MOD musics are designed to jump all over the place,
            so this flag would cause those to be stopped prematurely.
            If this flag is used together with the <see cref="F:ManagedBass.BassFlags.Loop"/> flag,
            then the music would not be stopped but any <see cref="F:ManagedBass.SyncFlags.End"/> sync would be triggered.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicNoSample">
            <summary>
            Music: Don't load the samples.
            This reduces the time taken to load the music, notably with MO3 files,
            which is useful if you just want to get the name and Length of the music without playing it.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MusicPositionResetEx">
            <summary>
            Music: Stop all notes and reset bpm/etc when seeking.
            This flag can be toggled at any time using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MuteMax">
            <summary>
            Sample: muted at max distance (3D only)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.VAM">
            <summary>
            Sample: uses the DX7 voice allocation and management
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SampleOverrideLowestVolume">
            <summary>
            Sample: override lowest volume
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SampleOverrideLongestPlaying">
            <summary>
            Sample: override longest playing
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SampleOverrideDistance">
            <summary>
            Sample: override furthest from listener (3D only)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.CDSubChannel">
            <summary>
            BASSCD add-on: Read sub-channel data.
            96 bytes of de-interleaved sub-channel data will be returned after each 2352 bytes of audio.
            This flag can not be used with the <see cref="F:ManagedBass.BassFlags.Float"/> flag,
            and is ignored if the <see cref="F:ManagedBass.BassFlags.Decode"/> flag is not used.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.CDSubchannelNoHW">
            <summary>
            BASSCD add-on: Read sub-channel data, without using any hardware de-interleaving.
            This is identical to the <see cref="F:ManagedBass.BassFlags.CDSubChannel"/> flag, except that the
            de-interleaving is always performed by BASSCD even if the drive is apparently capable of de-interleaving itself.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.CdC2Errors">
            <summary>
            BASSCD add-on: Include C2 error info.
            296 bytes of C2 error info is returned after each 2352 bytes of audio (and optionally 96 bytes of sub-channel data).
            This flag cannot be used with the <see cref="F:ManagedBass.BassFlags.Float"/> flag, and is ignored if the <see cref="F:ManagedBass.BassFlags.Decode"/> flag is not used.
            The first 294 bytes contain the C2 error bits (one bit for each byte of audio),
            followed by a byte containing the logical OR of all 294 bytes,
            which can be used to quickly check if there were any C2 errors.
            The final byte is just padding.
            Note that if you request both sub-channel data and C2 error info, the C2 info will come before the sub-channel data!
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SplitSlave">
            <summary>
            BASSmix add-on: only read buffered data.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MixerResume">
            <summary>
            BASSmix add-on: resume a stalled mixer immediately upon new/unpaused source
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MixerPositionEx">
            <summary>
            BASSmix add-on: enable <see cref="M:ManagedBass.Mix.BassMix.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags,System.Int32)"/> support.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MixerBuffer">
            <summary>
            BASSmix add-on: Buffer source data for <see cref="M:ManagedBass.Mix.BassMix.ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> and <see cref="M:ManagedBass.Mix.BassMix.ChannelGetLevel(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MixerLimit">
            <summary>
            BASSmix add-on: Limit mixer processing to the amount available from this source.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MixerEnd">
            <summary>
            BASSmix add-on: end the stream when there are no sources
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MixerMatrix">
            <summary>
            BASSmix add-on: Matrix mixing
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MixerNonStop">
            <summary>
            BASSmix add-on: don't stall when there are no sources
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MixerPause">
            <summary>
            BASSmix add-on: don't process the source
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MixerDownMix">
            <summary>
            BASSmix add-on: downmix to stereo (or mono if mixer is mono)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.MixerNoRampin">
            <summary>
            BASSmix add-on: don't ramp-in the start
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.RecordPause">
            <summary>
            Recording: Start the recording paused. Use <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)"/> to start it.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.RecordEchoCancel">
            <summary>
            Recording: Enable Echo Cancellation (only available on certain devices, like iOS).
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.RecordAGC">
            <summary>
            Recording: Enable Automatic Gain Control (only available on certain devices, like iOS).
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerFront">
            <summary>
            Front speakers (channel 1/2)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerRear">
            <summary>
            Rear/Side speakers (channel 3/4)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerCenterLFE">
            <summary>
            Center and LFE speakers (5.1, channel 5/6)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerRearCenter">
            <summary>
            Rear Center speakers (7.1, channel 7/8)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair1">
            <summary>
            Speakers Pair 1
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair2">
            <summary>
            Speakers Pair 2
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair3">
            <summary>
            Speakers Pair 3
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair4">
            <summary>
            Speakers Pair 4
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair5">
            <summary>
            Speakers Pair 5
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair6">
            <summary>
            Speakers Pair 6
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair7">
            <summary>
            Speakers Pair 7
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair8">
            <summary>
            Speakers Pair 8
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair9">
            <summary>
            Speakers Pair 9
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair10">
            <summary>
            Speakers Pair 10
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair11">
            <summary>
            Speakers Pair 11
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair12">
            <summary>
            Speakers Pair 12
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair13">
            <summary>
            Speakers Pair 13
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair14">
            <summary>
            Speakers Pair 14
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerPair15">
            <summary>
            Speakers Pair 15
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerLeft">
            <summary>
            Speaker Modifier: left channel only
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerRight">
            <summary>
            Speaker Modifier: right channel only
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerFrontLeft">
            <summary>
            Front Left speaker only (channel 1)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerRearLeft">
            <summary>
            Rear/Side Left speaker only (channel 3)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerCenter">
            <summary>
            Center speaker only (5.1, channel 5)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerRearCenterLeft">
            <summary>
            Rear Center Left speaker only (7.1, channel 7)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerFrontRight">
            <summary>
            Front Right speaker only (channel 2)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerRearRight">
            <summary>
            Rear/Side Right speaker only (channel 4)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerLFE">
            <summary>
            LFE speaker only (5.1, channel 6)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.SpeakerRearCenterRight">
            <summary>
            Rear Center Right speaker only (7.1, channel 8)
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.AacFrame960">
            <summary>
            BassAac add-on: use 960 samples per frame
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.AacStereo">
            <summary>
            BassAac add-on: Downmatrix to Stereo
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.DSDOverPCM">
            <summary>
            BassDSD add-on: Produce DSD-over-PCM data (with 0x05/0xFA markers). DSD-over-PCM data is 24-bit, so the <see cref="F:ManagedBass.BassFlags.Float"/> flag is required.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.DSDRaw">
            <summary>
            BassDSD add-on: Produce raw DSD data instead of PCM. The DSD data is in blocks of 8 bits (1 byte) per-channel with the MSB being first/oldest.
            DSD data is not playable by BASS, so the <see cref="F:ManagedBass.BassFlags.Decode"/> flag is required.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Ac3DownmixStereo">
            <summary>
            BassAC3 add-on: downmix to stereo
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Ac3DownmixQuad">
            <summary>
            BASS_AC3 add-on: downmix to quad
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Ac3DownmixDolby">
            <summary>
            BASS_AC3 add-on: downmix to dolby
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.Ac3DRC">
            <summary>
            BASS_AC3 add-on: enable dynamic range compression
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.DShowNoAudioProcessing">
            <summary>
            DSHOW add-on: Use this flag to disable audio processing.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.DShowStreamMix">
            <summary>
            DSHOW add-on: Use this flag to enable mixing video on a channel.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.DShowAutoDVD">
            <summary>
            DSHOW add-on: Use this flag to enable auto dvd functions(on mouse down, keys etc).
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.DShowLoop">
            <summary>
            DSHOW add-on: Use this flag to restart the stream when it's finished.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.DShowVideoProcessing">
            <summary>
            DSHOW add-on: Use this to enable video processing.
            </summary>
        </member>
        <member name="F:ManagedBass.BassFlags.WVStereo">
            <summary>
            BassWV add-on: Limit to stereo
            </summary>
        </member>
        <member name="F:ManagedBass.BASSInfoFlags.None">
            <summary>
            None of the flags are set
            </summary>
        </member>
        <member name="F:ManagedBass.BASSInfoFlags.ContinuousRate">
            <summary>
            The device supports all sample rates between minrate and maxrate.
            </summary>
        </member>
        <member name="F:ManagedBass.BASSInfoFlags.EmulatedDrivers">
            <summary>
            The device's drivers do NOT have DirectSound support, so it is being emulated.
            Updated drivers should be installed.
            </summary>
        </member>
        <member name="F:ManagedBass.BASSInfoFlags.Certified">
            <summary>
            The device driver has been certified by Microsoft.
            This flag is always set on WDM drivers.
            </summary>
        </member>
        <member name="F:ManagedBass.BASSInfoFlags.Mono">
            <summary>
            Mono samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="F:ManagedBass.BASSInfoFlags.Stereo">
            <summary>
            Stereo samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="F:ManagedBass.BASSInfoFlags.Secondary8Bit">
            <summary>
            8-bit samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="F:ManagedBass.BASSInfoFlags.Secondary16Bit">
            <summary>
            16-bit samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="T:ManagedBass.ChannelAttribute">
            <summary>
            Channel attribute options used by <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" /> and <see cref="M:ManagedBass.Bass.ChannelGetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single@)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.Frequency">
             <summary>
             The sample rate of a channel... 0 = original rate (when the channel was created).
             <para>
             This attribute applies to playback of the channel, and does not affect the
             channel's sample data, so has no real effect on decoding channels.
             It is still adjustable though, so that it can be used by the BassMix add-on,
             and anything else that wants to use it.
             </para>
             <para>
             It is not possible to change the sample rate of a channel if the "with FX
             flag" DX8 effect implementation enabled on it, unless DirectX 9 or above is installed.
             </para>
             <para>
             Increasing the sample rate of a stream or MOD music increases its CPU usage,
             and reduces the Length of its playback Buffer in terms of time.
             If you intend to raise the sample rate above the original rate, then you may also need
             to increase the Buffer Length via the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/>
             config option to avoid break-ups in the sound.
             </para>
            
             <para><b>Platform-specific</b></para>
             <para>On Windows, the sample rate will get rounded down to a whole number during playback.</para>
             </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.Volume">
            <summary>
            The volume level of a channel... 0 (silent) to 1 (full).
            <para>This can go above 1.0 on decoding channels.</para>
            <para>
            This attribute applies to playback of the channel, and does not affect the
            channel's sample data, so has no real effect on decoding channels.
            It is still adjustable though, so that it can be used by the BassMix add-on,
            and anything else that wants to use it.
            </para>
            <para>
            When using <see cref="M:ManagedBass.Bass.ChannelSlideAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single,System.Int32)"/>
            to slide this attribute, a negative volume value can be used to fade-out and then stop the channel.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.Pan">
             <summary>
             The panning/balance position of a channel... -1 (Full Left) to +1 (Full Right), 0 = Centre.
             <para>
             This attribute applies to playback of the channel, and does not affect the
             channel's sample data, so has no real effect on decoding channels.
             It is still adjustable though, so that it can be used by the <see cref="T:ManagedBass.Mix.BassMix"/> add-on,
             and anything else that wants to use it.
             </para>
             <para>
             It is not possible to set the pan position of a 3D channel.
             It is also not possible to set the pan position when using speaker assignment, but if needed,
             it can be done via a <see cref="T:ManagedBass.DSPProcedure"/> instead (not on mono channels).
             </para>
            
             <para><b>Platform-specific</b></para>
             <para>
             On Windows, this attribute has no effect when speaker assignment is used,
             except on Windows Vista and newer with the Bass.VistaSpeakerAssignment config option enabled.
             Balance control could be implemented via a <see cref="T:ManagedBass.DSPProcedure"/> instead
             </para>
             </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.EaxMix">
            <summary>
            The wet (reverb) / dry (no reverb) mix ratio... 0 (full dry) to 1 (full wet), -1 = automatically calculate the mix based on the distance (the default).
            <para>For a sample, stream, or MOD music channel with 3D functionality.</para>
            <para>
            Obviously, EAX functions have no effect if the output device does not support EAX.
            <see cref="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)"/> can be used to check that.
            </para>
            <para>
            EAX only affects 3D channels, but EAX functions do not require <see cref="M:ManagedBass.Bass.Apply3D"/> to apply the changes.
            LastError.NoEAX: The channel does not have EAX support.
            EAX only applies to 3D channels that are mixed by the hardware/drivers.
            <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)"/> can be used to check if a channel is being mixed by the hardware.
            EAX is only supported on Windows.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.NoBuffer">
            <summary>
            Non-Windows: Disable playback buffering?... 0 = no, else yes..
            <para>
            A playing channel is normally asked to render data to its playback Buffer in advance,
            via automatic Buffer updates or the <see cref="M:ManagedBass.Bass.Update(System.Int32)"/> and <see cref="M:ManagedBass.Bass.ChannelUpdate(System.Int32,System.Int32)"/> functions,
            ready for mixing with other channels to produce the final mix that is given to the output device.
            </para>
            <para>
            When this attribute is switched on (the default is off), that buffering is skipped and
            the channel will only be asked to produce data as it is needed during the generation of the final mix.
            This allows the lowest latency to be achieved, but also imposes tighter timing requirements
            on the channel to produce its data and apply any DSP/FX (and run mixtime syncs) that are set on it;
            if too long is taken, there will be a break in the output, affecting all channels that are playing on the same device.
            </para>
            <para>
            The channel's data is still placed in its playback Buffer when this attribute is on,
            which allows <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> and <see cref="M:ManagedBass.Bass.ChannelGetLevel(System.Int32)"/> to be used, although there is
            likely to be less data available to them due to the Buffer being less full.
            </para>
            <para>This attribute can be changed mid-playback.</para>
            <para>If switched on, any already buffered data will still be played, so that there is no break in sound.</para>
            <para>This attribute is not available on Windows, as BASS does not generate the final mix.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.CPUUsage">
            <summary>
            The CPU usage of a channel. (in percentage).
            <para>
            This attribute gives the percentage of CPU that the channel is using,
            including the time taken by decoding and DSP processing, and any FX that are
            not using the "with FX flag" DX8 effect implementation.
            It does not include the time taken to add the channel's data to the final output mix during playback.
            The processing of some add-on stream formats may also not be entirely included,
            if they use additional decoding threads; see the add-on documentation for details.
            </para>
            <para>
            Like <see cref="P:ManagedBass.Bass.CPUUsage"/>, this function does not strictly tell the CPU usage, but rather how timely the processing is.
            For example, if it takes 10ms to generate 100ms of data, that would be 10%.
            </para>
            <para>
            If the reported usage exceeds 100%, that means the channel's data is taking longer to generate than to play.
            The duration of the data is based on the channel's current sample rate (<see cref="F:ManagedBass.ChannelAttribute.Frequency"/>).
            A channel's CPU usage is updated whenever it generates data.
            That could be during a playback Buffer update cycle, or a <see cref="M:ManagedBass.Bass.Update(System.Int32)"/> call, or a <see cref="M:ManagedBass.Bass.ChannelUpdate(System.Int32,System.Int32)"/> call.
            For a decoding channel, it would be in a <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> or <see cref="M:ManagedBass.Bass.ChannelGetLevel(System.Int32)"/> call.
            </para>
            <para>This attribute is read-only, so cannot be modified via <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)"/>.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.SampleRateConversion">
            <summary>
            The sample rate conversion quality of a channel
            <para>
            0 = linear interpolation, 1 = 8 point sinc interpolation, 2 = 16 point sinc interpolation, 3 = 32 point sinc interpolation.
            Other values are also accepted but will be interpreted as 0 or 3, depending on whether they are lower or higher.
            </para>
            <para>
            When a channel has a different sample rate to what the output device is using,
            the channel's sample data will need to be converted to match the output device's rate during playback.
            This attribute determines how that is done.
            The linear interpolation option uses less CPU, but the sinc interpolation gives better sound quality (less aliasing),
            with the quality and CPU usage increasing with the number of points.
            A good compromise for lower spec systems could be to use sinc interpolation for music playback and linear interpolation for sound effects.
            </para>
            <para>
            Whenever possible, a channel's sample rate should match the output device's rate to avoid the need for any sample rate conversion.
            The device's sample rate could be used in <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedure,System.IntPtr)" />
            or <see cref="M:ManagedBass.Bass.MusicLoad(System.String,System.Int64,System.Int32,ManagedBass.BassFlags,System.Int32)" /> or <see cref="T:ManagedBass.Midi.BassMidi" /> stream creation calls, for example.
            </para>
            <para>
            The sample rate conversion occurs (when required) during playback,
            after the sample data has left the channel's playback Buffer, so it does not affect the data delivered by <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" />.
            Although this attribute has no direct effect on decoding channels,
            it is still available so that it can be used by the <see cref="T:ManagedBass.Mix.BassMix" /> add-on and anything else that wants to use it.
            </para>
            <para>
            This attribute can be set at any time, and changes take immediate effect.
            A channel's initial setting is determined by the <see cref="P:ManagedBass.Bass.SRCQuality" /> config option,
            or <see cref="P:ManagedBass.Bass.SampleSRCQuality" /> in the case of a sample channel.
            </para>
            <para><b>Platform-specific</b></para>
            <para>On Windows, sample rate conversion is handled by Windows or the output device/driver rather than BASS, so this setting has no effect on playback there.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.NetworkResumeBufferLevel">
            <summary>
            The download Buffer level required to resume stalled playback in percent... 0 - 100 (the default is 50%).
            <para>
            This attribute determines what percentage of the download Buffer (<see cref="P:ManagedBass.Bass.NetBufferLength"/>)
            needs to be filled before playback of a stalled internet stream will resume.
            It also applies to 'buffered' User file streams created with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)"/>.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.ScannedInfo">
            <summary>
            The scanned info of a channel.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MusicAmplify">
            <summary>
            The amplification level of a MOD music... 0 (min) to 100 (max).
            <para>This will be rounded down to a whole number.</para>
            <para>
            As the amplification level get's higher, the sample data's range increases, and therefore, the resolution increases.
            But if the level is set too high, then clipping can occur, which can result in distortion of the sound.
            You can check the current level of a MOD music at any time by <see cref="M:ManagedBass.Bass.ChannelGetLevel(System.Int32)"/>.
            By doing so, you can decide if a MOD music's amplification level needs adjusting.
            The default amplification level is 50.
            </para>
            <para>
            During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering.
            To reduce the delay, use the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> config option to reduce the Buffer Length.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MusicPanSeparation">
            <summary>
            The pan separation level of a MOD music... 0 (min) to 100 (max), 50 = linear.
            <para>
            This will be rounded down to a whole number.
            By default BASS uses a linear panning "curve".
            If you want to use the panning of FT2, use a pan separation setting of around 35.
            To use the Amiga panning (ie. full left and right) set it to 100.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MusicPositionScaler">
            <summary>
            The position scaler of a MOD music... 1 (min) to 256 (max).
            <para>
            This will be rounded down to a whole number.
            When calling <see cref="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)"/>, the row (HIWORD) will be scaled by this value.
            By using a higher scaler, you can get a more precise position indication.
            The default scaler is 1.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MusicBPM">
            <summary>
            The BPM of a MOD music... 1 (min) to 255 (max).
            <para>
            This will be rounded down to a whole number.
            This attribute is a direct mapping of the MOD's BPM, so the value can be changed via effects in the MOD itself.
            Note that by changing this attribute, you are changing the playback Length.
            During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering.
            To reduce the delay, use the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> config option to reduce the Buffer Length.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MusicSpeed">
            <summary>
            The speed of a MOD music... 0 (min) to 255 (max).
            <para>
            This will be rounded down to a whole number.
            This attribute is a direct mapping of the MOD's speed, so the value can be changed via effects in the MOD itself.
            The "speed" is the number of ticks per row.
            Setting it to 0, stops and ends the music.
            Note that by changing this attribute, you are changing the playback Length.
            During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering.
            To reduce the delay, use the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> config option to reduce the Buffer Length.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MusicVolumeGlobal">
            <summary>
            The global volume level of a MOD music... 0 (min) to 64 (max, 128 for IT format).
            <para>
            This will be rounded down to a whole number.
            This attribute is a direct mapping of the MOD's global volume, so the value can be changed via effects in the MOD itself.
            The "speed" is the number of ticks per row.
            Setting it to 0, stops and ends the music.
            Note that by changing this attribute, you are changing the playback Length.
            During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering.
            To reduce the delay, use the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> config option to reduce the Buffer Length.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MusicActiveChannelCount">
            <summary>
            The number of active channels in a MOD music.
            <para>
            This attribute gives the number of channels (including virtual) that are currently active in the decoder,
            which may not match what is being heard during playback due to buffering.
            To reduce the time difference, use the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> config option to reduce the Buffer Length.
            This attribute is read-only, so cannot be modified via <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)"/>.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MusicVolumeChannel">
            <summary>
            The volume level... 0 (silent) to 1 (full) of a channel in a MOD music + channel#.
            <para>channel: The channel to set the volume of... 0 = 1st channel.</para>
            <para>
            The volume curve used by this attribute is always linear, eg. 0.5 = 50%.
            The <see cref="P:ManagedBass.Bass.LogarithmicVolumeCurve"/> config option setting has no effect on this.
            The volume level of all channels is initially 1 (full).
            This attribute can also be used to count the number of channels in a MOD Music.
            During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering.
            To reduce the delay, use the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> config option to reduce the Buffer Length.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MusicVolumeInstrument">
            <summary>
            The volume level... 0 (silent) to 1 (full) of an instrument in a MOD music + inst#.
            <para>inst: The instrument to set the volume of... 0 = 1st instrument.</para>
            <para>
            The volume curve used by this attribute is always linear, eg. 0.5 = 50%.
            The <see cref="P:ManagedBass.Bass.LogarithmicVolumeCurve"/> config option setting has no effect on this.
            The volume level of all instruments is initially 1 (full).
            For MOD formats that do not use instruments, read "sample" for "instrument".
            This attribute can also be used to count the number of instruments in a MOD music.
            During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering.
            To reduce the delay, use the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> config option to reduce the Buffer Length.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.Tempo">
            <summary>
            BassFx Tempo: The Tempo in percents (-95%..0..+5000%).
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.Pitch">
            <summary>
            BassFx Tempo: The Pitch in semitones (-60..0..+60).
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.TempoFrequency">
            <summary>
            BassFx Tempo: The Samplerate in Hz, but calculates by the same % as <see cref="F:ManagedBass.ChannelAttribute.Tempo"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.TempoUseAAFilter">
            <summary>
            BassFx Tempo Option: Use FIR low-pass (anti-alias) filter (gain speed, lose quality)? true=1 (default), false=0.
            <para>See <see cref="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)"/> for details.</para>
            <para>On iOS, Android, WinCE and Linux ARM platforms this is by default disabled for lower CPU usage.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.TempoAAFilterLength">
            <summary>
            BassFx Tempo Option: FIR low-pass (anti-alias) filter Length in taps (8 .. 128 taps, default = 32, should be %4).
            <para>See <see cref="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)"/> for details.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.TempoUseQuickAlgorithm">
            <summary>
            BassFx Tempo Option: Use quicker tempo change algorithm (gain speed, lose quality)? true=1, false=0 (default).
            <para>See <see cref="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)"/> for details.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.TempoSequenceMilliseconds">
            <summary>
            BassFx Tempo Option: Tempo Sequence in milliseconds (default = 82).
            <para>See <see cref="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)"/> for details.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.TempoSeekWindowMilliseconds">
            <summary>
            BassFx Tempo Option: SeekWindow in milliseconds (default = 14).
            <para>See <see cref="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)"/> for details.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.TempoOverlapMilliseconds">
            <summary>
            BassFx Tempo Option: Tempo Overlap in milliseconds (default = 12).
            <para>See <see cref="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)"/> for details.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.TempoPreventClick">
            <summary>
            BassFx Tempo Option: Prevents clicks with tempo changes (default = FALSE).
            <para>See <see cref="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)"/> for details.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.ReverseDirection">
            <summary>
            Playback direction (-1 = Reverse or 1 = Forward).
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MidiPPQN">
            <summary>
            BASSMIDI: Gets the Pulses Per Quarter Note (or ticks per beat) value of the MIDI file.
            <para>
            This attribute is the number of ticks per beat as defined by the MIDI file;
            it will be 0 for MIDI streams created via <see cref="M:ManagedBass.Midi.BassMidi.CreateStream(System.Int32,ManagedBass.BassFlags,System.Int32)"/>,
            It is read-only, so can't be modified via <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)"/>.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MidiCPU">
            <summary>
            BASSMIDI: The maximum percentage of CPU time that a MIDI stream can use... 0 to 100, 0 = unlimited.
            <para>
            It is not strictly the CPU usage that is measured, but rather how timely the stream is able to render data.
            For example, a limit of 50% would mean that the rendering would need to be at least 2x real-time speed.
            When the limit is exceeded, <see cref="T:ManagedBass.Midi.BassMidi"/> will begin killing voices, starting with the  most quiet.
            When the CPU usage is limited, the stream's samples are loaded asynchronously
            so that any loading delays (eg. due to slow disk) do not hold up the stream for too long.
            If a sample cannot be loaded in time, then it will be silenced
            until it is available and the stream will continue playing other samples as normal in the meantime.
            This does not affect sample loading via <see cref="M:ManagedBass.Midi.BassMidi.StreamLoadSamples(System.Int32)"/>, which always operates synchronously.
            By default, a MIDI stream will have no CPU limit.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MidiChannels">
            <summary>
            BASSMIDI: The number of MIDI channels in a MIDI stream... 1 (min) - 128 (max).
            <para>
            For a MIDI file stream, the minimum is 16.
            New channels are melodic by default.
            Any notes playing on a removed channel are immediately stopped.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MidiVoices">
            <summary>
            BASSMIDI: The maximum number of samples to play at a time (polyphony) in a MIDI stream... 1 (min) - 1000 (max).
            <para>
            If there are currently more voices active than the new limit, then some voices will be killed to meet the limit.
            The number of voices currently active is available via the Voices attribute.
            A MIDI stream will initially have a default number of voices as determined by the Voices config option.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MidiVoicesActive">
            <summary>
            BASSMIDI: The number of samples (voices) currently playing in a MIDI stream.
            <para>This attribute is read-only, so cannot be modified via <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)"/>.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MidiTrackVolume">
            <summary>
            BASSMIDI: The volume level (0.0=silent, 1.0=normal/default) of a track in a MIDI file stream + track#.
            <para>track#: The track to set the volume of... 0 = first track.</para>
            <para>
            The volume curve used by this attribute is always linear, eg. 0.5 = 50%.
            The <see cref="P:ManagedBass.Bass.LogarithmicVolumeCurve"/> config option setting has no effect on this.
            During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering.
            To reduce the delay, use the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> config option to reduce the Buffer Length.
            This attribute can also be used to count the number of tracks in a MIDI file stream.
            MIDI streams created via <see cref="M:ManagedBass.Midi.BassMidi.CreateStream(System.Int32,ManagedBass.BassFlags,System.Int32)"/> do not have any tracks.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.OpusOriginalFrequency">
            <summary>
            BassOpus: The sample rate of an Opus stream's source material.
            <para>
            Opus streams always have a sample rate of 48000 Hz, and an Opus encoder will resample the source material to that if necessary.
            This attribute presents the original sample rate, which may be stored in the Opus file header.
            This attribute is read-only, so cannot be modified via <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.DSDGain">
            <summary>
            BassDSD: The gain (in decibels) applied when converting to PCM.
            </summary>
            <remarks>
            This attribute is only applicable when converting to PCM, and is unavailable when producing DSD-over-PCM or raw DSD data.
            The default setting is determined by the <see cref="F:ManagedBass.ChannelAttribute.DSDGain" /> config option
            </remarks>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.DSDRate">
            <summary>
            BassDSD: The DSD sample rate.
            </summary>
            <remarks>This attribute is read-only, so cannot be modified via <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />.</remarks>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.MixerLatency">
            <summary>
            BassMix: Custom output latency in seconds... default = 0 (no accounting for latency). Changes take immediate effect.
            </summary>
            <remarks>
            When a mixer is played by BASS, the <see cref="M:ManagedBass.Mix.BassMix.ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>, <see cref="M:ManagedBass.Mix.BassMix.ChannelGetLevel(System.Int32)"/>, <see cref="M:ManagedBass.Mix.BassMix.ChannelGetLevel(System.Int32,System.Single[],System.Single,ManagedBass.LevelRetrievalFlags)"/>, and <see cref="M:ManagedBass.Mix.BassMix.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)"/> functions will get the output latency and account for that so that they reflect what is currently being heard, but that cannot be done when a different output system is used, eg. ASIO or WASAPI.
            In that case, this attribute can be used to tell the mixer what the output latency is, so that those functions can still account for it.
            The mixer needs to have the <see cref="F:ManagedBass.BassFlags.Decode"/> and <see cref="F:ManagedBass.BassFlags.MixerPositionEx"/> flags set to use this attribute. 
            </remarks>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.Bitrate">
            <summary>
            The average bitrate of a file stream. 
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelAttribute.NoRamp">
            <summary>
            Disable playback ramping? 
            </summary>
        </member>
        <member name="T:ManagedBass.ChannelType">
            <summary>
            Channel Type flags to be used with <see cref="T:ManagedBass.ChannelInfo" /> (see also <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" />).
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.Unknown">
            <summary>
            Unknown channel format.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.Sample">
            <summary>
            Sample channel. (HCHANNEL)
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.Recording">
            <summary>
            Recording channel. (HRECORD)
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.MO3">
            <summary>
            MO3 format music.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.Stream">
            <summary>
            User sample stream.
            This can also be used as a flag to test if the channel is any kind of HSTREAM.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.OGG">
            <summary>
            OGG format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.MP1">
            <summary>
            MP1 format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.MP2">
            <summary>
            MP2 format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.MP3">
            <summary>
            MP3 format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.AIFF">
            <summary>
            WAV format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.MF">
            <summary>
            Media Foundation codec stream. Additional information is avaliable via the <see cref="F:ManagedBass.TagType.MF"/> tag.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.CD">
            <summary>
            Audio-CD, CDA
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.WMA">
            <summary>
            WMA format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.WMA_MP3">
            <summary>
            MP3 over WMA format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.WINAMP">
            <summary>
            Winamp Input format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.WV">
            <summary>
            WavPack Lossless format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.WV_H">
            <summary>
            WavPack Hybrid Lossless format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.WV_L">
            <summary>
            WavPack Lossy format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.WV_LH">
            <summary>
            WavPack Hybrid Lossy format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.OFR">
            <summary>
            Optimfrog format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.APE">
            <summary>
            APE format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.Mixer">
            <summary>
            BassMix mixer stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.Split">
            <summary>
            BassMix splitter stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.FLAC">
            <summary>
            FLAC format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.FLAC_OGG">
            <summary>
            FLAC OGG format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.MPC">
            <summary>
            MPC format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.AAC">
            <summary>
            AAC format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.MP4">
            <summary>
            MP4 format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.SPX">
            <summary>
            Speex format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.MIDI">
            <summary>
            MIDI sound format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.ALAC">
            <summary>
            Apple Lossless (ALAC) format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.TTA">
            <summary>
            TTA format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.AC3">
            <summary>
            AC3 format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.Video">
            <summary>
            Video format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.OPUS">
            <summary>
            Opus format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.DSD">
            <summary>
            Direct Stream Digital (DSD) format stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.ADX">
            <summary>
            ADX format stream.
            <para>
            ADX is a lossy proprietary audio storage and compression format developed
            by CRI Middleware specifically for use in video games, it is derived from ADPCM.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.AIX">
            <summary>
            AIX format stream.
            Only for ADX of all versions (with AIXP support).
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.Tempo">
            <summary>
            BassFx tempo stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.Reverse">
            <summary>
            BassFx reverse stream.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.MOD">
            <summary>
            MOD format music.
            This can also be used as a flag to test if the channel is any kind of HMusic.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.MTM">
            <summary>
            MTM format music.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.S3M">
            <summary>
            S3M format music.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.XM">
            <summary>
            XM format music.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.IT">
            <summary>
            IT format music.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.Wave">
            <summary>
            Wave format stream, LoWord = codec.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.WavePCM">
            <summary>
            Wave format stream, PCM 16-bit.
            </summary>
        </member>
        <member name="F:ManagedBass.ChannelType.WaveFloat">
            <summary>
            Wave format stream, Float 32-bit.
            </summary>
        </member>
        <member name="T:ManagedBass.DataFlags">
            <summary>
            Flags to be used with <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.Available">
            <summary>
            Query how much data is buffered
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFTIndividual">
            <summary>
            FFT flag: FFT for each channel, else all combined
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFTNoWindow">
            <summary>
            FFT flag: no Hanning window
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFTRemoveDC">
            <summary>
            FFT flag: pre-remove DC bias
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFTComplex">
            <summary>
            FFT flag: return complex data
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.Float">
            <summary>
            flag: return floating-point sample data
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFT256">
            <summary>
            256 sample FFT (returns 128 floating-point values)
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFT512">
            <summary>
            512 sample FFT (returns 256 floating-point values)
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFT1024">
            <summary>
            1024 sample FFT (returns 512 floating-point values)
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFT2048">
            <summary>
            2048 sample FFT (returns 1024 floating-point values)
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFT4096">
            <summary>
            4096 sample FFT (returns 2048 floating-point values)
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFT8192">
            <summary>
            8192 sample FFT (returns 4096 floating-point values)
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFT16384">
            <summary>
            16384 sample FFT (returns 8192 floating-point values)
            </summary>
        </member>
        <member name="F:ManagedBass.DataFlags.FFT32768">
            <summary>
            32768 FFT
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInfoFlags.None">
            <summary>
            The device is not enabled and not initialized.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInfoFlags.Enabled">
            <summary>
            The device is enabled.
            It will not be possible to initialize the device if this flag is not present.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInfoFlags.Default">
            <summary>
            The device is the system default.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInfoFlags.Initialized">
            <summary>
            The device is initialized, ie. <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/> or <see cref="M:ManagedBass.Bass.RecordInit(System.Int32)"/> has been called.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInfoFlags.TypeMask">
            <summary>
            Bitmask to identify the device Type.
            </summary>
        </member>
        <member name="T:ManagedBass.DeviceInitFlags">
            <summary>
            Initialization flags to be used with <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" />
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInitFlags.Default">
            <summary>
            0 = 16 bit, stereo, no 3D, no Latency calc, no Speaker Assignments
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInitFlags.Byte">
            <summary>
            Use 8 bit resolution, else 16 bit.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInitFlags.Mono">
            <summary>
            Use mono, else stereo.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInitFlags.Device3D">
            <summary>
            Enable 3D functionality.
            Note: If this is not specified when initilizing BASS,
            then the <see cref="F:ManagedBass.BassFlags.Bass3D"/> is ignored when loading/creating a sample/stream/music.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInitFlags.Latency">
            <summary>
            Calculate device latency (<see cref="T:ManagedBass.BassInfo"/> struct).
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInitFlags.CPSpeakers">
            <summary>
            Use the Windows control panel setting to detect the number of speakers.
            Only use this option if BASS doesn't detect the correct number of supported
            speakers automatically and you want to force BASS to use the number of speakers
            as configured in the windows control panel.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInitFlags.ForcedSpeakerAssignment">
            <summary>
            Force enabling of speaker assignment (always 8 speakers will be used regardless if the soundcard supports them).
            Only use this option if BASS doesn't detect the correct number of supported
            speakers automatically and you want to force BASS to use 8 speakers.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInitFlags.NoSpeakerAssignment">
            <summary>
            Ignore speaker arrangement
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceInitFlags.Frequency">
            <summary>
            Set the device's output rate to freq, otherwise leave it as it is.
            </summary>
        </member>
        <member name="T:ManagedBass.DeviceType">
            <summary>
            Device Type to be used with <see cref="T:ManagedBass.DeviceInfo" />.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.Network">
            <summary>
            An audio endpoint Device that the User accesses remotely through a network.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.Speakers">
            <summary>
            A set of speakers.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.Line">
            <summary>
            An audio endpoint Device that sends a line-level analog signal to
            a line-Input jack on an audio adapter or that receives a line-level analog signal
            from a line-output jack on the adapter.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.Headphones">
            <summary>
            A set of headphones.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.Microphone">
            <summary>
            A microphone.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.Headset">
            <summary>
            An earphone or a pair of earphones with an attached mouthpiece for two-way communication.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.Handset">
            <summary>
            The part of a telephone that is held in the hand and
            that contains a speaker and a microphone for two-way communication.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.Digital">
            <summary>
            An audio endpoint Device that connects to an audio adapter through a connector
            for a digital interface of unknown Type.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.SPDIF">
            <summary>
            An audio endpoint Device that connects to an audio adapter through
            a Sony/Philips Digital Interface (S/PDIF) connector.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.HDMI">
            <summary>
            An audio endpoint Device that connects to an audio adapter through
            a High-Definition Multimedia Interface (HDMI) connector.
            </summary>
        </member>
        <member name="F:ManagedBass.DeviceType.DisplayPort">
            <summary>
            An audio endpoint Device that connects to an audio adapter through a DisplayPort connector.
            </summary>
        </member>
        <member name="T:ManagedBass.DXPhase">
            <summary>
            DX8 effect phase.
            </summary>
        </member>
        <member name="F:ManagedBass.DXPhase.Negative180">
            <summary>
            Phase differential between left and right LFOs (-180)
            </summary>
        </member>
        <member name="F:ManagedBass.DXPhase.Negative90">
            <summary>
            Phase differential between left and right LFOs (-90)
            </summary>
        </member>
        <member name="F:ManagedBass.DXPhase.Zero">
            <summary>
            Phase differential between left and right LFOs (+/-0)
            </summary>
        </member>
        <member name="F:ManagedBass.DXPhase.Positive90">
            <summary>
            Phase differential between left and right LFOs (+90)
            </summary>
        </member>
        <member name="F:ManagedBass.DXPhase.Positive180">
            <summary>
            Phase differential between left and right LFOs (+180)
            </summary>
        </member>
        <member name="T:ManagedBass.DXWaveform">
            <summary>
            DirectX Effect Waveform.
            </summary>
        </member>
        <member name="F:ManagedBass.DXWaveform.Triangle">
            <summary>
            Triangle Wave.
            </summary>
        </member>
        <member name="F:ManagedBass.DXWaveform.Sine">
            <summary>
            Sine Wave.
            </summary>
        </member>
        <member name="T:ManagedBass.EffectType">
            <summary>
            FX effect types, use with <see cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.DXChorus">
            <summary>
            DX8 Chorus.
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.DXDistortion">
            <summary>
            DX8 Distortion.
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.DXEcho">
            <summary>
            DX8 Echo.
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.DXFlanger">
            <summary>
            DX8 Flanger.
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.DXParamEQ">
            <summary>
            DX8 Parametric equalizer.
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.DXReverb">
            <summary>
            DX8 Reverb.
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.Rotate">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Channel Volume Ping-Pong (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.Volume">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Volume control (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.PeakEQ">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Peaking Equalizer (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.Mix">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Channel Swap/Remap/Downmix (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.Damp">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Dynamic Amplification (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.AutoWah">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Auto WAH (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.Phaser">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Phaser (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.Chorus">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Chorus (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.Distortion">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Distortion (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.Compressor">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Dynamic Range Compressor (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.VolumeEnvelope">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Volume Envelope (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.BQF">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: BiQuad filters (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.Echo">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Echo/Reverb 4 (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.PitchShift">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Pitch Shift using FFT (multi channel).
            </summary>
        </member>
        <member name="F:ManagedBass.EffectType.Freeverb">
            <summary>
            <see cref="T:ManagedBass.Fx.BassFx"/>: Pitch Shift using FFT (multi channel).
            </summary>
        </member>
        <member name="T:ManagedBass.FileStreamPosition">
            <summary>
            Stream File Position modes to be used with <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" />
            </summary>
        </member>
        <member name="F:ManagedBass.FileStreamPosition.Current">
            <summary>
            Position that is to be decoded for playback next.
            This will be a bit ahead of the position actually being heard due to buffering.
            </summary>
        </member>
        <member name="F:ManagedBass.FileStreamPosition.Download">
            <summary>
            Download progress of an internet file stream or "buffered" User file stream.
            </summary>
        </member>
        <member name="F:ManagedBass.FileStreamPosition.End">
            <summary>
            End of the file, in other words the file Length.
            When streaming in blocks, the file Length is unknown, so the download Buffer Length is returned instead.
            </summary>
        </member>
        <member name="F:ManagedBass.FileStreamPosition.Start">
            <summary>
            Start of stream data in the file.
            </summary>
        </member>
        <member name="F:ManagedBass.FileStreamPosition.Connected">
            <summary>
            Internet file stream or "buffered" User file stream is still connected? 0 = no, 1 = yes.
            </summary>
        </member>
        <member name="F:ManagedBass.FileStreamPosition.Buffer">
            <summary>
            The amount of data in the Buffer of an internet file stream or "buffered" User file stream.
            Unless streaming in blocks, this is the same as <see cref="F:ManagedBass.FileStreamPosition.Download"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.FileStreamPosition.Socket">
            <summary>
            Returns the socket hanlde used for streaming.
            </summary>
        </member>
        <member name="F:ManagedBass.FileStreamPosition.AsyncBuffer">
            <summary>
            The amount of data in the asynchronous file reading Buffer.
            This requires that the <see cref="F:ManagedBass.BassFlags.AsyncFile"/> flag was used at the stream's creation.
            </summary>
        </member>
        <member name="F:ManagedBass.FileStreamPosition.WmaBuffer">
            <summary>
            WMA add-on: internet buffering progress (0-100%)
            </summary>
        </member>
        <member name="F:ManagedBass.FileStreamPosition.HlsSegment">
            <summary>
            Segment Sequence number.
            </summary>
        </member>
        <member name="T:ManagedBass.FXChannelFlags">
            <summary>
            DSP channels flags.
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.All">
            <summary>
            All channels at once (as by default).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.None">
            <summary>
            Disable an effect for all channels (resp. set the global volume of the Volume effect).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel1">
            <summary>
            left-front channel
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel2">
            <summary>
            right-front channel
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel3">
            <summary>
            Channel 3: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel4">
            <summary>
            Channel 4: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel5">
            <summary>
            Channel 5: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel6">
            <summary>
            Channel 6: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel7">
            <summary>
            Channel 7: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel8">
            <summary>
            Channel 8: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel9">
            <summary>
            Channel 9: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel10">
            <summary>
            Channel 10: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel11">
            <summary>
            Channel 11: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel12">
            <summary>
            Channel 12: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel13">
            <summary>
            Channel 13: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel14">
            <summary>
            Channel 14: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel15">
            <summary>
            Channel 15: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel16">
            <summary>
            Channel 16: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel17">
            <summary>
            Channel 17: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel18">
            <summary>
            Channel 18: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel19">
            <summary>
            Channel 19: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel20">
            <summary>
            Channel 20: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel21">
            <summary>
            Channel 21: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel22">
            <summary>
            Channel 22: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel23">
            <summary>
            Channel 23: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel24">
            <summary>
            Channel 24: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel25">
            <summary>
            Channel 25: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel26">
            <summary>
            Channel 26: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel27">
            <summary>
            Channel 27: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel28">
            <summary>
            Channel 28: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel29">
            <summary>
            Channel 29: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:ManagedBass.FXChannelFlags.Channel30">
            <summary>
            Channel 30: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="T:ManagedBass.InputFlags">
            <summary>
            <see cref="M:ManagedBass.Bass.RecordSetInput(System.Int32,ManagedBass.InputFlags,System.Single)" /> flags.
            </summary>
        </member>
        <member name="F:ManagedBass.InputFlags.None">
            <summary>
            Don't change any setting. 
            Use this flag, if you only want to set the volume.
            </summary>
        </member>
        <member name="F:ManagedBass.InputFlags.Off">
            <summary>
            Disable the Input.
            This flag can't be used when the device supports only one Input at a time.
            </summary>
        </member>
        <member name="F:ManagedBass.InputFlags.On">
            <summary>
            Enable the Input.
            If the device only allows one Input at a time, then any previously enabled Input will be disabled by this.
            </summary>
        </member>
        <member name="T:ManagedBass.InputTypeFlags">
            <summary>
            Used with <see cref="M:ManagedBass.Bass.RecordGetInput(System.Int32,System.Single@)"/> applying <see cref="F:ManagedBass.InputTypeFlags.InputTypeMask"/> on the return value;
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.InputTypeMask">
            <summary>
            The Type of Input is also indicated in the high 8-bits of <see cref="M:ManagedBass.Bass.RecordGetInput(System.Int32,System.Single@)"/> (use this to test the return value).
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.Error">
            <summary>
            The Type of Input is errorness.
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.Undefined">
            <summary>
            Anything that is not covered by the other types
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.Digital">
            <summary>
            Digital Input source, for example, a DAT or audio CD.
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.Line">
            <summary>
            Line-in. On some devices, "Line-in" may be combined with other analog sources into a single Analog Input.
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.Microphone">
            <summary>
            Microphone.
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.MIDISynthesizer">
            <summary>
            Internal MIDI synthesizer.
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.AnalogCD">
            <summary>
            Analog audio CD.
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.Phone">
            <summary>
            Telephone.
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.Speaker">
            <summary>
            PC speaker.
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.Wave">
            <summary>
            The device's WAVE/PCM output.
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.Auxiliary">
            <summary>
            Auxiliary. Like "Line-in", "Aux" may be combined with other analog sources into a single Analog Input on some devices.
            </summary>
        </member>
        <member name="F:ManagedBass.InputTypeFlags.Analog">
            <summary>
            Analog, typically a mix of all analog sources (what you hear).
            </summary>
        </member>
        <member name="T:ManagedBass.LevelRetrievalFlags">
            <summary>
            Level retrieval flags (to be used with <see cref="M:ManagedBass.Bass.ChannelGetLevel(System.Int32,System.Single[],System.Single,ManagedBass.LevelRetrievalFlags)" />).
            </summary>
        </member>
        <member name="F:ManagedBass.LevelRetrievalFlags.All">
            <summary>
            Retrieves mono levels
            </summary>
        </member>
        <member name="F:ManagedBass.LevelRetrievalFlags.Mono">
            <summary>
            Retrieves mono levels
            </summary>
        </member>
        <member name="F:ManagedBass.LevelRetrievalFlags.Stereo">
            <summary>
            Retrieves stereo levels
            </summary>
        </member>
        <member name="F:ManagedBass.LevelRetrievalFlags.RMS">
            <summary>
            Optional Flag: If set it returns RMS levels instead of peak leavels
            </summary>
        </member>
        <member name="T:ManagedBass.Mode3D">
            <summary>
            3D Channel Mode flags used with <see cref="T:ManagedBass.SampleInfo" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Mode3D.LeaveCurrent">
            <summary>
            To be used with <see cref="M:ManagedBass.Bass.ChannelSet3DAttributes(System.Int32,ManagedBass.Mode3D,System.Single,System.Single,System.Int32,System.Int32,System.Single)"/>
            in order to leave the current 3D processing mode unchanged.
            </summary>
        </member>
        <member name="F:ManagedBass.Mode3D.Normal">
            <summary>
            Normal 3D processing
            </summary>
        </member>
        <member name="F:ManagedBass.Mode3D.Relative">
            <summary>
            The channel's 3D position (position/velocity/orientation) are relative to the listener.
            When the listener's position/velocity/orientation is changed with <see cref="M:ManagedBass.Bass.Set3DPosition(ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)"/>,
            the channel's position relative to the listener does not change.
            </summary>
        </member>
        <member name="F:ManagedBass.Mode3D.Off">
            <summary>
            Turn off 3D processing on the channel, the sound will be played in the center.
            </summary>
        </member>
        <member name="T:ManagedBass.PlaybackState">
            <summary>
            <see cref="M:ManagedBass.Bass.ChannelIsActive(System.Int32)" /> return values.
            </summary>
        </member>
        <member name="F:ManagedBass.PlaybackState.Stopped">
            <summary>
            The channel is not active, or Handle is not a valid channel.
            </summary>
        </member>
        <member name="F:ManagedBass.PlaybackState.Playing">
            <summary>
            The channel is playing (or recording).
            </summary>
        </member>
        <member name="F:ManagedBass.PlaybackState.Stalled">
            <summary>
            Playback of the stream has been stalled due to there not being enough sample
            data to continue playing. The playback will automatically resume once there's
            sufficient data to do so.
            </summary>
        </member>
        <member name="F:ManagedBass.PlaybackState.Paused">
            <summary>
            The channel is paused.
            </summary>
        </member>
        <member name="T:ManagedBass.PositionFlags">
            <summary>
            Channel Position Mode flags to be used with e.g. <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" />, <see cref="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)" />,
            <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> or <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.Bytes">
            <summary>
            Byte position.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.MusicOrders">
            <summary>
            Order.Row position (HMUSIC only).
            LoWord = order, HiWord = row * scaler (<see cref="F:ManagedBass.ChannelAttribute.MusicPositionScaler" />).
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.MIDITick">
            <summary>
            Tick position (MIDI streams only).
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.OGG">
            <summary>
            OGG bitstream number.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.CDTrack">
            <summary>
            CD Add-On: the track number.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.MIDIDecaySeek">
            <summary>
            Midi Add-On: Let the old sound decay naturally (including reverb) when changing the position,
            including looping and such can also be used in <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)"/> calls to have it apply to particular position changes.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.MusicPositionReset">
            <summary>
            MOD Music Flag: Stop all notes when moving position.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.MusicPositionResetEx">
            <summary>
            MOD Music Flag: Stop all notes and reset bmp/etc when moving position.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.MixerNoRampIn">
            <summary>
            Mixer Flag: Don't ramp-in the start after seeking.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.Inexact">
            <summary>
            Flag: Allow inexact seeking.
            For speed, seeking may stop at the beginning of a block rather than partially processing the block to reach the requested position.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.Decode">
            <summary>
            Get the decoding (not playing) position.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.DecodeTo">
            <summary>
            Flag: decode to the position instead of seeking.
            </summary>
        </member>
        <member name="F:ManagedBass.PositionFlags.Scan">
            <summary>
            Scan the file to build a seek table up to the position, if it has not already been scanned.
            Scanning will continue from where it left off previously rather than restarting from the beginning of the file each time.
            This flag only applies to MP3/MP2/MP1 files and will be ignored with other file formats.
            </summary>
        </member>
        <member name="T:ManagedBass.RecordFormatFlags">
            <summary>
            Formats flags of <see cref="P:ManagedBass.RecordInfo.SupportedFormats"/> member to be used with <see cref="T:ManagedBass.RecordInfo" />
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.Unknown">
            <summary>
            Unknown Format
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF1M08">
            <summary>
            11.025 kHz, Mono, 8-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF1S08">
            <summary>
            11.025 kHz, Stereo, 8-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF1M16">
            <summary>
            11.025 kHz, Mono, 16-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF1S16">
            <summary>
            11.025 kHz, Stereo, 16-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF2M08">
            <summary>
            22.05 kHz, Mono, 8-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF2S08">
            <summary>
            22.05 kHz, Stereo, 8-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF2M16">
            <summary>
            22.05 kHz, Mono, 16-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF2S16">
            <summary>
            22.05 kHz, Stereo, 16-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF4M08">
            <summary>
            44.1 kHz, Mono, 8-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF4S08">
            <summary>
            44.1 kHz, Stereo, 8-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF4M16">
            <summary>
            44.1 kHz, Mono, 16-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF4S16">
            <summary>
            44.1 kHz, Stereo, 16-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF48M08">
            <summary>
            48 kHz, Mono, 8-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF48S08">
            <summary>
            48 kHz, Stereo, 8-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF48M16">
            <summary>
            48 kHz, Mono, 16-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF48S16">
            <summary>
            48 kHz, Stereo, 16-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF96M08">
            <summary>
            96 kHz, Mono, 8-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF96S08">
            <summary>
            96 kHz, Stereo, 8-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF96M16">
            <summary>
            96 kHz, Mono, 16-bit
            </summary>
        </member>
        <member name="F:ManagedBass.RecordFormatFlags.WF96S16">
            <summary>
            96 kHz, Stereo, 16-bit
            </summary>
        </member>
        <member name="T:ManagedBass.RecordInfoFlags">
            <summary>
            Flags to be used with <see cref="T:ManagedBass.RecordInfo" />
            </summary>
        </member>
        <member name="F:ManagedBass.RecordInfoFlags.None">
            <summary>
            None of the flags is set
            </summary>
        </member>
        <member name="F:ManagedBass.RecordInfoFlags.EmulatedDrivers">
            <summary>
            The device's drivers do NOT have DirectSound support, so it is being emulated.
            Updated drivers should be installed.
            </summary>
        </member>
        <member name="F:ManagedBass.RecordInfoFlags.Certified">
            <summary>
            The device driver has been certified by Microsoft.
            This flag is always set on WDM drivers.
            </summary>
        </member>
        <member name="T:ManagedBass.StreamProcedureType">
            <summary>
            <see cref="T:ManagedBass.StreamProcedure"/> flag used with <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedure,System.IntPtr)" /> resp. used with a User sample stream to be used with <see cref="T:ManagedBass.StreamProcedure" />.
            </summary>
        </member>
        <member name="F:ManagedBass.StreamProcedureType.End">
            <summary>
            Flag to signify that the end of the stream is reached.
            </summary>
        </member>
        <member name="F:ManagedBass.StreamProcedureType.Push">
            <summary>
            Create a "push" stream.
            Instead of BASS pulling data from a StreamProcedure function, data is pushed to
            BASS via <see cref="M:ManagedBass.Bass.StreamPutData(System.Int32,System.IntPtr,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.StreamProcedureType.Dummy">
            <summary>
            Create a "dummy" stream.
            A dummy stream doesn't have any sample data of its own, but a decoding dummy
            stream (with <see cref="F:ManagedBass.BassFlags.Decode"/> flag) can be used to apply DSP/FX processing
            to any sample data, by setting DSP/FX on the stream and feeding the data through <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>.
            The dummy stream should have the same sample format as the data being fed through it.
            </summary>
        </member>
        <member name="T:ManagedBass.StreamSystem">
            <summary>
            User file system flag to be used with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" />
            </summary>
        </member>
        <member name="F:ManagedBass.StreamSystem.NoBuffer">
            <summary>
            Unbuffered file system (like also used by <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)" />).
            <para>
            The unbuffered file system is what is used by <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)" />.
            In this system, BASS does not do any intermediate buffering - it simply requests data from the file as and when it needs it.
            This means that reading (<see cref="T:ManagedBass.FileReadProcedure" />) must be quick,
            otherwise the decoding will be delayed and playback Buffer underruns (old data repeated) are a possibility.
            It's not so important for seeking (<see cref="T:ManagedBass.FileSeekProcedure" />) to be fast, as that is generally not required during decoding, except when looping a file.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.StreamSystem.Buffer">
            <summary>
            Buffered file system (like also used by <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" />).
            <para>
            The buffered file system is what is used by <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" />.
            As the name suggests, data from the file is buffered so that it's readily available for decoding -
            BASS creates a thread dedicated to "downloading" the data. This is ideal for when the data is coming from a source that has high latency, like the internet.
            It's not possible to seek in buffered file streams, until the download has reached the requested position - it's not possible to seek at all if it's being streamed in blocks.
            </para>
            </summary>
        </member>
        <member name="F:ManagedBass.StreamSystem.BufferPush">
            <summary>
            Buffered, with the data pushed to BASS via <see cref="M:ManagedBass.Bass.StreamPutFileData(System.Int32,System.IntPtr,System.Int32)" />.
            <para>
            The push buffered file system is the same as <see cref="F:ManagedBass.StreamSystem.Buffer"/>, except that instead of the file data being pulled from the <see cref="T:ManagedBass.FileReadProcedure" /> function in a "download" thread,
            the data is pushed to BASS via <see cref="M:ManagedBass.Bass.StreamPutFileData(System.Int32,System.IntPtr,System.Int32)" />.
            A <see cref="T:ManagedBass.FileReadProcedure" /> function is still required, to get the initial data used in the creation of the stream.
            </para>
            </summary>
        </member>
        <member name="T:ManagedBass.SyncFlags">
            <summary>
            Sync types to be used with <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> (param flag) and <see cref="T:ManagedBass.SyncProcedure" /> (data flag).
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.Onetime">
            <summary>
            FLAG: sync only once, else continuously
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.Mixtime">
            <summary>
            FLAG: sync at mixtime, else at playtime
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.Position">
            <summary>
            Sync when a channel reaches a position.
            param : position in bytes
            data : not used
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MusicInstrument">
            <summary>
            Sync when an instrument (sample for the non-instrument based formats) is played in a MOD music (not including retrigs).
            param : LOWORD=instrument (1=first) HIWORD=note (0=c0...119=b9, -1=all)
            data : LOWORD=note HIWORD=volume (0-64)
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.End">
            <summary>
            Sync when a channel reaches the end.
            param : not used
            data : 1 = the sync is triggered by a backward jump in a MOD music, otherwise not used
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MusicFx">
            <summary>
            Sync when the "sync" effect (XM/MTM/MOD: E8x/Wxx, IT/S3M: S2x) is used.
            param : 0:data=Position, 1:data="x" value
            data : param=0: LOWORD=order HIWORD=row, param=1: "x" value
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MetadataReceived">
            <summary>
            Sync when metadata is received in a stream.
            param : not used
            data : not used - the updated metadata is available from <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)"/>
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.Slided">
            <summary>
            Sync when an attribute slide is completed.
            param : not used
            data : the Type of slide completed (one of the <see cref="T:ManagedBass.ChannelAttribute"/> values)
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.Stalled">
            <summary>
            Sync when playback has stalled.
            param : not used
            data : 0=stalled, 1=resumed
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.Downloaded">
            <summary>
            Sync when downloading of an internet (or "buffered" User file) stream has ended.
            param : not used
            data : not used
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.Free">
            <summary>
            Sync when a channel is freed.
            param : not used
            data : not used
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MusicPosition">
            <summary>
            Sync when a MOD music reaches an order:row position.
            param : LOWORD=order (0=first, -1=all) HIWORD=row (0=first, -1=all)
            data : LOWORD=order HIWORD=row
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.Seeking">
            <summary>
            Sync when seeking (inc. looping and restarting).
            So it could be used to reset DSP/etc.
            param : position in bytes
            data : 0=playback is unbroken, 1=if is it broken (eg. Buffer flushed).
            The latter would be the time to reset DSP/etc.
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.OggChange">
            <summary>
            Sync when a new logical bitstream begins in a chained OGG stream.
            Updated tags are available from <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)"/>.
            param : not used
            data : not used
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.Stop">
            <summary>
            Sync when the DirectSound Buffer fails during playback, eg. when the device is no longer available.
            param : not used
            data : not used
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.WinampBitRate">
            <summary>
            WINAMP add-on: Sync when bitrate is changed or retrieved from a winamp Input plug-in.
            param : not used
            data : the bitrate retrieved from the winamp Input plug-in -
            called when it is retrieved or changed (VBR MP3s, OGGs, etc).
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.CDError">
            <summary>
            CD add-on: Sync when playback is stopped due to an error.
            For example, the drive door being opened.
            param : not used
            data : the position that was being read from the CD track at the time.
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.CDSpeed">
            <summary>
            CD add-on: Sync when the read speed is automatically changed due to the BassCd.AutoSpeedReduction setting.
            param : not used
            data : the new read speed.
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MidiMarker">
            <summary>
            MIDI add-on: Sync when a marker is encountered.
            param : not used
            data : the marker index, which can be used in a <see cref="!:Midi.BassMidi.StreamGetMark(int,MidiMarkerType,int,out MidiMarker)"/> call.
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MidiCue">
            <summary>
            MIDI add-on: Sync when a cue is encountered.
            param : not used
            data : the marker index, which can be used in a <see cref="!:Midi.BassMidi.StreamGetMark(int,MidiMarkerType,int,out MidiMarker)"/> call.
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MidiLyric">
            <summary>
            MIDI add-on: Sync when a lyric event is encountered.
            param : not used
            data : the marker index, which can be used in a <see cref="!:Midi.BassMidi.StreamGetMark(int,MidiMarkerType,int,out MidiMarker)"/> call.
            If the text begins with a '/' (slash) character, a new line should be started.
            If it begins with a '\' (backslash) character, the display should be cleared.
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MidiText">
            <summary>
            MIDI add-on: Sync when a text event is encountered.
            param : not used
            data : the marker index, which can be used in a <see cref="!:Midi.BassMidi.StreamGetMark(int,MidiMarkerType,int,out MidiMarker)"/> call.
            Lyrics can sometimes be found in <see cref="F:ManagedBass.Midi.MidiMarkerType.Text"/> instead of <see cref="F:ManagedBass.Midi.MidiMarkerType.Lyric"/> markers.
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MidiEvent">
            <summary>
            MIDI add-on: Sync when a Type of event is processed, in either a MIDI file or <see cref="!:Midi.BassMidi.StreamEvent(int,int,MidiEventType,int)"/>.
            param : event Type (0 = all types).
            data : LOWORD = event parameter, HIWORD = channel (high 8 bits contain the event Type when syncing on all types).
            See <see cref="!:Midi.BassMidi.StreamEvent(int,int,MidiEventType,int)"/> for a list of event types and their parameters.
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MidiTick">
            <summary>
            MIDI add-on: Sync when reaching a tick position.
            param : tick position.
            data : not used
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MidiTimeSignature">
            <summary>
            MIDI add-on: Sync when a time signature event is processed.
            param : event Type.
            data : The time signature events are given (by <see cref="!:Midi.BassMidi.StreamGetMark(int,MidiMarkerType,int,out MidiMarker)"/>)
            in the form of "numerator/denominator metronome-pulse 32nd-notes-per-MIDI-quarter-note", eg. "4/4 24 8".
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MidiKeySignature">
            <summary>
            MIDI add-on: Sync when a key signature event is processed.
            param : event Type.
            data : The key signature events are given (by <see cref="!:Midi.BassMidi.StreamGetMark(int,MidiMarkerType,int,out MidiMarker)"/>) in the form of "a b",
            where a is the number of sharps (if positive) or flats (if negative),
            and b signifies major (if 0) or minor (if 1).
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.WmaChange">
            <summary>
            WMA add-on: Sync on a track change in a server-side playlist.
            Updated tags are available via <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)"/>.
            param : not used
            data : not used
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.WmaMeta">
            <summary>
            WMA add-on: Sync on a mid-stream tag change in a server-side playlist.
            Updated tags are available via <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)"/>.
            param : not used
            data : not used - the updated metadata is available from <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MixerEnvelope">
            <summary>
            MIX add-on: Sync when an envelope reaches the end.
            param : not used
            data : envelope Type
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.MixerEnvelopeNode">
            <summary>
            MIX add-on: Sync when an envelope node is reached.
            param : Optional limit the sync to a certain envelope Type (one of the BASSMIXEnvelope values).
            data : Will contain the envelope Type in the LOWORD and the current node number in the HIWORD.
            </summary>
        </member>
        <member name="F:ManagedBass.SyncFlags.HlsSegement">
            <summary>
            Sync when a new segment begins downloading.
            Mixtime only.
            param: not used.
            data: not used.
            </summary>
        </member>
        <member name="T:ManagedBass.TagType">
            <summary>
            Types of what's returned by <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.ID3">
            <summary>
            ID3v1 tags : A pointer to a 128 byte block is returned.
            See www.id3.org for details of the block's structure.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.ID3v2">
            <summary>
            ID3v2 tags : A pointer to a variable Length block is returned.
            See www.id3.org for details of the block's structure.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.OGG">
            <summary>
            OGG comments : Only available when streaming an OGG file.
            A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.HTTP">
            <summary>
            HTTP headers : Only available when streaming from a HTTP server.
            A pointer to a series of null-terminated ANSI strings is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.ICY">
            <summary>
            ICY headers : A pointer to a series of null-terminated ANSI strings is returned,
            the final string ending with a double null.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.META">
            <summary>
            ICY (Shoutcast) metadata : A single null-terminated ANSI string containing
            the current stream title and url (usually omitted).
            The format of the string is: StreamTitle='xxx';StreamUrl='xxx';
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.APE">
            <summary>
            APE (v1 or v2) tags : Only available when streaming an APE file.
            A pointer to a series of null-terminated UTF-8 strings is returned,
            the final string ending with a double null.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.MP4">
            <summary>
            iTunes/MP4 metadata : Only available when streaming a MP4 file.
            A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.WMA">
            <summary>
            WMA header tags: WMA tags : Only available when streaming a WMA file.
            A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.OggEncoder">
            <summary>
            OGG encoder : A single null-terminated UTF-8 string.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.Lyrics3v2">
            <summary>
            Lyric3v2 tag : A single ANSI string is returned, containing the Lyrics3v2 information.
            See www.id3.org/Lyrics3v2 for details of its format.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.WmaMeta">
            <summary>
            WMA mid-stream tag: a single UTF-8 string.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.WmaCodec">
            <summary>
            WMA codec: A description of the codec used by the file.
            2 null-terminated UTF-8 strings are returned, with the 1st string being the name of the codec,
            and the 2nd containing additional information like what VBR setting was used.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.FlacCue">
            <summary>
            FLAC cuesheet.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.MF">
            <summary>
            Media Foundation tags : A pointer to a series of null-terminated UTF-8 strings
            is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.WaveFormat">
            <summary>
            WAVE format : A pointer to a <see cref="F:ManagedBass.TagType.WaveFormat"/> structure is returned.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.RiffInfo">
            <summary>
            RIFF/WAVE tags : array of null-terminated ANSI strings.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.RiffBext">
            <summary>
            BWF/RF64 tags (Broadcast Audio Extension) : A pointer to a variable Length block is returned.
            See the EBU specification for details of the block's structure.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.RiffCart">
            <summary>
            RIFF/BWF Radio Traffic Extension tags : A pointer to a variable Length block is returned.
            See the EBU specifications for details of the block's structure.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.RiffDISP">
            <summary>
            RIFF DISP text chunk: a single ANSI string.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.ApeBinary">
            <summary>
            + index# : <see cref="!:Ape.ApeBinaryTag"/> structure.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.MusicName">
            <summary>
            MOD music name : a single ANSI string.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.MusicMessage">
            <summary>
            MOD message : a single ANSI string.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.MusicOrders">
            <summary>
            MOD music order list: BYTE array of pattern numbers played at that order position.
            Pattern number 254 is "+++" (skip order) and 255 is "---" (end song).
            You can use <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)"/> with <see cref="F:ManagedBass.PositionFlags.MusicOrders"/> to get the Length of the array.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.MusicAuth">
            <summary>
            MOD author : UTF-8 string
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.MusicInstrument">
            <summary>
            + instrument#, MOD instrument name : ANSI string
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.MusicSample">
            <summary>
            + sample#, MOD sample name : ANSI string
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.MidiTrack">
            <summary>
            + track#, track text : array of null-terminated ANSI strings
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.FlacPicture">
            <summary>
            + index# : FLACPicture structure.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.AdxLoop">
            <summary>
            ADX tags: A pointer to the ADX loop structure.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.DSDArtist">
            <summary>
            DSDIFF artist : ASCII string
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.DSDTitle">
            <summary>
            DSDIFF title : ASCII string
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.DSDComment">
            <summary>
            + index, DSDIFF comment : A pointer to the DSDIFF comment tag structure.
            </summary>
        </member>
        <member name="F:ManagedBass.TagType.HlsExtInf">
            <summary>
            Segment's EXTINF tag: UTF-8 string.
            </summary>
        </member>
        <member name="T:ManagedBass.VAMMode">
            <summary>
            Voice allocation management flags.
            These flags enable hardware resource stealing... if the hardware has no	available voices, a currently playing Buffer will be stopped to make room for the new Buffer.
            </summary>
            <remarks>
            NOTE: only samples loaded/created with the <see cref="F:ManagedBass.BassFlags.VAM"/> flag are considered for termination by the DX7 voice management.
            </remarks>
        </member>
        <member name="F:ManagedBass.VAMMode.Hardware">
            <summary>
            Play the sample in hardware (default).
            If no hardware voices are available then the "play" call will fail.
            </summary>
        </member>
        <member name="F:ManagedBass.VAMMode.Software">
            <summary>
            Play the sample in software (ie. non-accelerated).
            No other VAM flags may be used together with this flag.
            </summary>
        </member>
        <member name="F:ManagedBass.VAMMode.TerminateTime">
            <summary>
            If there are no free hardware voices,
            the Buffer to be terminated will be the one with the least time left to play.
            </summary>
        </member>
        <member name="F:ManagedBass.VAMMode.TerminateDistance">
            <summary>
            If there are no free hardware voices, the Buffer to be terminated will be
            one that was loaded/created with the <see cref="F:ManagedBass.BassFlags.MuteMax"/> flag and is beyond
            it's max distance. If there are no buffers that match this criteria, then
            the "play" call will fail.
            </summary>
        </member>
        <member name="F:ManagedBass.VAMMode.TerminatePriority">
            <summary>
            If there are no free hardware voices,
            the Buffer to be terminated will be the one with the lowest priority.
            </summary>
        </member>
        <member name="T:ManagedBass.WaveFormatTag">
            <summary>
            Wave Format Encoding
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Extensible">
            <summary>
            Wave Format Extensible, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Unknown">
            <summary>
            Unknown, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Pcm">
            <summary>
            PCM, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Adpcm">
            <summary>
            ADPCM, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.IeeeFloat">
            <summary>
            IEEE Float, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Vselp">
            <summary>
            VSELP, Compaq Computer Corp.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.IbmCvsd">
            <summary>
            IBM CVSD, IBM Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ALaw">
            <summary>
            ALAW, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MuLaw">
            <summary>
            MULAW, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Dts">
            <summary>
            DTS, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Drm">
            <summary>
            DRM, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.WmaVoice9">
            <summary>
            WMA VOICE 9
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.OkiAdpcm">
            <summary>
            OKI ADPCM, OKI
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DviAdpcm">
            <summary>
            DVI ADPCM, Intel Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ImaAdpcm">
            <summary>
            IMA ADPCM, Intel Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MediaspaceAdpcm">
            <summary>
            MEDIASPACE ADPCM, Videologic
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SierraAdpcm">
            <summary>
            SIERRA ADPCM, Sierra Semiconductor Corp
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.G723Adpcm">
            <summary>
            G723 ADPCM, Antex Electronics Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DigiStd">
            <summary>
            DIGISTD, DSP Solutions, Inc.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DigiFix">
            <summary>
            DIGIFIX, DSP Solutions, Inc.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DialogicOkiAdpcm">
            <summary>
            DIALOGIC OKI ADPCM, Dialogic Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MediaVisionAdpcm">
            <summary>
            MEDIAVISION ADPCM, Media Vision, Inc.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.CUCodec">
            <summary>
            CU CODEC, Hewlett-Packard Company
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.YamahaAdpcm">
            <summary>
            YAMAHA ADPCM, Yamaha Corporation of America
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SonarC">
            <summary>
            SONARC, Speech Compression
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DspGroupTrueSpeech">
            <summary>
            DSPGROUP TRUESPEECH, DSP Group, Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.EchoSpeechCorporation1">
            <summary>
            ECHOSC1, Echo Speech Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.AudioFileAf36">
            <summary>
            AUDIOFILE AF36, Virtual Music, Inc.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Aptx">
            <summary>
            APTX, Audio Processing Technology
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.AudioFileAf10">
            <summary>
            AUDIOFILE AF10, Virtual Music, Inc.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Prosody1612">
            <summary>
            PROSODY 1612, Aculab plc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Lrc">
            <summary>
            LRC, Merging Technologies S.A.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DolbyAc2">
            <summary>
            DOLBY AC2, Dolby Laboratories
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Gsm610">
            <summary>
            GSM610, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MsnAudio">
            <summary>
            MSNAUDIO, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.AntexAdpcme">
            <summary>
            ANTEX ADPCME, Antex Electronics Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ControlResVqlpc">
            <summary>
            CONTROL RES VQLPC, Control Resources Limited
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DigiReal">
            <summary>
            DIGIREAL, DSP Solutions, Inc.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DigiAdpcm">
            <summary>
            DIGIADPCM, DSP Solutions, Inc.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ControlResCr10">
            <summary>
            CONTROL RES CR10, Control Resources Limited
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.NMS_VBXADPCM">
            <summary>
            Natural MicroSystems
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.CS_IMAADPCM">
            <summary>
            Crystal Semiconductor IMA ADPCM
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ECHOSC3">
            <summary>
            Echo Speech Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ROCKWELL_ADPCM">
            <summary>
            Rockwell International
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ROCKWELL_DIGITALK">
            <summary>
            Rockwell International
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.XEBEC">
            <summary>
            Xebec Multimedia Solutions Limited
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.G721_ADPCM">
            <summary>
            Antex Electronics Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.G728_CELP">
            <summary>
            Antex Electronics Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MSG723">
            <summary>
            Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Mpeg">
            <summary>
            MPEG, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.RT24">
            <summary>
            InSoft, Inc.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.PAC">
            <summary>
            InSoft, Inc.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Mp3">
            <summary>
            MPEGLAYER3, ISO/MPEG Layer3 Format Tag
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.LUCENT_G723">
            <summary>
            Lucent Technologies
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.CIRRUS">
            <summary>
            Cirrus Logic
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ESPCM">
            <summary>
            ESS Technology 
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.CANOPUS_ATRAC">
            <summary>
            Canopus, co., Ltd.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.G726_ADPCM">
            <summary>
            APICOM
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.G722_ADPCM">
            <summary>
            APICOM
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DSAT_DISPLAY">
            <summary>
            Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_BYTE_ALIGNED">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_AC8">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_AC10">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_AC16">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_AC20">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_RT24">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_RT29">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_RT29HW">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_VR12">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_VR18">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_TQ40">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SOFTSOUND">
            <summary>
            Softsound, Ltd.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VOXWARE_TQ60">
            <summary>
            Voxware Inc
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MSRT24">
            <summary>
            Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.G729A">
            <summary>
            AT&amp;T Labs, Inc.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MVI_MVI2">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DF_G726">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DF_GSM610">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ISIAUDIO">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ONLIVE">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SBC24">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DOLBY_AC3_SPDIF">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MEDIASONIC_G723">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.PROSODY_8KBPS">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ZYXEL_ADPCM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.PHILIPS_LPCBB">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.PACKED">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MALDEN_PHONYTALK">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Gsm">
            <summary>
            WAVE_FORMAT_GSM
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.G729">
            <summary>
            WAVE_FORMAT_G729
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.G723">
            <summary>
            WAVE_FORMAT_G723
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Acelp">
            <summary>
            WAVE_FORMAT_ACELP
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.RawAac">
            <summary>
            WAVE_FORMAT_RAW_AAC1
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.RHETOREX_ADPCM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.IRAT">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VIVO_G723">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VIVO_SIREN">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DIGITAL_G723">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SANYO_LD_ADPCM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SIPROLAB_ACEPLNET">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SIPROLAB_ACELP4800">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SIPROLAB_ACELP8V3">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SIPROLAB_G729">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SIPROLAB_G729A">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SIPROLAB_KELVIN">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.G726ADPCM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.QUALCOMM_PUREVOICE">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.QUALCOMM_HALFRATE">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.TUBGSM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MSAUDIO1">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.WMA">
            <summary>
            Windows Media Audio, WAVE_FORMAT_WMAUDIO2, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.WMAProfessional">
            <summary>
            Windows Media Audio Professional WAVE_FORMAT_WMAUDIO3, Microsoft Corporation
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.WMALosseless">
            <summary>
            Windows Media Audio Lossless, WAVE_FORMAT_WMAUDIO_LOSSLESS
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.WMA_SPDIF">
            <summary>
            Windows Media Audio Professional over SPDIF WAVE_FORMAT_WMASPDIF (0x0164)
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.UNISYS_NAP_ADPCM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.UNISYS_NAP_ULAW">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.UNISYS_NAP_ALAW">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.UNISYS_NAP_16K">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.CREATIVE_ADPCM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.CREATIVE_FASTSPEECH8">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.CREATIVE_FASTSPEECH10">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.UHER_ADPCM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.QUARTERDECK">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ILINK_VC">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.RAW_SPORT">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.ESST_AC3">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.IPI_HSX">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.IPI_RPELP">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.CS2">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SONY_SCX">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.FM_TOWNS_SND">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.BTV_DIGITAL">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.QDESIGN_MUSIC">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VME_VMPCM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.TPC">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.OLIGSM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.OLIADPCM">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.OLICELP">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.OLISBC">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.OLIOPR">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.LH_CODEC">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.NORRIS">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.SOUNDSPACE_MUSICOMPRESS">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MPEG_ADTS_AAC">
            <summary>
            Advanced Audio Coding (AAC) audio in Audio Data Transport Stream (ADTS) format.
            The format block is a WAVEFORMATEX structure with wFormatTag equal to WAVE_FORMAT_MPEG_ADTS_AAC.
            </summary>
            <remarks>
            The WAVEFORMATEX structure specifies the core AAC-LC sample rate and number of channels, 
            prior to applying spectral band replication (SBR) or parametric stereo (PS) tools, if present.
            No additional data is required after the WAVEFORMATEX structure.
            </remarks>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MPEG_RAW_AAC">
            <summary></summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MPEG_LOAS">
            <summary>
            MPEG-4 audio transport stream with a synchronization layer (LOAS) and a multiplex layer (LATM).
            The format block is a WAVEFORMATEX structure with wFormatTag equal to WAVE_FORMAT_MPEG_LOAS.
            </summary>
            <remarks>
            The WAVEFORMATEX structure specifies the core AAC-LC sample rate and number of channels, 
            prior to applying spectral SBR or PS tools, if present.
            No additional data is required after the WAVEFORMATEX structure.
            </remarks>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.NOKIA_MPEG_ADTS_AAC">
            <summary>NOKIA_MPEG_ADTS_AAC</summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.NOKIA_MPEG_RAW_AAC">
            <summary>NOKIA_MPEG_RAW_AAC</summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VODAFONE_MPEG_ADTS_AAC">
            <summary>VODAFONE_MPEG_ADTS_AAC</summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.VODAFONE_MPEG_RAW_AAC">
            <summary>VODAFONE_MPEG_RAW_AAC</summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.MPEG_HEAAC">
            <summary>
            High-Efficiency Advanced Audio Coding (HE-AAC) stream.
            The format block is an HEAACWAVEFORMAT structure.
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.DVM">
            <summary>
            WAVE_FORMAT_DVM
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Vorbis1">
            <summary>
            WAVE_FORMAT_VORBIS1 "Og" Original stream compatible
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Vorbis2">
            <summary>
            WAVE_FORMAT_VORBIS2 "Pg" Have independent header
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Vorbis3">
            <summary>
            WAVE_FORMAT_VORBIS3 "Qg" Have no codebook header
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Vorbis1P">
            <summary>
            WAVE_FORMAT_VORBIS1P "og" Original stream compatible
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Vorbis2P">
            <summary>
            WAVE_FORMAT_VORBIS2P "pg" Have independent headere
            </summary>
        </member>
        <member name="F:ManagedBass.WaveFormatTag.Vorbis3P">
            <summary>
            WAVE_FORMAT_VORBIS3P "qg" Have no codebook header
            </summary>
        </member>
        <member name="T:ManagedBass.Bass">
             <summary>
             Wraps bass.dll.
            
             <para>
             Supports: .mp3, .ogg, .wav, .mp2, .mp1, .aiff, .m2a, .mpa, .m1a, .mpg, .mpeg, .aif, .mp3pro, .bwf, .mus,
             .mod, .mo3, .s3m, .xm, .it, .mtm, .umx, .mdz, .s3z, .itz, .xmz
             </para>
             </summary>
             <remarks>
             <para>
             BASS is a multiplatform audio library.
             It's purpose is to provide the most powerful and efficient (yet easy to use),
             sample, stream, MOD music, and recording functions.
             All in a tiny DLL, under 100KB in size.
             </para>
             </remarks>
        </member>
        <member name="M:ManagedBass.Bass.Apply3D">
            <summary>
            Applies changes made to the 3D system.
            </summary>
            <remarks>
            <para>
            This function must be called to apply any changes made with <see cref="M:ManagedBass.Bass.Set3DFactors(System.Single,System.Single,System.Single)"/>, <see cref="M:ManagedBass.Bass.Set3DPosition(ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)"/>, <see cref="M:ManagedBass.Bass.ChannelSet3DAttributes(System.Int32,ManagedBass.Mode3D,System.Single,System.Single,System.Int32,System.Int32,System.Single)"/> or <see cref="M:ManagedBass.Bass.ChannelSet3DPosition(System.Int32,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)"/>.
            This allows multiple changes to be synchronized, and also improves performance.
            </para>
            <para>
            This function applies 3D changes on all the initialized devices.
            There's no need to re-call it for each individual device when using multiple devices.
            </para>
            </remarks>
            <seealso cref="M:ManagedBass.Bass.ChannelSet3DAttributes(System.Int32,ManagedBass.Mode3D,System.Single,System.Single,System.Int32,System.Int32,System.Single)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelSet3DPosition(System.Int32,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)"/>
            <seealso cref="M:ManagedBass.Bass.Set3DFactors(System.Single,System.Single,System.Single)"/>
            <seealso cref="M:ManagedBass.Bass.Set3DPosition(ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)"/>
        </member>
        <member name="M:ManagedBass.Bass.Get3DFactors(System.Single@,System.Single@,System.Single@)">
            <summary>
            Retrieves the factors that affect the calculations of 3D sound.
            </summary>
            <param name="Distance">The distance factor.</param>
            <param name="RollOff">The rolloff factor.</param>
            <param name="Doppler">The doppler factor.</param>
            <returns>
            If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">The device was not initialized with 3D support.</exception>
            <remarks>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice" />) determines which device this function call applies to.</remarks>
            <seealso cref="M:ManagedBass.Bass.Set3DFactors(System.Single,System.Single,System.Single)"/>
        </member>
        <member name="M:ManagedBass.Bass.Set3DFactors(System.Single,System.Single,System.Single)">
            <summary>
            Sets the factors that affect the calculations of 3D sound.
            </summary>
            <param name="Distance">
            The distance factor... less than 0.0 = leave current... examples: 1.0 = use meters, 0.9144 = use yards, 0.3048 = use feet.
            By default BASS measures distances in meters, you can change this setting if you are using a different unit of measurement.
            </param>
            <param name="RollOff">The rolloff factor, how fast the sound quietens with distance... 0.0 (min) - 10.0 (max), less than 0.0 = leave current... examples: 0.0 = no rolloff, 1.0 = real world, 2.0 = 2x real.</param>
            <param name="Doppler">
            The doppler factor... 0.0 (min) - 10.0 (max), less than 0.0 = leave current... examples: 0.0 = no doppler, 1.0 = real world, 2.0 = 2x real.
            The doppler effect is the way a sound appears to change pitch when it is moving towards or away from you (say hello to Einstein!).
            The listener and sound velocity settings are used to calculate this effect, this <paramref name="Doppler"/> value can be used to lessen or exaggerate the effect.
            </param>
            <returns>
            If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">The device was not initialized with 3D support.</exception>
            <remarks>
            <para>As with all 3D functions, use <see cref="M:ManagedBass.Bass.Apply3D" /> to apply the changes.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <seealso cref="M:ManagedBass.Bass.Apply3D"/>
            <seealso cref="M:ManagedBass.Bass.Get3DFactors(System.Single@,System.Single@,System.Single@)"/>
        </member>
        <member name="M:ManagedBass.Bass.Get3DPosition(ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@)">
            <summary>
            Retrieves the position, velocity, and orientation of the listener.
            </summary>
            <param name="Position">The position of the listener</param>
            <param name="Velocity">The listener's velocity</param>
            <param name="Front">The direction that the listener's front is pointing</param>
            <param name="Top">The direction that the listener's top is pointing</param>
            <returns>
            If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">The device was not initialized with 3D support.</exception>
            <remarks>
            <para>The <paramref name="Front" /> and <paramref name="Top" /> parameters must both be retrieved in a single call, they can not be retrieved individually.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <seealso cref="M:ManagedBass.Bass.Set3DPosition(ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)"/>
            <seealso cref="T:ManagedBass.Vector3D"/>
        </member>
        <member name="M:ManagedBass.Bass.Set3DPosition(ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)">
            <summary>
            Sets the position, velocity, and orientation of the listener (i.e. the player).
            </summary>
            <param name="Position">The position of the listener... <see langword="null"/> = Leave Current.</param>
            <param name="Velocity">The listener's velocity... <see langword="null"/> = Leave Current.</param>
            <param name="Front">The direction that the listener's front is pointing... <see langword="null"/> = Leave Current.</param>
            <param name="Top">The direction that the listener's top is pointing... <see langword="null"/> = Leave Current.</param>
            <returns>
            If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">The device was not initialized with 3D support.</exception>
            <remarks>
            <para>The <paramref name="Front" /> and <paramref name="Top" /> parameters must both be set in a single call, they can not be set individually.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <seealso cref="M:ManagedBass.Bass.Apply3D"/>
            <seealso cref="M:ManagedBass.Bass.Get3DPosition(ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@)"/>
            <seealso cref="M:ManagedBass.Bass.Set3DFactors(System.Single,System.Single,System.Single)"/>
            <seealso cref="T:ManagedBass.Vector3D"/>
        </member>
        <member name="P:ManagedBass.Bass.Algorithm3D">
            <summary>
            The 3D algorithm for software mixed 3D channels.
            </summary>
            <remarks>
            <para>
            These algorithms only affect 3D channels that are being mixed in software.
            <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)"/> can be used to check whether a channel is being software mixed.
            </para>
            <para>
            Changing the algorithm only affects subsequently created or loaded samples, musics, or streams;
            it does not affect any that already exist.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            On Windows, DirectX 7 or above is required for this option to have effect.
            On other platforms, only the <see cref="F:ManagedBass.Algorithm3D.Default"/> and <see cref="F:ManagedBass.Algorithm3D.Off"/> options are available.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGet3DAttributes(System.Int32,ManagedBass.Mode3D@,System.Single@,System.Single@,System.Int32@,System.Int32@,System.Single@)">
            <summary>
            Retrieves the 3D attributes of a sample, stream, or MOD music channel with 3D functionality.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="Mode">The 3D processing mode (see <see cref="T:ManagedBass.Mode3D" />).</param>
            <param name="Min">The minimum distance.</param>
            <param name="Max">The maximum distance.</param>
            <param name="iAngle">The angle of the inside projection cone.</param>
            <param name="oAngle">The angle of the outside projection cone.</param>
            <param name="OutVol">The delta-volume outside the outer projection cone.</param>
            <returns>If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The <paramref name="iAngle"/> and <paramref name="oAngle"/> parameters must both be retrieved in a single call to this function (ie. you can't retrieve one without the other).</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">The channel does not have 3D functionality.</exception>
            <seealso cref="M:ManagedBass.Bass.ChannelGet3DPosition(System.Int32,ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelGetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single@)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelSet3DAttributes(System.Int32,ManagedBass.Mode3D,System.Single,System.Single,System.Int32,System.Int32,System.Single)"/>
            <seealso cref="F:ManagedBass.ChannelAttribute.EaxMix"/>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSet3DAttributes(System.Int32,ManagedBass.Mode3D,System.Single,System.Single,System.Int32,System.Int32,System.Single)">
            <summary>
            Sets the 3D attributes of a sample, stream, or MOD music channel with 3D functionality.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="Mode">The 3D processing mode</param>
            <param name="Min">The minimum distance. The channel's volume is at maximum when the listener is within this distance... less than 0.0 = leave current.</param>
            <param name="Max">The maximum distance. The channel's volume stops decreasing when the listener is beyond this distance... less than 0.0 = leave current.</param>
            <param name="iAngle">The angle of the inside projection cone in degrees... 0 (no cone) - 360 (sphere), -1 = leave current.</param>
            <param name="oAngle">The angle of the outside projection cone in degrees... 0 (no cone) - 360 (sphere), -1 = leave current.</param>
            <param name="OutVol">The delta-volume outside the outer projection cone... 0 (silent) - 100 (same as inside the cone), -1 = leave current.</param>
            <returns>If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">The channel does not have 3D functionality.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">One or more of the attribute values is invalid.</exception>
            <remarks>
            <para>The <paramref name="iAngle"/> and <paramref name="oAngle"/> parameters must both be set in a single call to this function (ie. you can't set one without the other).
            The <paramref name="iAngle"/> and <paramref name="oAngle"/> angles decide how wide the sound is projected around the orientation angle. Within the inside angle the volume level is the channel volume, as set with <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />.
            Outside the outer angle, the volume changes according to the <paramref name="OutVol"/> value. Between the inner and outer angles, the volume gradually changes between the inner and outer volume levels.
            If the inner and outer angles are 360 degrees, then the sound is transmitted equally in all directions.</para>
            <para>As with all 3D functions, use <see cref="M:ManagedBass.Bass.Apply3D" /> to apply the changes made.</para>
            </remarks>
            <seealso cref="M:ManagedBass.Bass.ChannelGet3DAttributes(System.Int32,ManagedBass.Mode3D@,System.Single@,System.Single@,System.Int32@,System.Int32@,System.Single@)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelSet3DPosition(System.Int32,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)"/>
            <seealso cref="F:ManagedBass.ChannelAttribute.EaxMix"/>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGet3DPosition(System.Int32,ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@)">
            <summary>
            Retrieves the 3D position of a sample, stream, or MOD music channel with 3D functionality.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="Position">Position of the sound.</param>
            <param name="Orientation">Orientation of the sound.</param>
            <param name="Velocity">Velocity of the sound.</param>
            <returns>If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">The channel does not have 3D functionality.</exception>
            <seealso cref="M:ManagedBass.Bass.ChannelGet3DAttributes(System.Int32,ManagedBass.Mode3D@,System.Single@,System.Single@,System.Int32@,System.Int32@,System.Single@)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelGetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single@)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelSet3DPosition(System.Int32,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)"/>
            <seealso cref="M:ManagedBass.Bass.Get3DFactors(System.Single@,System.Single@,System.Single@)"/>
            <seealso cref="M:ManagedBass.Bass.Get3DPosition(ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@)"/>
            <seealso cref="T:ManagedBass.Vector3D"/>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSet3DPosition(System.Int32,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)">
            <summary>
            Sets the 3D position of a sample, stream, or MOD music channel with 3D functionality.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="Position">Position of the sound.</param>
            <param name="Orientation">Orientation of the sound.</param>
            <param name="Velocity">Velocity of the sound. This is only used to calculate the doppler effect, and has no effect on the sound's position.</param>
            <returns>If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>As with all 3D functions, <see cref="M:ManagedBass.Bass.Apply3D" /> must be called to apply the changes made.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">The channel does not have 3D functionality.</exception>
            <seealso cref="M:ManagedBass.Bass.Apply3D"/>
            <seealso cref="M:ManagedBass.Bass.ChannelGet3DPosition(System.Int32,ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelSet3DAttributes(System.Int32,ManagedBass.Mode3D,System.Single,System.Single,System.Int32,System.Int32,System.Single)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)"/>
            <seealso cref="M:ManagedBass.Bass.Set3DFactors(System.Single,System.Single,System.Single)"/>
            <seealso cref="M:ManagedBass.Bass.Set3DPosition(ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)"/>
            <seealso cref="T:ManagedBass.Vector3D"/>
        </member>
        <member name="P:ManagedBass.Bass.SupportedFormats">
            <summary>
            Gets the Formats supported by Bass.
            </summary>
        </member>
        <member name="M:ManagedBass.Bass.Update(System.Int32)">
            <summary>
            Updates the HSTREAM and HMUSIC channel playback buffers.
            </summary>
            <param name="Length">The amount of data to render, in milliseconds.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Updating is already in progress.</exception>
            <remarks>
            When automatic updating is disabled, this function (or <see cref="M:ManagedBass.Bass.ChannelUpdate(System.Int32,System.Int32)" />) needs to be called to keep the playback buffers updated.
            The <paramref name="Length"/> parameter should include some safety margin, in case the next update cycle gets delayed.
            For example, if calling this function every 100ms, 200 would be a reasonable <paramref name="Length"/> parameter.
            </remarks>
            <seealso cref="M:ManagedBass.Bass.ChannelUpdate(System.Int32,System.Int32)"/>
            <seealso cref="P:ManagedBass.Bass.PlaybackBufferLength"/>
            <seealso cref="P:ManagedBass.Bass.UpdateThreads"/>
        </member>
        <member name="P:ManagedBass.Bass.CPUUsage">
            <summary>
            Retrieves the current CPU usage of BASS as a percentage of total CPU time.
            </summary>
            <remarks>
            <para>
            This function includes the time taken to render stream (HSTREAM) and MOD music (HMUSIC) channels during playback, and any DSP functions set on those channels.
            It slso includes any FX that are not using the "with FX flag" DX8 effect implementation.
            </para>
            <para>
            The rendering of some add-on stream formats may not be entirely included, if they use additional decoding threads.
            See the add-on documentation for details.
            </para>
            <para>
            This function does not strictly tell the CPU usage, but rather how timely the processing is.
            For example, if it takes 10ms to render 100ms of data, that would be 10%.
            If the reported usage gets to 100%, that means the channel data is being played faster than it can be rendered, and Buffer underruns are likely to occur.
            </para>
            <para>
            If automatic updating is disabled, then the value returned by this function is only updated after each call to <see cref="M:ManagedBass.Bass.Update(System.Int32)" />.
            <see cref="M:ManagedBass.Bass.ChannelUpdate(System.Int32,System.Int32)" /> usage is not included.
            The CPU usage of an individual channel is available via the <see cref="F:ManagedBass.ChannelAttribute.CPUUsage"/> attribute.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            On Windows, the CPU usage does not include sample channels (HCHANNEL), which are mixed by the output device/drivers (hardware mixing) or Windows (software mixing).
            On other platforms, the CPU usage does include sample playback as well as the generation of the final output mix.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.Version">
            <summary>
            Retrieves the version of BASS that is loaded
            </summary>
        </member>
        <member name="P:ManagedBass.Bass.LastError">
            <summary>
            Gets the Error that occured on the Last Bass function that was called.
            </summary>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)">
            <summary>
            Retrieves information on a channel.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="Info"><see cref="T:ManagedBass.ChannelInfo" /> instance where to store the channel information at.</param>
            <returns>
            If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetInfo(System.Int32)">
            <summary>
            Retrieves information on a channel.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <returns>An instance of the <see cref="T:ManagedBass.ChannelInfo" /> structure. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSetDSP(System.Int32,ManagedBass.DSPProcedure,System.IntPtr,System.Int32)">
            <summary>
            Sets up a User DSP function on a stream, MOD music, or recording channel.
            </summary>
            <param name="Handle">The channel Handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="Procedure">The callback function (see <see cref="T:ManagedBass.DSPProcedure" />).</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <param name="Priority">
            The priority of the new DSP, which determines it's position in the DSP chain.
            DSPs with higher priority are called before those with lower.
            </param>
            <returns>
            If succesful, then the new DSP's Handle is returned, else 0 is returned.
            Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <remarks>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            <para>
            Equally, you can also remove them at any time.
            Use <see cref="M:ManagedBass.Bass.ChannelRemoveDSP(System.Int32,System.Int32)"/> to remove a DSP function.
            </para>
            <para>
            Multiple DSP functions may be used per channel, in which case the order that the functions are called is determined by their priorities.
            Any DSPs that have the same priority are called in the order that they were added.
            </para>
            <para>
            DSP functions can be applied to MOD musics and streams, but not samples.
            If you want to apply a DSP function to a sample, then you should stream the sample.
            </para>
            <para>
            Unlike Bass.Net, a reference to <paramref name="Procedure"/> doesn't need to be held by you manually.
            ManagedBass automatically holds a reference and frees it when the Channel is freed or DSP is removed via <see cref="M:ManagedBass.Bass.ChannelRemoveDSP(System.Int32,System.Int32)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelRemoveDSP(System.Int32,System.Int32)">
            <summary>
            Removes a DSP function from a stream, MOD music, or recording channel.
            </summary>
            <param name="Handle">The channel Handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="DSP">Handle of the DSP function to remove from the channel (return value of a previous <see cref="M:ManagedBass.Bass.ChannelSetDSP(System.Int32,ManagedBass.DSPProcedure,System.IntPtr,System.Int32)" /> call).</param>
            <returns>If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle">At least one of <paramref name="Handle" /> and <paramref name="DSP" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)">
            <summary>
            Sets up a synchronizer on a MOD music, stream or recording channel.
            </summary>
            <param name="Handle">The channel Handle... a HMUSIC, HSTREAM or HRECORD.</param>
            <param name="Type">The Type of sync (see <see cref="T:ManagedBass.SyncFlags" />).</param>
            <param name="Parameter">The sync parameters, depends on the sync Type (see <see cref="T:ManagedBass.SyncFlags"/>).</param>
            <param name="Procedure">The callback function which should be invoked with the sync.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>
            If succesful, then the new synchronizer's Handle is returned, else 0 is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Type">An illegal <paramref name="Type" /> was specified.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">An illegal <paramref name="Parameter" /> was specified.</exception>
            <remarks>
            <para>
            Multiple synchronizers may be used per channel, and they can be set before and while playing.
            Equally, synchronizers can also be removed at any time, using <see cref="M:ManagedBass.Bass.ChannelRemoveSync(System.Int32,System.Int32)" />.
            If the <see cref="F:ManagedBass.SyncFlags.Onetime"/> flag is used, then the sync is automatically removed after its first occurrence.
            </para>
            <para>The <see cref="F:ManagedBass.SyncFlags.Mixtime"/> flag can be used with <see cref="F:ManagedBass.SyncFlags.End"/> or <see cref="F:ManagedBass.SyncFlags.Position"/>/<see cref="F:ManagedBass.SyncFlags.MusicPosition"/> syncs to implement custom looping, by using <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> in the callback.
            A <see cref="F:ManagedBass.SyncFlags.Mixtime"/> sync can also be used to add or remove DSP/FX at specific points, or change a HMUSIC channel's flags or attributes (see <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)" />).
            The <see cref="F:ManagedBass.SyncFlags.Mixtime"/> flag can also be useful with a <see cref="F:ManagedBass.SyncFlags.Seeking"/> sync, to reset DSP states after seeking.</para>
            <para>
            Several of the sync types are triggered in the process of rendering the channel's sample data;
            for example, <see cref="F:ManagedBass.SyncFlags.Position"/> and <see cref="F:ManagedBass.SyncFlags.End"/> syncs, when the rendering reaches the sync position or the end, respectively.
            Those sync types should be set before starting playback or pre-buffering (ie. before any rendering), to avoid missing any early sync events.
            </para>
            <para>With recording channels, <see cref="F:ManagedBass.SyncFlags.Position"/> syncs are triggered just before the <see cref="T:ManagedBass.RecordProcedure" /> receives the block of data containing the sync position.</para>
            <para>
            Unlike Bass.Net, a reference to <paramref name="Procedure"/> doesn't need to be held by you manually.
            ManagedBass automatically holds a reference and frees it when the Channel is freed or Sync is removed via <see cref="M:ManagedBass.Bass.ChannelRemoveSync(System.Int32,System.Int32)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelRemoveSync(System.Int32,System.Int32)">
            <summary>
            Removes a synchronizer from a MOD music or stream channel.
            </summary>
            <param name="Handle">The channel Handle... a HMUSIC, HSTREAM or HRECORD.</param>
            <param name="Sync">Handle of the synchronizer to remove (return value of a previous <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> call).</param>
            <returns>
            If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)">
            <summary>
            Starts (or resumes) playback of a sample, stream, MOD music, or recording.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL / HMUSIC / HSTREAM / HRECORD Handle.</param>
            <param name="Restart">
            Restart playback from the beginning? If Handle is a User stream, it's current Buffer contents are flushed.
            If it's a MOD music, it's BPM/etc are automatically reset to their initial values.
            </param>
            <returns>
            If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Start">The output is paused/stopped, use <see cref="M:ManagedBass.Bass.Start" /> to start it.</exception>
            <exception cref="F:ManagedBass.Errors.Decode">The channel is not playable, it's a "decoding channel".</exception>
            <exception cref="F:ManagedBass.Errors.BufferLost">Should not happen... check that a valid window Handle was used with <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/>.</exception>
            <exception cref="F:ManagedBass.Errors.NoHW">
            No hardware voices are available (HCHANNEL only).
            This only occurs if the sample was loaded/created with the <see cref="F:ManagedBass.BassFlags.VAM"/> flag,
            and <see cref="F:ManagedBass.VAMMode.Hardware"/> is set in the sample's VAM mode,
            and there are no hardware voices available to play it.
            </exception>
            <remarks>
            When streaming in blocks (<see cref="F:ManagedBass.BassFlags.StreamDownloadBlocks"/>), the restart parameter is ignored as it's not possible to go back to the start.
            The <paramref name="Restart" /> parameter is also of no consequence with recording channels.
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelPause(System.Int32)">
            <summary>
            Pauses a sample, stream, MOD music, or recording.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL / HMUSIC / HSTREAM / HRECORD Handle.</param>
            <returns>
            If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.NotPlaying">The channel is not playing (or <paramref name="Handle" /> is not a valid channel).</exception>
            <exception cref="F:ManagedBass.Errors.Decode">The channel is not playable, it's a "decoding channel".</exception>
            <exception cref="F:ManagedBass.Errors.Already">The channel is already paused.</exception>
            <remarks>
            Use <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" /> to resume a paused channel.
            <see cref="M:ManagedBass.Bass.ChannelStop(System.Int32)" /> can be used to stop a paused channel.
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelStop(System.Int32)">
            <summary>
            Stops a sample, stream, MOD music, or recording.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM or HRECORD Handle.</param>
            <returns>
            If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <remarks>
            <para>
            Stopping a User stream (created with <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedure,System.IntPtr)" />) will clear its Buffer contents,
            and stopping a sample channel (HCHANNEL) will result in it being freed.
            Use <see cref="M:ManagedBass.Bass.ChannelPause(System.Int32)" /> instead if you wish to stop a User stream and then resume it from the same point.
            </para>
            <para>
            When used with a "decoding channel" (<see cref="F:ManagedBass.BassFlags.Decode"/> was used at creation),
            this function will end the channel at its current position, so that it's not possible to decode any more data from it.
            Any <see cref="F:ManagedBass.SyncFlags.End"/> syncs that have been set on the channel will not be triggered by this, they are only triggered when reaching the natural end.
            <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> can be used to reset the channel and start decoding again.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelLock(System.Int32,System.Boolean)">
            <summary>
            Locks a stream, MOD music or recording channel to the current thread.
            </summary>
            <param name="Handle">The channel Handle... a HMUSIC, HSTREAM or HRECORD Handle.</param>
            <param name="Lock">If <see langword="false" />, unlock the channel, else lock it.</param>
            <returns>
            If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <remarks>
            Locking a channel prevents other threads from performing most functions on it, including Buffer updates.
            Other threads wanting to access a locked channel will block until it is unlocked, so a channel should only be locked very briefly.
            A channel must be unlocked in the same thread that it was locked.
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelIsActive(System.Int32)">
            <summary>
            Checks if a sample, stream, or MOD music is active (playing) or stalled. Can also check if a recording is in progress.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <returns><see cref="T:ManagedBass.PlaybackState" /> indicating whether the state of the channel.
            </returns>
            <remarks>
            <para>
            When using this function with a decoding channel, <see cref="F:ManagedBass.PlaybackState.Playing"/> will be returned while there is still data to decode.
            Once the end has been reached, <see cref="F:ManagedBass.PlaybackState.Stopped"/> will be returned.
            <see cref="F:ManagedBass.PlaybackState.Stalled"/> is never returned for decoding channels;
            you can tell a decoding channel is stalled if <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> returns less data than requested,
            and this function still returns <see cref="F:ManagedBass.PlaybackState.Playing"/>.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSetLink(System.Int32,System.Int32)">
            <summary>
            Links two MOD music or stream channels together.
            </summary>
            <param name="Handle">The channel Handle... a HMUSIC or HSTREAM.</param>
            <param name="Channel">The Handle of the channel to have linked with it... a HMUSIC or HSTREAM.</param>
            <returns>
            If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle">At least one of <paramref name="Handle" /> and <paramref name="Channel" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Decode">At least one of <paramref name="Handle" /> and <paramref name="Channel" /> is a "decoding channel", so can't be linked.</exception>
            <exception cref="F:ManagedBass.Errors.Already"><paramref name="Channel" /> is already linked to <paramref name="Handle" />.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
            <remarks>
            <para>
            Linked channels are started/stopped/paused/resumed together.
            Links are one-way, for example, channel <paramref name="Channel" /> will be started by channel <paramref name="Handle" />,
            but not vice versa unless another link has been set in that direction.
            </para>
            <para>
            If a linked channel has reached the end, it will not be restarted when a channel it is linked to is started.
            If you want a linked channel to be restarted, you need to have resetted it's position using <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> beforehand.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            Except for on Windows, linked channels on the same device are guaranteed to start playing simultaneously.
            On Windows, it is possible for there to be a slight gap between them, but it will generally be shorter (and never longer) than starting them individually.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelRemoveLink(System.Int32,System.Int32)">
            <summary>
            Removes a links between two MOD music or stream channels.
            </summary>
            <param name="Handle">The channel Handle... a HMUSIC or HSTREAM.</param>
            <param name="Channel">The Handle of the channel to have unlinked with it... a HMUSIC or HSTREAM.</param>
            <returns>
            If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Already">Either <paramref name="Channel" /> is not a valid channel, or it is already not linked to <paramref name="Handle" />.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)">
            <summary>
            Modifies and retrieves a channel's flags.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="Flags">
            A combination of flags that can be toggled (see <see cref="T:ManagedBass.BassFlags" />).
            Speaker assignment flags can also be toggled (HSTREAM/HMUSIC).
            </param>
            <param name="Mask">
            The flags (as above) to modify. Flags that are not included in this are left as they are, so it can be set to 0 in order to just retrieve the current flags.
            To modify the speaker flags, any of the Speaker flags can be used in the mask (no need to include all of them).
            </param>
            <returns>
            If successful, the channel's updated flags are returned, else -1 is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <remarks>
            <para>
            Some flags may not be adjustable in some circumstances, so the return value should be checked to confirm any changes.
            The flags listed above are just the flags that can be modified, and there may be additional flags present in the return value.
            See the <see cref="T:ManagedBass.ChannelInfo" /> documentation for a full list of flags.
            </para>
            <para>
            Streams that are created by add-ons may have additional flags available.
            There is a limited number of possible flag values though, so some add-ons may use the same flag value for different things.
            This means that when using add-on specific flags with a stream created via the plugin system,
            it is a good idea to first confirm that the add-on is handling the stream, by checking its ctype via <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" />.
            </para>
            <para>
            During playback, the effects of flag changes are not heard instantaneously, due to buffering.
            To reduce the delay, use the <see cref="P:ManagedBass.Bass.PlaybackBufferLength" /> config option to reduce the Buffer Length.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelHasFlag(System.Int32,ManagedBass.BassFlags)">
            <summary>
            Checks if a flag is present on a channel.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="Flag">see <see cref="T:ManagedBass.BassFlags" /></param>
        </member>
        <member name="M:ManagedBass.Bass.ChannelAddFlag(System.Int32,ManagedBass.BassFlags)">
            <summary>
            Adds a flag to a channel.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="Flag">see <see cref="T:ManagedBass.BassFlags" /></param>
        </member>
        <member name="M:ManagedBass.Bass.ChannelRemoveFlag(System.Int32,ManagedBass.BassFlags)">
            <summary>
            Removes a flag from a channel.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="Flag">see <see cref="T:ManagedBass.BassFlags" /></param>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single@)">
            <summary>
            Retrieves the value of an attribute of a sample, stream or MOD music.
            Can also get the sample rate of a recording channel.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM or HRECORD.</param>
            <param name="Attribute">The attribute to set the value of (one of <see cref="T:ManagedBass.ChannelAttribute" />)</param>
            <param name="Value">Reference to a float to receive the attribute value.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Attribute" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetAttribute(System.Int32,ManagedBass.ChannelAttribute)">
            <summary>
            Retrieves the value of an attribute of a sample, stream or MOD music.
            Can also get the sample rate of a recording channel.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM or HRECORD.</param>
            <param name="Attribute">The attribute to set the value of (one of <see cref="T:ManagedBass.ChannelAttribute" />)</param>
            <returns>If successful, the attribute value is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Attribute" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.IntPtr,System.Int32)">
            <summary>
            Retrieves the value of a channel's attribute.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM  or HRECORD.</param>
            <param name="Attribute">The attribute to get the value of (e.g. <see cref="F:ManagedBass.ChannelAttribute.ScannedInfo"/>)</param>
            <param name="Value">Pointer to a buffer to receive the attribute data.</param>
            <param name="Size">The size of the attribute data... 0 = get the size of the attribute without getting the data.</param>
            <returns>If successful, the size of the attribute data is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>This function also supports the floating-point attributes supported by <see cref="M:ManagedBass.Bass.ChannelGetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single@)" />.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The <paramref name="Attribute" /> is not available.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Attribute" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Value" /> content or <paramref name="Size" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)">
            <summary>
            Sets the value of an attribute of a sample, stream or MOD music.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM  or HRECORD.</param>
            <param name="Attribute">The attribute to set the value of.</param>
            <param name="Value">The new attribute value. See the attribute's documentation for details on the possible values.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The actual attribute value may not be exactly the same as requested, due to precision differences.
            For example, an attribute might only allow whole number values.
            <see cref="M:ManagedBass.Bass.ChannelGetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single@)" /> can be used to confirm what the value is.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Attribute" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Value" /> is not valid. See the attribute's documentation for the valid range of values.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Double)">
            <summary>
            Sets the value of an attribute of a sample, stream or MOD music.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM  or HRECORD.</param>
            <param name="Attribute">The attribute to set the value of.</param>
            <param name="Value">The new attribute value. See the attribute's documentation for details on the possible values.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The actual attribute value may not be exactly the same as requested, due to precision differences.
            For example, an attribute might only allow whole number values.
            <see cref="M:ManagedBass.Bass.ChannelGetAttribute(System.Int32,ManagedBass.ChannelAttribute)" /> can be used to confirm what the value is.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Attribute" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Value" /> is not valid. See the attribute's documentation for the valid range of values.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.IntPtr,System.Int32)">
            <summary>
            Sets the value of a channel's attribute.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM  or HRECORD.</param>
            <param name="Attribute">The attribute to set the value of. (e.g. <see cref="F:ManagedBass.ChannelAttribute.ScannedInfo"/>)</param>
            <param name="Value">The pointer to the new attribute data.</param>
            <param name="Size">The size of the attribute data.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Attribute" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Value" /> is not valid. See the attribute's documentation for the valid range of values.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)">
            <summary>
            Retrieves the requested tags/headers from a channel, if they are available.
            </summary>
            <param name="Handle">The channel handle...a HMUSIC or HSTREAM.</param>
            <param name="Tags">The tags/headers wanted...</param>
            <returns>If succesful, a pointer to the data of the tags/headers is returned, else <see cref="F:System.IntPtr.Zero" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Some tags (eg. <see cref="F:ManagedBass.TagType.ID3"/>) are located at the end of the file, so when streaming a file from the internet, the tags will not be available until the download is complete.
            A <see cref="F:ManagedBass.SyncFlags.Downloaded"/> sync can be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be informed of when the download is complete.
            A <see cref="F:ManagedBass.SyncFlags.MetadataReceived"/> sync can be used to be informed of new Shoutcast metadata, and a <see cref="F:ManagedBass.SyncFlags.OggChange"/> sync for when a new logical bitstream begins in a chained OGG stream, which generally brings new OGG tags.
            <para>
            In a chained OGG file containing multiple bitstreams, each bitstream will have its own tags.
            To get the tags from a particular one, <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> can be first used to seek to it.
            </para>
            <para>When a Media Foundation codec is in use, the <see cref="F:ManagedBass.TagType.WaveFormat"/> tag can be used to find out what the source format is.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The requested tags are not available.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)">
            <summary>
            Retrieves the playback Length of a channel.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM. HSAMPLE handles may also be used.</param>
            <param name="Mode">How to retrieve the Length (one of the <see cref="T:ManagedBass.PositionFlags" /> flags).</param>
            <returns>
            If succesful, then the channel's Length is returned, else -1 is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The Length is not available.</exception>
            <remarks>
            <para>
            The exact Length of a stream will be returned once the whole file has been streamed, but until then it is not always possible to 100% accurately estimate the Length.
            The Length is always exact for MP3/MP2/MP1 files when the <see cref="F:ManagedBass.BassFlags.Prescan"/> flag is used in the <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)" /> call, otherwise it is an (usually accurate) estimation based on the file size.
            The Length returned for OGG files will usually be exact (assuming the file is not corrupt), but when streaming from the internet (or "buffered" User file), it can be a very rough estimation until the whole file has been downloaded.
            It will also be an estimate for chained OGG files that are not pre-scanned.
            </para>
            <para>Unless an OGG file contains a single bitstream, the number of bitstreams it contains will only be available if it was pre-scanned at the stream's creation.</para>
            <para>Retrieving the Length of a MOD music requires that the <see cref="F:ManagedBass.BassFlags.Prescan"/> flag was used in the <see cref="M:ManagedBass.Bass.MusicLoad(System.String,System.Int64,System.Int32,ManagedBass.BassFlags,System.Int32)" /> call.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelBytes2Seconds(System.Int32,System.Int64)">
            <summary>
            Translates a byte position into time (seconds), based on a channel's format.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD. HSAMPLE handles may also be used.</param>
            <param name="Position">The position in Bytes to translate.</param>
            <returns>If successful, then the translated Length in seconds is returned, else a negative value is returned. Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <remarks>The translation is based on the channel's initial sample rate, when it was created.</remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSeconds2Bytes(System.Int32,System.Double)">
            <summary>
            Translates a time (seconds) position into bytes, based on a channel's format.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD. HSAMPLE handles may also be used.</param>
            <param name="Position">The position to translate (in seconds, e.g. 0.03 = 30ms).</param>
            <returns>
            If successful, then the translated Length in Bytes is returned, else -1 is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <remarks>
            <para>The translation is based on the channel's initial sample rate, when it was created.</para>
            <para>The return value is rounded down to the position of the nearest sample.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)">
            <summary>
            Retrieves the playback position of a sample, stream, or MOD music. Can also be used with a recording channel.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="Mode">How to retrieve the position</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            If successful, the position is returned.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The requested position is not available.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
            <remarks>With MOD music you might use the <see cref="M:ManagedBass.BitHelper.LoWord(System.Int32)" /> and <see cref="M:ManagedBass.BitHelper.HiWord(System.Int32)" /> methods to retrieve the order and the row values respectively.</remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)">
            <summary>
            Sets the playback position of a sample, MOD music, or stream.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HSTREAM or HMUSIC.</param>
            <param name="Position">The position, in units determined by the <paramref name="Mode" />.</param>
            <param name="Mode">How to set the position.</param>
            <returns>
            If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.NotFile">The stream is not a file stream.</exception>
            <exception cref="F:ManagedBass.Errors.Position">The requested position is invalid, eg. beyond the end.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The download has not yet reached the requested position.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
            <remarks>
            <para>
            Setting the position of a MOD music in bytes (other than 0) requires that the <see cref="F:ManagedBass.BassFlags.Prescan"/> flag was used in the <see cref="M:ManagedBass.Bass.MusicLoad(System.String,System.Int64,System.Int32,ManagedBass.BassFlags,System.Int32)" /> call.
            When setting the position in orders/rows, the channel's byte position (as reported by <see cref="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)" />) is reset to 0.
            This is because it's not possible to get the byte position of an order/row position - it's possible that a position may never be played in the normal cause of events, or it may be played multiple times.
            </para>
            <para>
            When changing the position of a MOD music, and the <see cref="F:ManagedBass.BassFlags.MusicPositionReset"/> flag is active on the channel, all notes that were playing before the position changed will be stopped.
            Otherwise, the notes will continue playing until they are stopped in the MOD music.
            When setting the position in bytes, the BPM, "speed" and "global volume" are updated to what they would normally be at the new position.
            Otherwise they are left as they were prior to the postion change, unless the seek position is 0 (the start), in which case they are also reset to the starting values (when using the <see cref="F:ManagedBass.BassFlags.MusicPositionReset"/> flag).
            When the <see cref="F:ManagedBass.BassFlags.MusicPositionResetEx"/> flag is active, the BPM, speed and global volume are reset with every seek.
            </para>
            <para>
            For MP3/MP2/MP1 streams, unless the file is scanned via the <see cref="F:ManagedBass.PositionFlags.Scan"/> or the <see cref="F:ManagedBass.BassFlags.Prescan"/> flag at stream creation, seeking will be approximate but generally still quite accurate.
            Besides scanning, exact seeking can also be achieved with the <see cref="F:ManagedBass.PositionFlags.DecodeTo"/> flag.
            </para>
            <para>Seeking in internet file (and "buffered" User file) streams is possible once the download has reached the requested position, so long as the file is not being streamed in blocks <see cref="F:ManagedBass.BassFlags.StreamDownloadBlocks"/>.</para>
            <para>User streams (created with <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedure,System.IntPtr)" />) are not seekable, but it is possible to reset a User stream (including its Buffer contents) by setting its position to byte 0.</para>
            <para>The <see cref="F:ManagedBass.PositionFlags.DecodeTo"/> flag can be used to seek forwards in streams that are not normally seekable, like custom streams or internet streams that are using the <see cref="F:ManagedBass.BassFlags.StreamDownloadBlocks"/> flag, but it will only go as far as what is currently available; it will not wait for more data to be downloaded, for example. <see cref="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)" /> can be used to confirm what the new position actually is.</para>
            <para>In some cases, particularly when the <see cref="F:ManagedBass.PositionFlags.Inexact"/> flag is used, the new position may not be what was requested. <see cref="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)" /> can be used to confirm what the new position actually is.</para>
            <para>The <see cref="F:ManagedBass.PositionFlags.Scan"/> flag works the same way as the <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)" /> <see cref="F:ManagedBass.BassFlags.Prescan"/> flag, and can be used to delay the scanning until after the stream has been created. When a position beyond the end is requested, the call will fail (<see cref="F:ManagedBass.Errors.Position"/> error code) but the seek table and exact Length will have been scanned.
            When a file has been scanned, all seeking (even without the <see cref="F:ManagedBass.PositionFlags.Scan"/> flag) within the scanned part of it will use the scanned infomation.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelIsSliding(System.Int32,ManagedBass.ChannelAttribute)">
            <summary>
            Checks if an attribute (or any attribute) of a sample, stream, or MOD music is sliding.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HMUSIC, HSTREAM or HRECORD.</param>
            <param name="Attribute">The attribute to check for sliding (0 for any attribute).</param>
            <returns>If the attribute (or any) is sliding, then <see langword="true" /> is returned, else <see langword="false" /> is returned.</returns>
        </member>
        <member name="M:ManagedBass.Bass.IsSlidableAttribute(ManagedBass.ChannelAttribute)">
            <summary>
            Checks whether a <see cref="T:ManagedBass.ChannelAttribute"/> is slidable via <see cref="M:ManagedBass.Bass.ChannelSlideAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single,System.Int32)"/>.
            </summary>
            <param name="Attribute">The attribute to check</param>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSlideAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single,System.Int32)">
            <summary>
            Slides a channel's attribute from its current value to a new value.
            </summary>
            <param name="Handle">The channel Handle... a HCHANNEL, HSTREAM or HMUSIC, or HRECORD.</param>
            <param name="Attribute">The attribute to slide the value of.</param>
            <param name="Value">The new attribute value. See the attribute's documentation for details on the possible values.</param>
            <param name="Time">The Length of time (in milliseconds) that it should take for the attribute to reach the <paramref name="Value" />.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Attribute" /> is not valid.</exception>
            <remarks>
            <para>This function is similar to <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />, except that the attribute is ramped to the value over the specified period of time.
            Another difference is that the value is not pre-checked. If it is invalid, the slide will simply end early.</para>
            <para>If an attribute is already sliding, then the old slide is stopped and replaced by the new one.</para>
            <para><see cref="M:ManagedBass.Bass.ChannelIsSliding(System.Int32,ManagedBass.ChannelAttribute)" /> can be used to check if an attribute is currently sliding. A BASS_SYNC_SLIDE sync can also be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered at the end of a slide.
            The sync will not be triggered in the case of an existing slide being replaced by a new one.</para>
            <para>Attribute slides are unaffected by whether the channel is playing, paused or stopped. They carry on regardless.</para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetLevel(System.Int32)">
            <summary>
            Retrieves the level (peak amplitude) of a sample, stream, MOD music or recording channel.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            <para>
            If successful, the level of the left channel is returned in the low word (low 16-bits), and the level of the right channel is returned in the high word (high 16-bits).
            If the channel is mono, then the low word is duplicated in the high word.
            The level ranges linearly from 0 (silent) to 32768 (max).
            0 will be returned when a channel is stalled.
            </para>
            </returns>
            <remarks>
            <para>
            This function measures the level of the channel's sample data, not the level of the channel in the final output mix,
            so the channel's volume and panning/balance (as set with <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />, <see cref="F:ManagedBass.ChannelAttribute.Volume"/> or <see cref="F:ManagedBass.ChannelAttribute.Pan"/>) does not affect it.
            The effect of any DSP/FX set on the channel is present in the measurement, except for DX8 effects when using the "With FX flag" DX8 effect implementation.
            </para>
            <para>
            For channels that are more than stereo, the left level will include all left channels (eg. front-left, rear-left, center), and the right will include all right (front-right, rear-right, LFE).
            If there are an odd number of channels then the left and right levels will include all channels.
            If the level of each individual channel is required, that is available from the other overload(s).
            </para>
            <para>
            20ms of data is inspected to calculate the level.
            When used with a decoding channel, that means 20ms of data needs to be decoded from the channel in order to calculate the level, and that data is then gone, eg. it is not available to a subsequent <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> call.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.NotPlaying">The channel is not playing.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The decoding channel has reached the end.</exception>
            <exception cref="F:ManagedBass.Errors.BufferLost">Should not happen... check that a valid window handle was used with <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" />.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetLevelLeft(System.Int32)">
            <summary>
            Gets the Level of the Left Channel.
            </summary>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetLevelRight(System.Int32)">
            <summary>
            Gets the Level of the Right Channel.
            </summary>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetLevel(System.Int32,System.Single[],System.Single,ManagedBass.LevelRetrievalFlags)">
            <summary>
            Retrieves the level (peak amplitude) of a sample, stream, MOD music or recording channel.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="Levels">The array in which the levels are to be returned.</param>
            <param name="Length">How much data (in seconds) to look at to get the level (limited to 1 second).</param>
            <param name="Flags">What levels to retrieve.</param>
            <returns>
            On success <see langword="true" /> is returned - else <see langword="false" />, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            <para>If successful, the requested levels are returned in the <paramref name="Levels" /> array.</para>
            </returns>
            <remarks>
            This function operates in the same way as <see cref="M:ManagedBass.Bass.ChannelGetLevel(System.Int32)" /> but has greater flexibility on how the level is measured.
            The levels are not clipped, so may exceed +/-1.0 on floating-point channels.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.NotPlaying">The channel is not playing.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The decoding channel has reached the end.</exception>
            <exception cref="F:ManagedBass.Errors.BufferLost">Should not happen... check that a valid window handle was used with <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" />.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetLevel(System.Int32,System.Single,ManagedBass.LevelRetrievalFlags)">
            <summary>
            Retrieves the level (peak amplitude) of a sample, stream, MOD music or recording channel.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="Length">How much data (in seconds) to look at to get the level (limited to 1 second).</param>
            <param name="Flags">What levels to retrieve.</param>
            <returns>Array of levels on success, else <see langword="null" />. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function operates in the same way as <see cref="M:ManagedBass.Bass.ChannelGetLevel(System.Int32)" /> but has greater flexibility on how the level is measured.
            The levels are not clipped, so may exceed +/-1.0 on floating-point channels.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.NotPlaying">The channel is not playing.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The decoding channel has reached the end.</exception>
            <exception cref="F:ManagedBass.Errors.BufferLost">Should not happen... check that a valid window handle was used with <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" />.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a sample channel, stream, MOD music, or recording channel.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="Buffer">Location to write the data as an <see cref="T:System.IntPtr"/> (can be <see cref="F:System.IntPtr.Zero" /> when handle is a recording channel (HRECORD), to discard the requested amount of data from the recording buffer).</param>
            <param name="Length">Number of bytes wanted, and/or the <see cref="T:ManagedBass.DataFlags" /></param>
            <returns>If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> or DataFlags.Fixed flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>
            This function can only return as much data as has been written to the channel's buffer, so it may not always be possible to get the amount of data requested, especially if you request large amounts.
            If you really do need large amounts, then increase the buffer lengths (<see cref="P:ManagedBass.Bass.PlaybackBufferLength"/>).
            The <see cref="F:ManagedBass.DataFlags.Available"/> flag can be used to check how much data a channel's buffer contains at any time, including when stopped or stalled.
            </para>
            <para>When requesting data from a decoding channel, data is decoded directly from the channel's source (no playback buffer) and as much data as the channel has available can be decoded at a time.</para>
            <para>When retrieving sample data, 8-bit samples are unsigned (0 to 255), 16-bit samples are signed (-32768 to 32767), 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).
            That is unless the <see cref="F:ManagedBass.DataFlags.Float"/> flag is used, in which case, the sample data will be converted to 32-bit floating-point if it is not already, or if the DataFlags.Fixed flag is used, in which case the data will be coverted to 8.24 fixed-point.
            </para>
            <para>
            Unless complex data is requested via the <see cref="F:ManagedBass.DataFlags.FFTComplex"/> flag, the magnitudes of the first half of an FFT result are returned.
            For example, with a 2048 sample FFT, there will be 1024 floating-point values returned.
            If the DataFlags.Fixed flag is used, then the FFT values will be in 8.24 fixed-point form rather than floating-point.
            Each value, or "bin", ranges from 0 to 1 (can actually go higher if the sample data is floating-point and not clipped).
            The 1st bin contains the DC component, the 2nd contains the amplitude at 1/2048 of the channel's sample rate, followed by the amplitude at 2/2048, 3/2048, etc.
            A Hann window is applied to the sample data to reduce leakage, unless the <see cref="F:ManagedBass.DataFlags.FFTNoWindow"/> flag is used.
            When a window is applied, it causes the DC component to leak into the next bin, but that can be removed (reduced to 0) by using the <see cref="F:ManagedBass.DataFlags.FFTRemoveDC"/> flag.
            Doing so slightly increases the processing required though, so it should only be done when needed, which is when a window is applied and the 2nd bin value is important.
            </para>
            <para>
            Channels that have 2 or more sample channels (ie. stereo or above) may have FFT performed on each individual channel, using the <see cref="F:ManagedBass.DataFlags.FFTIndividual"/> flag.
            Without this flag, all of the channels are combined, and a single mono FFT is performed.
            Performing the extra individual FFTs of course increases the amount of processing required.
            The return values are interleaved in the same order as the channel's sample data, eg. stereo = left,right,left,etc.
            </para>
            <para>This function is most useful if you wish to visualize (eg. spectrum analyze) the sound.</para>
            <para><b>Platform-specific:</b></para>
            <para>The DataFlags.Fixed flag is only available on Android and Windows CE.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The channel has reached the end.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The <see cref="F:ManagedBass.DataFlags.Available"/> flag was used with a decoding channel.</exception>
            <exception cref="F:ManagedBass.Errors.BufferLost">Should not happen... check that a valid window handle was used with <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" />.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a sample channel, stream, MOD music, or recording channel.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="Buffer">Location to write the data as a byte[].</param>
            <param name="Length">Number of bytes wanted, and/or the <see cref="T:ManagedBass.DataFlags" /></param>
            <returns>If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> or DataFlags.Fixed flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a sample channel, stream, MOD music, or recording channel.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="Buffer">Location to write the data as a short[].</param>
            <param name="Length">Number of bytes wanted, and/or the <see cref="T:ManagedBass.DataFlags" /></param>
            <returns>If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> or DataFlags.Fixed flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a sample channel, stream, MOD music, or recording channel.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="Buffer">Location to write the data as a int[].</param>
            <param name="Length">Number of bytes wanted, and/or the <see cref="T:ManagedBass.DataFlags" /></param>
            <returns>If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> or DataFlags.Fixed flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.Single[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a sample channel, stream, MOD music, or recording channel.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="Buffer">Location to write the data as a float[].</param>
            <param name="Length">Number of bytes wanted, and/or the <see cref="T:ManagedBass.DataFlags" /></param>
            <returns>If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> or DataFlags.Fixed flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
        </member>
        <member name="M:ManagedBass.Bass.ChannelUpdate(System.Int32,System.Int32)">
            <summary>
            Updates the playback buffer of a stream or MOD music.
            </summary>
            <param name="Handle">The channel handle... a HMUSIC or HSTREAM.</param>
            <param name="Length">
            The amount to render, in milliseconds... 0 = default (2 x <see cref="P:ManagedBass.Bass.UpdatePeriod" />).
            This is capped at the space available in the buffer.
            </param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            When starting playback of a stream or MOD music, after creating it or changing its position, there will be a slight delay while the initial data is decoded for playback.
            Usually the delay is not noticeable or important, but if you need playback to start instantly when you call <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" />, then use this function first.
            The length parameter should be at least equal to the <see cref="P:ManagedBass.Bass.UpdatePeriod" />.
            </para>
            <para>
            It may not always be possible to render the requested amount of data, in which case this function will still succeed.
            <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> (<see cref="F:ManagedBass.DataFlags.Available"/>) can be used to check how much data a channel has buffered for playback.
            </para>
            <para>
            When automatic updating is disabled (<see cref="P:ManagedBass.Bass.UpdatePeriod" /> = 0 or <see cref="P:ManagedBass.Bass.UpdateThreads" /> = 0),
            this function could be used instead of <see cref="M:ManagedBass.Bass.Update(System.Int32)" /> to implement different update periods for different channels,
            instead of a single update period for all.
            Unlike <see cref="M:ManagedBass.Bass.Update(System.Int32)" />, this function can also be used while automatic updating is enabled.
            </para>
            <para>The CPU usage of this function is not included in the <see cref="P:ManagedBass.Bass.CPUUsage" /> reading.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Decoding channels do not have playback buffers.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The channel has ended.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="P:ManagedBass.Bass.Float">
            <summary>
            Gets if Floating-Point audio is supported on the current platform.
            </summary>
        </member>
        <member name="P:ManagedBass.Bass.PlaybackBufferLength">
            <summary>
            The Buffer Length in milliseconds (default = 500).
            </summary>
            <remarks>
            <para>
            The minimum Length is 1ms above the update period (See <see cref="P:ManagedBass.Bass.UpdatePeriod"/>),
            the maximum is 5000 milliseconds.
            If the Length specified is outside this range, it is automatically capped.
            Increasing the Length, decreases
            the chance of the sound possibly breaking-up on slower computers, but also
            increases the latency for DSP/FX.
            </para>
            <para>
            Small Buffer lengths are only required if the sound is going to be changing in real-time, for example, in a soft-synth.
            If you need to use a small Buffer, then the <see cref="P:ManagedBass.BassInfo.MinBufferLength"/> should be used to get the recommended
            minimum Buffer Length supported by the device and it's drivers.
            Even at this default Length, it's still possible that the sound could break up on some systems,
            it's also possible that smaller buffers may be fine.
            So when using small buffers, you should have an option in your software for the User to finetune the Length used, for optimal performance.
            Using this config option only affects the HMUSIC/HSTREAM channels that you create afterwards, not the ones that have already been created.
            So you can have channels with differing Buffer lengths by using this config option each time before creating them.
            If automatic updating is disabled, make sure you call <see cref="M:ManagedBass.Bass.Update(System.Int32)"/>
            frequently enough to keep the buffers updated.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.UpdatePeriod">
            <summary>
            The update period of HSTREAM and HMUSIC channel playback buffers in milliseconds.
            </summary>
            <remarks>
            <para>
            0 = disable automatic updating.
            The minimum period is 5ms, the maximum is 100ms.
            If the period specified is outside this range, it is automatically capped.
            The default period is 100ms.
            </para>
            <para>
            The update period is the amount of time between updates of the playback buffers of HSTREAM/HMUSIC channels.
            Shorter update periods allow smaller buffers to be set with the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> option, but
            as the rate of updates increases, so the overhead of setting up the updates becomes a greater part of the CPU usage.
            The update period only affects HSTREAM and HMUSIC channels, it does not affect samples.
            Nor does it have any effect on decoding channels, as they are not played.
            BASS creates one or more threads (determined by <see cref="P:ManagedBass.Bass.UpdateThreads"/>)
            specifically to perform the updating, except when automatic updating is disabled
            (period=0) - then you must regularly call <see cref="M:ManagedBass.Bass.Update(System.Int32)"/> or <see cref="M:ManagedBass.Bass.ChannelUpdate(System.Int32,System.Int32)"/> instead.
            This allows you to synchronize BASS's CPU usage with your program's.
            For example, in a game loop you could call <see cref="M:ManagedBass.Bass.Update(System.Int32)"/>
            once per frame, which keeps all the processing in sync so that the frame rate is as smooth as possible.
            <see cref="M:ManagedBass.Bass.Update(System.Int32)"/> should be called at least around 8 times per second, even more often if the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/>
            option is used to set smaller buffers.
            The update period can be altered at any time, including during playback.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.GlobalSampleVolume">
            <summary>
            Global sample volume level... 0 (silent) - 10000 (full).
            </summary>
            <remarks>
            This config option allows you to have control over the volume levels of all the samples,
            which is useful for setup options (eg. separate music and fx volume controls).
            A channel's final volume = channel volume * global volume / max volume.
            So, for example, if a stream channel's volume is 0.5 and the global stream volume is 8000,
            then effectively the stream's volume level is 0.4 (0.5 * 8000 / 10000 = 0.4).
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.GlobalStreamVolume">
            <summary>
            Global stream volume level... 0 (silent) - 10000 (full).
            </summary>
            <remarks>
            This config option allows you to have control over the volume levels of all streams,
            which is useful for setup options (eg. separate music and fx volume controls).
            A channel's final volume = channel volume * global volume / max volume.
            So, for example, if a stream channel's volume is 0.5 and the global stream volume is 8000,
            then effectively the stream's volume level is 0.4 (0.5 * 8000 / 10000 = 0.4).
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.GlobalMusicVolume">
            <summary>
            Global music volume level... 0 (silent) - 10000 (full).
            </summary>
            <remarks>
            This config option allows you to have control over the volume levels of all the MOD musics,
            which is useful for setup options (eg. separate music and fx volume controls).
            A channel's final volume = channel volume * global volume / max volume.
            So, for example, if a stream channel's volume is 0.5 and the global stream volume is 8000,
            then effectively the stream's volume level is 0.4 (0.5 * 8000 / 10000 = 0.4).
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.LogarithmicVolumeCurve">
            <summary>
            Volume translation curve... false = Linear (Default), true = Logarithmic.
            </summary>
            <remarks>
            DirectSound uses logarithmic volume and panning curves, which can be awkward to work with.
            For example, with a logarithmic curve, the audible difference between 10000 and 9000,
            is not the same as between 9000 and 8000.
            With a linear "curve" the audible difference is spread equally across the whole range of values,
            so in the previous example the audible difference between 10000 and 9000,
            and between 9000 and 8000 would be identical.
            When using the linear curve, the volume range is from 0% (silent) to 100% (full).
            When using the logarithmic curve, the volume range is from -100 dB (effectively silent) to 0 dB (full).
            For example, a volume level of 0.5 is 50% linear or -50 dB logarithmic.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.LogarithmicPanningCurve">
            <summary>
            Panning translation curve... false = Linear (Default), true = Logarithmic.
            </summary>
            <remarks>
            The panning curve affects panning in exactly the same way as the <see cref="P:ManagedBass.Bass.LogarithmicVolumeCurve"/> affects the volume.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.FloatingPointDSP">
            <summary>
            Pass 32-bit floating-point sample data to all <see cref="T:ManagedBass.DSPProcedure"/> callback functions.
            </summary>
            <remarks>
            Normally DSP functions receive sample data in whatever format the channel is using, ie. it can be 8, 16 or 32-bit.
            But using this config option, BASS will convert 8/16-bit sample data to 32-bit floating-point before passing
            it to DSP functions, and then convert it back after all the DSP functions are done.
            As well as simplifying the DSP code (no need for 8/16-bit processing),
            this also means that there is no degradation of quality as sample data passes through a chain of DSP.
            This config option also applies to effects set via <see cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)"/>,
            except for DX8 effects when using the "With FX flag" DX8 effect implementation.
            Changing the setting while there are DSP or FX set could cause problems, so should be avoided.
            <para>
            <b>Platform-specific</b>: On Android and Windows CE, 8.24 bit fixed-point is used instead of floating-point.
            Floating-point DX8 effect processing requires DirectX 9 (or above) on Windows.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.UpdateThreads">
            <summary>
            The number of threads to use for updating playback buffers... 0 = Disable automatic updating.
            </summary>
            <remarks>
            The number of update threads determines how many HSTREAM/HMUSIC channel playback buffers can be updated in parallel;
            each thread can process one channel at a time.
            The default is to use a single thread, but additional threads can be used to take advantage of multiple CPU cores.
            There is generally nothing much to be gained by creating more threads than there are CPU cores,
            but one benefit of using multiple threads even with a single CPU core is that
            a slow updating channel need not delay the updating of other channels.
            When automatic updating is disabled (threads = 0), <see cref="M:ManagedBass.Bass.Update(System.Int32)"/> or <see cref="M:ManagedBass.Bass.ChannelUpdate(System.Int32,System.Int32)"/> should be used instead.
            The number of update threads can be changed at any time, including during playback.
            <para><b>Platform-specific</b>: The number of update threads is limited to 1 on Windows CE platforms.</para>
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.AsyncFileBufferLength">
            <summary>
            The Buffer Length (in bytes) for asynchronous file reading (default setting is 65536 bytes (64KB)).
            </summary>
            <remarks>
            This will be rounded up to the nearest 4096 byte (4KB) boundary.
            This determines the amount of file data that can be read ahead of time with asynchronous file reading.
            Changes only affect streams that are created afterwards, not any that already exist.
            So it is possible to have streams with differing Buffer lengths
            by using this config option before creating each of them.
            When asynchronous file reading is enabled, the Buffer level is available from <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)"/>.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.HandleCount">
            <summary>
            Gets the total number of HSTREAM/HSAMPLE/HMUSIC/HRECORD handles.
            </summary>
            <remarks>
            The Handle count may not only include the app-created stuff but also internal stuff.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.NetTimeOut">
            <summary>
            Time (in milliseconds) to wait for a server to respond to a connection request.
            The default timeout is 5 seconds (5000 milliseconds).
            </summary>
        </member>
        <member name="P:ManagedBass.Bass.NetReadTimeOut">
            <summary>
            The time (in milliseconds) to wait for a server to deliver more data for an internet stream. (default=0, infinite).
            When the timeout is hit, the connection with the server will be closed.
            </summary>
        </member>
        <member name="P:ManagedBass.Bass.NetBufferLength">
            <summary>
            The internet download Buffer Length, in milliseconds.
            </summary>
            <remarks>
            Increasing the Buffer Length decreases the chance of the stream stalling,
            but also increases the time taken by <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)"/>
            to create the stream, as it has to pre-Buffer more data (adjustable via the <see cref="P:ManagedBass.Bass.NetPreBuffer"/> option).
            Aside from the pre-buffering, this setting has no effect on streams without either the <see cref="F:ManagedBass.BassFlags.StreamDownloadBlocks"/>
            or <see cref="F:ManagedBass.BassFlags.RestrictDownloadRate"/> flags.
            When streaming in blocks, this option determines the download Buffer Length.
            The effective Buffer Length can actually be a bit more than that specified,
            including data that has been read from the Buffer by the decoder but not yet decoded.
            This config option also determines the buffering used by "buffered" User file streams
            created with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)"/>.
            The default Buffer Length is 5 seconds (5000 milliseconds).
            The net Buffer Length should be larger than the Length of the playback Buffer (<see cref="P:ManagedBass.Bass.PlaybackBufferLength"/>),
            otherwise the stream is likely to briefly stall soon after starting playback.
            Using this config option only affects streams created afterwards, not any that have already been created.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.PauseNoPlay">
            <summary>
            Prevent channels being played when the output is paused? (default = true)
            </summary>
            <remarks>
            When the output is paused using <see cref="M:ManagedBass.Bass.Pause"/>, and this config option is enabled,
            channels can't be played until the output is resumed using <see cref="M:ManagedBass.Bass.Start"/>.
            Attempts to play a channel will give a <see cref="F:ManagedBass.Errors.Start"/> error.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.NetPreBuffer">
            <summary>
            Amount (percentage) to pre-Buffer when opening internet streams. (default = 75%)
            </summary>
            <remarks>
            This setting determines what percentage of the Buffer Length (<see cref="P:ManagedBass.Bass.NetBufferLength"/>)
            should be filled by <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)"/>.
            Setting this lower (eg. 0) is useful if you want to display a "buffering progress" (using <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)"/>)
            when opening internet streams, but note that this setting is just a minimum.
            BASS will always pre-download a certain amount to verify the stream.
            As well as internet streams, this config setting also applies to "buffered" User file streams
            created with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)"/>.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.FTPPassive">
            <summary>
            Use passive mode in FTP connections? (default = true)
            Changes take effect from the next internet stream creation call.
            </summary>
        </member>
        <member name="P:ManagedBass.Bass.NetPlaylist">
            <summary>
            Process URLs in PLS, M3U, WPL or ASX playlists?...
            0 = never (Default),
            1 = in <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)"/> only,
            2 = in <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)"/> and <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)"/> too.
            </summary>
            <remarks>
            When enabled, BASS will process PLS, M3U, WPL and ASX playlists,
            going through each entry until it finds a URL that it can play.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.NetAgent">
            <summary>
            The "User-Agent" request header sent to servers.
            </summary>
        </member>
        <member name="P:ManagedBass.Bass.NetProxy">
            <summary>
            Proxy server settings (in the form of "User:pass@server:port"... null = don't use a proxy). "" (empty string) = use the OS's default proxy settings.
            </summary>
            <remarks>
            If only the "User:pass@" part is specified, then those authorization credentials are used with the default proxy server.
            If only the "server:port" part is specified, then that proxy server is used without any authorization credentials.
            Changes take effect from the next internet stream creation call.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.MusicVirtial">
            <summary>
            The maximum number of virtual channels to use in the rendering of IT files... 1 (min) to 512 (max). (default = 64).
            </summary>
            <remarks>
            If the value specified is outside this range, it is automatically capped.
            This setting only affects IT files, as the other MOD music formats do not have virtual channels.
            Changes only apply to subsequently loaded files, not any that are already loaded.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.FileVerificationBytes">
            <summary>
            The amount of data (in bytes) to check in order to verify/detect the file format... 1000 (min) to 100000 (max). (default = 16000 bytes).
            </summary>
            <remarks>
            If the value specified is outside this range, it is automatically capped.
            Of the file formats supported as standard, this setting only affects the detection of MP3/MP2/MP1 formats,
            but it may also be used by add-ons (see the documentation).
            For internet (and "buffered" User file) streams, a quarter of the Length is used, up to a minimum of 1000 bytes.
            The verification Length excludes any tags that may be at the start of the file.
            For internet (and "buffered" User file) streams, the <see cref="P:ManagedBass.Bass.NetVerificationBytes"/> setting determines how much data is checked.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.NetVerificationBytes">
            <summary>
            The amount of data to check (in bytes) in order to verify/detect the file format of internet streams... 1000 (min) to 1000000 (max),
            or 0 = 25% of the <see cref="P:ManagedBass.Bass.FileVerificationBytes"/> setting (with a minimum of 1000 bytes).
            </summary>
            <remarks>
            If the value specified is outside this range, it is automatically capped.
            Of the file formats supported as standard, this setting only affects the detection of MP3/MP2/MP1 formats,
            but it may also be used by add-ons (see the documentation).
            The verification Length excludes any tags that may be found at the start of the file.
            The default setting is 0, which means 25% of the <see cref="P:ManagedBass.Bass.FileVerificationBytes"/> setting.
            As well as internet streams, this config setting also applies to "buffered" User file streams
            created with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)"/>.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.SuppressMP3ErrorCorruptionSilence">
            <summary>
            Suppress silencing for corrupted MP3 frames. (default is false).
            </summary>
            <remarks>
            When BASS is detecting some corruption in an MP3 file's Huffman coding,
            it silences the frame to avoid any unpleasent noises that can result from corruption.
            Set this parameter to true in order to suppress this behavior.
            This applies only to the regular BASS version and NOT the "mp3-free" version.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.SRCQuality">
            <summary>
            Gets or Sets the default sample rate conversion quality...
            0 = linear interpolation,
            1 = 8 point sinc interpolation (Default),
            2 = 16 point sinc interpolation,
            3 = 32 point sinc interpolation.
            Other values are also accepted.
            </summary>
            <remarks>
            This config option determines what sample rate conversion
            quality new channels will initially have, except for sample channels (HCHANNEL),
            which use the <see cref="P:ManagedBass.Bass.SampleSRCQuality"/> setting.
            A channel's sample rate conversion quality can subsequently
            be changed via the <see cref="F:ManagedBass.ChannelAttribute.SampleRateConversion"/> attribute (see <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)"/>).
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.SampleSRCQuality">
            <summary>
            Gets or Sets the default sample rate conversion quality for samples...
            0 = linear interpolation (Default),
            1 = 8 point sinc interpolation,
            2 = 16 point sinc interpolation,
            3 = 32 point sinc interpolation.
            Other values are also accepted.
            </summary>
            <remarks>
            This config option determines what sample rate conversion quality a new sample
            channel will initially have, following a <see cref="M:ManagedBass.Bass.SampleGetChannel(System.Int32,System.Boolean)"/> call.
            The channel's sample rate conversion quality can subsequently be changed
            via the <see cref="F:ManagedBass.ChannelAttribute.SampleRateConversion"/> attribute (see <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)"/>).
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.OggPreScan">
            <summary>
            Pre-scan chained OGG files? (enabled by default)
            </summary>
            <remarks>
            This option is equivalent to including the <see cref="F:ManagedBass.BassFlags.Prescan"/> flag
            in a <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)"/> call when opening an OGG file.
            It can be disabled if seeking and an accurate Length reading are not required from chained OGG files,
            for faster stream creation.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.DeviceNonStop">
            <summary>
            Do not stop the output device when nothing is playing on it?
            </summary>
        </member>
        <member name="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>
            Creates a sample stream from an MP3, MP2, MP1, OGG, WAV, AIFF or plugin supported file.
            </summary>
            <param name="File">Filename for which a stream should be created.</param>
            <param name="Offset">File Offset to begin streaming from.</param>
            <param name="Length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="Flags">Any combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            BASS has built-in support for MPEG, OGG, WAV and AIFF files.
            Support for additional formats is available via add-ons, which can be downloaded from the BASS website: <a href="http://www.un4seen.com">www.un4seen.com</a>.
            </para>
            <para>
            MPEG 1.0, 2.0 and 2.5 layer 3 (MP3) files are supported, layers 1 (MP1) and 2 (MP2) are also supported.
            Standard RIFF and RF64 WAV files are supported, with the sample data in a PCM format or compressed with an ACM codec, but the codec is required to be installed on the user's system for the WAV to be decoded.
            So you should either distribute the codec with your software, or use a codec that comes with Windows (eg. Microsoft ADPCM).
            All PCM formats from 8 to 32-bit are supported in WAV and AIFF files, but the output will be restricted to 16-bit unless the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used.
            64-bit floating-point WAV and AIFF files are also supported, but are rendered in 16-bit or 32-bit floating-point depending on the flags.
            The file's original resolution is available via <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" />.
            </para>
            <para>
            Chained OGG files containing multiple logical bitstreams are supported, but seeking within them is only fully supported if the <see cref="F:ManagedBass.BassFlags.Prescan"/> flag is used (or the <see cref="P:ManagedBass.Bass.OggPreScan"/> config option is enabled) to have them pre-scanned.
            Without pre-scanning, seeking will only be possible back to the start.
            The <see cref="F:ManagedBass.PositionFlags.OGG"/> mode can be used with <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" /> to get the number of bitstreams and with <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> to seek to a particular one.
            A <see cref="F:ManagedBass.SyncFlags.OggChange"/> sync can be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> to be informed of when a new bitstream begins during decoding/playback.
            </para>
            <para>Multi-channel (ie. more than stereo) OGG, WAV and AIFF files are supported.</para>
            <para>
            Use <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" /> to retrieve information on the format (sample rate, resolution, channels) of the stream.
            The playback length of the stream can be retrieved using <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" />.
            </para>
            <para>
            If <paramref name="Length"/> = 0 (use all data up to the end of the file), and the file length increases after creating the stream (ie. the file is still being written), then BASS will play the extra data too, but the length returned by <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" /> will not be updated until the end is reached.
            The <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" /> return values will be updated during playback of the extra data though.
            </para>
            <para>
            To stream a file from the internet, use <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" />.
            To stream from other locations, see <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" />.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            On Windows and Windows CE, ACM codecs are supported with compressed WAV files.
            Media Foundation codecs are also supported on Windows 7 and updated versions of Vista, including support for AAC/MP4 and WMA.
            On iOS and OSX, CoreAudio codecs are supported, adding support for any file formats that have a codec installed.
            Media Foundation and CoreAudio codecs are only tried after the built-in decoders and any plugins have rejected the file.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding channels (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device. The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is also unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Length" /> must be specified when streaming from memory.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">The <paramref name="File"/> could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The file's format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.Codec">The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>  
        </member>
        <member name="M:ManagedBass.Bass.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>
            Creates a sample stream from an MP3, MP2, MP1, OGG, WAV, AIFF or plugin supported memory IntPtr.
            </summary>
            <param name="Memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="Offset">Offset to begin streaming from.</param>
            <param name="Length">Data length (needs to be set to the length of the memory stream in bytes which should be played).</param>
            <param name="Flags">Any combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            BASS has built-in support for MPEG, OGG, WAV and AIFF files.
            Support for additional formats is available via add-ons, which can be downloaded from the BASS website: <a href="http://www.un4seen.com">www.un4seen.com</a>.
            </para>
            <para>
            MPEG 1.0, 2.0 and 2.5 layer 3 (MP3) files are supported, layers 1 (MP1) and 2 (MP2) are also supported.
            Standard RIFF and RF64 WAV files are supported, with the sample data in a PCM format or compressed with an ACM codec, but the codec is required to be installed on the user's system for the WAV to be decoded.
            So you should either distribute the codec with your software, or use a codec that comes with Windows (eg. Microsoft ADPCM).
            All PCM formats from 8 to 32-bit are supported in WAV and AIFF files, but the output will be restricted to 16-bit unless the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used.
            64-bit floating-point WAV and AIFF files are also supported, but are rendered in 16-bit or 32-bit floating-point depending on the flags.
            The file's original resolution is available via <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" />.
            </para>
            <para>
            Chained OGG files containing multiple logical bitstreams are supported, but seeking within them is only fully supported if the <see cref="F:ManagedBass.BassFlags.Prescan"/> flag is used (or the <see cref="P:ManagedBass.Bass.OggPreScan"/> config option is enabled) to have them pre-scanned.
            Without pre-scanning, seeking will only be possible back to the start.
            The <see cref="F:ManagedBass.PositionFlags.OGG"/> mode can be used with <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" /> to get the number of bitstreams and with <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> to seek to a particular one.
            A <see cref="F:ManagedBass.SyncFlags.OggChange"/> sync can be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> to be informed of when a new bitstream begins during decoding/playback.
            </para>
            <para>Multi-channel (ie. more than stereo) OGG, WAV and AIFF files are supported.</para>
            <para>
            Use <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" /> to retrieve information on the format (sample rate, resolution, channels) of the stream.
            The playback length of the stream can be retrieved using <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" />.
            </para>
            <para>
            If <paramref name="Length"/> = 0 (use all data up to the end of the file), and the file length increases after creating the stream (ie. the file is still being written), then BASS will play the extra data too, but the length returned by <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" /> will not be updated until the end is reached.
            The <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" /> return values will be updated during playback of the extra data though.
            </para>
            <para>
            When streaming from memory, the memory must not be freed before the stream is freed.
            There may be exceptions to that with some add-ons (see the documentation).
            </para>
            <para>
            To stream a file from the internet, use <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" />.
            To stream from other locations, see <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" />.
            </para>
            <para>The Memory buffer must be pinned when using this overload.</para>
            <para><b>Platform-specific</b></para>
            <para>
            On Windows and Windows CE, ACM codecs are supported with compressed WAV files.
            Media Foundation codecs are also supported on Windows 7 and updated versions of Vista, including support for AAC/MP4 and WMA.
            On iOS and OSX, CoreAudio codecs are supported, adding support for any file formats that have a codec installed.
            Media Foundation and CoreAudio codecs are only tried after the built-in decoders and any plugins have rejected the file.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding channels (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device. The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is also unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Length" /> must be specified when streaming from memory.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The file's format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.Codec">The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags)">
            <summary>
            Creates a sample stream from an MP3, MP2, MP1, OGG, WAV, AIFF or plugin supported file in memory (byte[]).
            </summary>
            <param name="Memory">A byte[] containing file data.</param>
            <param name="Offset">Offset to begin streaming from.</param>
            <param name="Length">Data length (needs to be set to the length of the memory stream in bytes which should be played).</param>
            <param name="Flags">Any combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            BASS has built-in support for MPEG, OGG, WAV and AIFF files.
            Support for additional formats is available via add-ons, which can be downloaded from the BASS website: <a href="http://www.un4seen.com">www.un4seen.com</a>.
            </para>
            <para>
            MPEG 1.0, 2.0 and 2.5 layer 3 (MP3) files are supported, layers 1 (MP1) and 2 (MP2) are also supported.
            Standard RIFF and RF64 WAV files are supported, with the sample data in a PCM format or compressed with an ACM codec, but the codec is required to be installed on the user's system for the WAV to be decoded.
            So you should either distribute the codec with your software, or use a codec that comes with Windows (eg. Microsoft ADPCM).
            All PCM formats from 8 to 32-bit are supported in WAV and AIFF files, but the output will be restricted to 16-bit unless the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used.
            64-bit floating-point WAV and AIFF files are also supported, but are rendered in 16-bit or 32-bit floating-point depending on the flags.
            The file's original resolution is available via <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" />.
            </para>
            <para>
            Chained OGG files containing multiple logical bitstreams are supported, but seeking within them is only fully supported if the <see cref="F:ManagedBass.BassFlags.Prescan"/> flag is used (or the <see cref="P:ManagedBass.Bass.OggPreScan"/> config option is enabled) to have them pre-scanned.
            Without pre-scanning, seeking will only be possible back to the start.
            The <see cref="F:ManagedBass.PositionFlags.OGG"/> mode can be used with <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" /> to get the number of bitstreams and with <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> to seek to a particular one.
            A <see cref="F:ManagedBass.SyncFlags.OggChange"/> sync can be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> to be informed of when a new bitstream begins during decoding/playback.
            </para>
            <para>Multi-channel (ie. more than stereo) OGG, WAV and AIFF files are supported.</para>
            <para>
            Use <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" /> to retrieve information on the format (sample rate, resolution, channels) of the stream.
            The playback length of the stream can be retrieved using <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" />.
            </para>
            <para>
            If <paramref name="Length"/> = 0 (use all data up to the end of the file), and the file length increases after creating the stream (ie. the file is still being written), then BASS will play the extra data too, but the length returned by <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" /> will not be updated until the end is reached.
            The <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" /> return values will be updated during playback of the extra data though.
            </para>
            <para>
            The <paramref name="Memory"/> is pinned by this overload and freed when the stream is freed.
            </para>
            <para>
            To stream a file from the internet, use <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" />.
            To stream from other locations, see <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" />.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            On Windows and Windows CE, ACM codecs are supported with compressed WAV files.
            Media Foundation codecs are also supported on Windows 7 and updated versions of Vista, including support for AAC/MP4 and WMA.
            On iOS and OSX, CoreAudio codecs are supported, adding support for any file formats that have a codec installed.
            Media Foundation and CoreAudio codecs are only tried after the built-in decoders and any plugins have rejected the file.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding channels (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device. The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is also unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="Length" /> must be specified when streaming from memory.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The file's format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.Codec">The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)">
            <summary>
            Creates a sample stream from an MP3, MP2, MP1, OGG, WAV, AIFF or plugin supported file via user callback functions.
            </summary>
            <param name="System">File system to use.</param>
            <param name="Flags">Any combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Procedures">The user defined file function (see <see cref="T:ManagedBass.FileProcedures" />).</param>
            <param name="User">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            The buffered file system (<see cref="F:ManagedBass.StreamSystem.Buffer"/>) is what is used by <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" />.
            As the name suggests, data from the file is buffered so that it's readily available for decoding - BASS creates a thread dedicated to "downloading" the data.
            This is ideal for when the data is coming from a source that has high latency, like the internet.
            It's not possible to seek in buffered file streams, until the download has reached the requested position - it's not possible to seek at all if it's being streamed in blocks.
            </para>
            <para>
            The push buffered file system (<see cref="F:ManagedBass.StreamSystem.BufferPush"/>) is the same, except that instead of the file data being pulled from the <see cref="T:ManagedBass.FileReadProcedure" /> function in a "download" thread, the data is pushed to BASS via <see cref="M:ManagedBass.Bass.StreamPutFileData(System.Int32,System.IntPtr,System.Int32)" />.
            A <see cref="T:ManagedBass.FileReadProcedure" /> function is still required, to get the initial data used in the creation of the stream.
            </para>
            <para>
            The unbuffered file system (<see cref="F:ManagedBass.StreamSystem.NoBuffer"/>) is what is used by <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)" />.
            In this system, BASS does not do any intermediate buffering - it simply requests data from the file as and when it needs it.
            This means that reading (<see cref="T:ManagedBass.FileReadProcedure" />) must be quick, otherwise the decoding will be delayed and playback buffer underruns (old data repeated) are a possibility.
            It's not so important for seeking (<see cref="T:ManagedBass.FileSeekProcedure" />) to be fast, as that is generally not required during decoding, except when looping a file.
            </para>
            <para>In all cases, BASS will automatically stall playback of the stream when insufficient data is available, and resume it when enough data does become available.</para>
            <para><b>Platform-specific</b></para>
            <para>
            On Windows and Windows CE, ACM codecs are supported with compressed WAV files.
            Media Foundation codecs are also supported on Windows 7 and updated versions of Vista, including support for AAC/MP4 and WMA.
            On iOS and OSX, CoreAudio codecs are supported, adding support for any file formats that have a codec installed.
            Media Foundation and CoreAudio codecs are only tried after the built-in decoders and any plugins have rejected the file.
            </para>
            <para>
            A copy is made of the <paramref name="Procedures"/> callback function table, so it does not have to persist beyond this function call.
            Unlike Bass.Net, a reference to <paramref name="Procedures"/> doesn't need to be held by you manually.
            ManagedBass automatically holds a reference and frees it when the Channel is freed.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding channels (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device. The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is also unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="System" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The file's format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.Codec">The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)">
            <summary>
            Creates a sample stream from an MP3, MP2, MP1, OGG, WAV, AIFF or plugin supported file on the internet, optionally receiving the downloaded data in a callback.
            </summary>
            <param name="Url">
            URL of the file to stream.
            Should begin with "http://", "https://" or "ftp://", or another add-on supported protocol.
            The URL can be followed by custom HTTP request headers to be sent to the server;
            the URL and each header should be terminated with a carriage return and line feed ("\r\n").
            </param>
            <param name="Offset">File position to start streaming from. This is ignored by some servers, specifically when the file length is unknown, for example a Shout/Icecast server.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags" /></param>
            <param name="Procedure">Callback function to receive the file as it is downloaded... <see langword="null" /> = no callback.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Use <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" /> to retrieve information on the format (sample rate, resolution, channels) of the stream.
            The playback length of the stream can be retrieved using <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" />.
            </para>
            <para>
            When playing the stream, BASS will stall the playback if there is insufficient data to continue playing.
            Playback will automatically be resumed when sufficient data has been downloaded.
            <see cref="M:ManagedBass.Bass.ChannelIsActive(System.Int32)" /> can be used to check if the playback is stalled, and the progress of the file download can be checked with <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" />.
            </para>
            <para>When streaming in blocks (<see cref="F:ManagedBass.BassFlags.StreamDownloadBlocks"/>), be careful not to stop/pause the stream for too long, otherwise the connection may timeout due to there being no activity and the stream will end prematurely.</para>
            <para>
            When streaming from Shoutcast servers, metadata (track titles) may be sent by the server.
            The data can be retrieved with <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)" />.
            A sync can also be set (using <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />) so that you are informed when metadata is received.
            A <see cref="F:ManagedBass.SyncFlags.OggChange"/> sync can be used to be informed of when a new logical bitstream begins in an Icecast/OGG stream.
            </para>
            <para>
            When using an <paramref name="Offset" />, the file length returned by <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" /> can be used to check that it was successful by comparing it with the original file length.
            Another way to check is to inspect the HTTP headers retrieved with <see cref="M:ManagedBass.Bass.ChannelGetTags(System.Int32,ManagedBass.TagType)" />.
            </para>
            <para>Custom HTTP request headers may be ignored by some plugins, notably BassWma.</para>
            <para>
            Unlike Bass.Net, a reference to <paramref name="Procedure"/> doesn't need to be held by you manually.
            ManagedBass automatically holds a reference and frees it when the Channel is freed.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            On Windows and Windows CE, ACM codecs are supported with compressed WAV files.
            Media Foundation codecs are also supported on Windows 7 and updated versions of Vista, including support for AAC and WMA.
            On iOS and OSX, CoreAudio codecs are supported, including support for AAC and ALAC.
            Media Foundation and CoreAudio codecs are only tried after the built-in decoders and any plugins have rejected the file.
            Built-in support for IMA and Microsoft ADPCM WAV files is provided on Linux/Android/Windows CE, while they are supported via ACM and CoreAudio codecs on Windows and OSX/iOS.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding channels (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device. The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is also unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.NoInternet">No internet connection could be opened. Can be caused by a bad proxy setting.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Url" /> is not a valid URL.</exception>
            <exception cref="F:ManagedBass.Errors.Timeout">The server did not respond to the request within the timeout period, as set with <see cref="P:ManagedBass.Bass.NetTimeOut"/> config option.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">The file could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The file's format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.Codec">The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified Speaker flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="F:ManagedBass.Bass.NoSoundDevice">
            <summary>
            Index of No Sound Device.
            </summary>
        </member>
        <member name="F:ManagedBass.Bass.DefaultDevice">
            <summary>
            Index of Default Device.
            </summary>
        </member>
        <member name="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)">
            <summary>
            Initializes an output device.
            </summary>
            <param name="Device">The device to use... -1 = default device, 0 = no sound, 1 = first real output device.
            <see cref="M:ManagedBass.Bass.GetDeviceInfo(System.Int32,ManagedBass.DeviceInfo@)" /> or <see cref="P:ManagedBass.Bass.DeviceCount" /> can be used to get the total number of devices.
            </param>
            <param name="Frequency">Output sample rate.</param>
            <param name="Flags">Any combination of <see cref="T:ManagedBass.DeviceInitFlags"/>.</param>
            <param name="Win">The application's main window... <see cref="F:System.IntPtr.Zero" /> = the desktop window (use this for console applications).</param>
            <param name="ClsID">Class identifier of the object to create, that will be used to initialize DirectSound... <see langword="null" /> = use default</param>
            <returns>If the device was successfully initialized, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Device">The device number specified is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Already">The device has already been initialized. You must call <see cref="M:ManagedBass.Bass.Free" /> before you can initialize it again.</exception>
            <exception cref="F:ManagedBass.Errors.Driver">There is no available device driver... the device may already be in use.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The specified format is not supported by the device. Try changing the <paramref name="Frequency" /> and <paramref name="Flags" /> parameters.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">The device has no 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
            <remarks>
            <para>This function must be successfully called before using any sample, stream or MOD music functions. The recording functions may be used without having called this function.</para>
            <para>Playback is not possible with the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device, but it does allow the use of "decoding channels", eg. to decode files.</para>
            <para>When specifying a class identifier (<paramref name="ClsID"/>), after successful initialization, you can use GetDSoundObject(DSInterface) to retrieve the DirectSound object, and through that access any special interfaces that the object may provide.</para>
            <para>
            Simultaneously using multiple devices is supported in the BASS API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions. <see cref="P:ManagedBass.Bass.CurrentDevice" /> is used to switch the current device.
            When successful, <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/> automatically sets the current thread's device to the one that was just initialized.
            </para>
            <para>
            When using the default device (device = -1), <see cref="P:ManagedBass.Bass.CurrentDevice" /> can be used to find out which device it was mapped to.
            On Windows, it'll always be the first device.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            On Linux, a 'Default' device is hardcoded to device number 1, which uses the default output set in the ALSA config; that could map directly to one of the other devices or it could use ALSA plugins.
            If the IncludeDefaultDevice config option has been enbled, a "Default" device is also available on Windows, who's output will follow default device changes on Windows 7.
            In both cases, the "Default" device will also be the default device (device = -1).
            </para>
            <para>
            The sample format specified in the <paramref name="Frequency" /> and <paramref name="Flags" /> parameters has no effect on the device output on iOS or OSX, and not on Windows unless VxD drivers are used (on Windows 98/95);
            with WDM drivers (on Windows XP/2000/Me/98SE), the output format is automatically set depending on the format of what is played and what the device supports, while on Vista and above, the output format is determined by the user's choice in the Sound control panel.
            On Linux the output device will use the specified format if possible, but will otherwise use a format as close to it as possible.
            If the <see cref="F:ManagedBass.DeviceInitFlags.Frequency"/> flag is specified on iOS or OSX, then the device's output rate will be set to the freq parameter (if possible).
            The <see cref="F:ManagedBass.DeviceInitFlags.Frequency"/> flag has no effect on other platforms.
            <see cref="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)" /> can be used to check what the output format actually is.
            </para>
            <para>
            The <paramref name="Win" /> and <paramref name="ClsID" /> parameters are only used on Windows and are ignored on other platforms.
            That applies to the <see cref="F:ManagedBass.DeviceInitFlags.CPSpeakers"/> and <see cref="F:ManagedBass.DeviceInitFlags.ForcedSpeakerAssignment"/> flags too, as the number of available speakers is always accurately detected on the other platforms.
            The <see cref="F:ManagedBass.DeviceInitFlags.Latency"/> flag is also ignored on Linux/OSX/Android/Windows CE, as latency information is available without it.
            The latency is also available without it on iOS, but not immediately following this function call unless the flag is used.
            </para>
            <para>
            The DeviceInitFlags.DMix flag is only available on Linux, and allows multiple applications to share the device (if they all use 'dmix').
            It may also be possible for multiple applications to use exclusive access if the device is capable of hardware mixing.
            If exclusive access initialization fails, the DeviceInitFlags.DMix flag will automatically be tried;
            if that happens, it can be detected via <see cref="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)" /> and the <see cref="P:ManagedBass.BassInfo.InitFlags"/>.
            </para>
            <para>On Linux and Windows CE, the length of the device's buffer can be set via the <see cref="P:ManagedBass.Bass.PlaybackBufferLength" /> config option.</para>
            </remarks>
            <seealso cref="M:ManagedBass.Bass.Free"/>
            <seealso cref="P:ManagedBass.Bass.CPUUsage"/>
            <seealso cref="M:ManagedBass.Bass.GetDeviceInfo(System.Int32,ManagedBass.DeviceInfo@)"/>
            <seealso cref="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)"/>
            <seealso cref="M:ManagedBass.Bass.MusicLoad(System.String,System.Int64,System.Int32,ManagedBass.BassFlags,System.Int32)"/>
            <seealso cref="M:ManagedBass.Bass.CreateSample(System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.BassFlags)"/>
            <seealso cref="M:ManagedBass.Bass.SampleLoad(System.String,System.Int64,System.Int32,System.Int32,ManagedBass.BassFlags)"/>
        </member>
        <member name="M:ManagedBass.Bass.Start">
            <summary>
            Starts (or resumes) the output.
            </summary>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/> has not been successfully called.</exception>
            <remarks>
            <para>The output is automatically started by <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/>, so there is no need to use this function unless you have stopped or paused the output.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice"/>) determines which device this function call applies to.</para>
            </remarks>
            <seealso cref="M:ManagedBass.Bass.Pause"/>
            <seealso cref="M:ManagedBass.Bass.Stop"/>
        </member>
        <member name="M:ManagedBass.Bass.Pause">
            <summary>
            Stops the output, pausing all musics/samples/streams.
            </summary>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>Use <see cref="M:ManagedBass.Bass.Start" /> to resume the output and paused channels.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
        </member>
        <member name="M:ManagedBass.Bass.Stop">
            <summary>
            Stops the output, stopping all musics/samples/streams.
            </summary>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>This function can be used after <see cref="M:ManagedBass.Bass.Pause" /> to stop the paused channels, so that they will not be resumed the next time <see cref="M:ManagedBass.Bass.Start" /> is called.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
        </member>
        <member name="M:ManagedBass.Bass.Free">
            <summary>
            Frees all resources used by the output device, including all it's samples, streams, and MOD musics.
            </summary>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>This function should be called for all initialized devices before your program exits. It's not necessary to individually free the samples/streams/musics as these are all automatically freed by this function.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelGetDevice(System.Int32)">
            <summary>
            Retrieves the device that the channel is using.
            </summary>
            <param name="Handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD. HSAMPLE handles may also be used.</param>
            <returns>If successful, the device number is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Recording devices are indicated by the HIWORD of the return value being 1, when this function is called with a HRECORD channel.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSetDevice(System.Int32,System.Int32)">
            <summary>
            Changes the device that a stream, MOD music or sample is using.
            </summary>
            <param name="Handle">The channel or sample handle... only HMUSIC, HSTREAM or HSAMPLE are supported.</param>
            <param name="Device">The device to use...0 = no sound, 1 = first real output device.</param>
            <returns>If succesful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            All of the channel's current settings are carried over to the new device, but if the channel is using the "with FX flag" DX8 effect implementation,
            the internal state (eg. buffers) of the DX8 effects will be reset. Using the "without FX flag" DX8 effect implementation, the state of the DX8 effects is preserved.
            <para>
            When changing a sample's device, all the sample's existing channels (HCHANNELs) are freed.
            It's not possible to change the device of an individual sample channel.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Device" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Init">The requested device has not been initialized.</exception>
            <exception cref="F:ManagedBass.Errors.Already">The channel is already using the requested device.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding channels are allowed to use the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">
            The sample format is not supported by the device/drivers.
            If the channel is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.
            </exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="P:ManagedBass.Bass.DeviceCount">
            <summary>
            Gets the number of Playback Devices available.
            </summary>
        </member>
        <member name="P:ManagedBass.Bass.Volume">
            <summary>
            Gets or sets the current output master volume level... 0 (silent) to 1 (max).
            </summary>
            <remarks>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice" />) determines which device this function call applies to.</para>
            <para>A return value of -1 indicates error. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. Throws <see cref="T:ManagedBass.BassException"/> on Error while setting value.</para>
            <para>The actual volume level may not be exactly the same as set, due to underlying precision differences.</para>
            <para>
            This function affects the volume level of all applications using the same output device.
            If you wish to only affect the level of your app's sounds, <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />
            and/or the <see cref="P:ManagedBass.Bass.GlobalMusicVolume"/>, <see cref="P:ManagedBass.Bass.GlobalSampleVolume"/> and <see cref="P:ManagedBass.Bass.GlobalStreamVolume"/> config options should be used instead.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">There is no volume control when using the <see cref="F:ManagedBass.Bass.NoSoundDevice">No Sound Device</see>.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">Invalid volume.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="P:ManagedBass.Bass.CurrentDevice">
            <summary>
            Gets or sets the device setting of the current thread... 0 = no sound, 1 = first real output device.
            </summary>
            <remarks>
            <para>A return value of -1 indicates error. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. Throws <see cref="T:ManagedBass.BassException"/> on Error while setting value.</para>
            <para>
            Simultaneously using multiple devices is supported in the BASS API via a context switching system -
            instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions.
            The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.
            </para>
            <para>The functions that use the device selection are the following:
            <see cref="M:ManagedBass.Bass.Free" />, GetDSoundObject(int), <see cref="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)" />, <see cref="M:ManagedBass.Bass.Start" />, <see cref="M:ManagedBass.Bass.Stop" />, <see cref="M:ManagedBass.Bass.Pause" />, <see cref="P:ManagedBass.Bass.Volume" />, <see cref="M:ManagedBass.Bass.Set3DFactors(System.Single,System.Single,System.Single)" />, <see cref="M:ManagedBass.Bass.Get3DFactors(System.Single@,System.Single@,System.Single@)" />, <see cref="M:ManagedBass.Bass.Set3DPosition(ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)" />, <see cref="M:ManagedBass.Bass.Get3DPosition(ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@,ManagedBass.Vector3D@)" />, SetEAXParameters, GetEAXParameters.
            It also determines which device is used by a new sample/stream/music: <see cref="M:ManagedBass.Bass.MusicLoad(System.String,System.Int64,System.Int32,ManagedBass.BassFlags,System.Int32)" />, <see cref="M:ManagedBass.Bass.SampleLoad(System.String,System.Int64,System.Int32,System.Int32,ManagedBass.BassFlags)" />, <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)" />, etc...
            </para>
            <para>
            When one of the above functions is called, BASS will check the current thread's device setting, and if no device is selected (or the selected device is not initialized), BASS will automatically select the lowest device that is initialized.
            This means that when using a single device, there is no need to use this function;
            BASS will automatically use the device that is initialized.
            Even if you free the device, and initialize another, BASS will automatically switch to the one that is initialized.
            </para>
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.GetDeviceInfo(System.Int32,ManagedBass.DeviceInfo@)">
            <summary>
            Retrieves information on an output device.
            </summary>
            <param name="Device">The device to get the information of... 0 = first.</param>
            <param name="Info">A <see cref="T:ManagedBass.DeviceInfo" /> object to retrieve the information into.</param>
            <returns>
            If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <remarks>
            This function can be used to enumerate the available devices for a setup dialog.
            Device 0 is always the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device, so if you should start at device 1 if you only want to list real devices.
            <para><b>Platform-specific</b></para>
            <para>
            On Linux, a "Default" device is hardcoded to device number 1, which uses the default output set in the ALSA config, and the real devices start at number 2.
            That is also the case on Windows when the IncludeDefaultDevice option is enabled.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Device">The device number specified is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.GetDeviceInfo(System.Int32)">
            <summary>
            Retrieves information on an output device.
            </summary>
            <param name="Device">The device to get the information of... 0 = first.</param>
            <returns>An instance of the <see cref="T:ManagedBass.DeviceInfo" /> structure is returned. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <remarks>
            This function can be used to enumerate the available devices for a setup dialog.
            Device 0 is always the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device, so if you should start at device 1 if you only want to list real devices.
            <para><b>Platform-specific</b></para>
            <para>
            On Linux, a "Default" device is hardcoded to device number 1, which uses the default output set in the ALSA config, and the real devices start at number 2.
            That is also the case on Windows when the IncludeDefaultDevice option is enabled.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Device">The device number specified is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)">
            <summary>
            Retrieves information on the device being used.
            </summary>
            <param name="Info"><see cref="T:ManagedBass.BassInfo"/> object to receive the information.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/> has not been successfully called.</exception>
            <remarks>
            When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice"/>) determines which device this function call applies to.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.Info">
            <summary>
            Retrieves information on the device being used.
            </summary>
            <returns><see cref="T:ManagedBass.BassInfo"/> structure with the retreived information. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/> has not been successfully called.</exception>
            <remarks>
            When using multiple devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentDevice"/>) determines which device this function call applies to.
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.FXSetParameters(System.Int32,System.IntPtr)">
            <summary>
            Sets the parameters of an effect
            </summary>
            <param name="Handle">The effect handle</param>
            <param name="Parameters">Pointer to the parameters structure. The structure used depends on the effect type.</param>
            <returns>
            If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">One or more of the parameters are invalid, make sure all the values are within the valid ranges.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
            <seealso cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)"/>
            <seealso cref="M:ManagedBass.Bass.FXGetParameters(System.Int32,System.IntPtr)"/>
        </member>
        <member name="M:ManagedBass.Bass.FXSetParameters(System.Int32,ManagedBass.IEffectParameter)">
            <summary>
            Sets the parameters of an effect
            </summary>
            <param name="Handle">The effect handle</param>
            <param name="Parameters">The parameters structure. The structure used depends on the effect type.</param>
            <returns>
            If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">One or more of the parameters are invalid, make sure all the values are within the valid ranges.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
            <seealso cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)"/>
            <seealso cref="M:ManagedBass.Bass.FXGetParameters(System.Int32,System.IntPtr)"/>
        </member>
        <member name="M:ManagedBass.Bass.FXGetParameters(System.Int32,System.IntPtr)">
            <summary>
            Retrieves the parameters of an effect
            </summary>
            <param name="Handle">The effect handle</param>
            <param name="Parameters">Pointer to the parameters structure to fill. The structure used depends on the effect type.</param>
            <returns>
            If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid.</exception>
            <seealso cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)"/>
            <seealso cref="M:ManagedBass.Bass.FXSetParameters(System.Int32,System.IntPtr)"/>
        </member>
        <member name="M:ManagedBass.Bass.FXGetParameters(System.Int32,ManagedBass.IEffectParameter)">
            <summary>
            Retrieves the parameters of an effect
            </summary>
            <param name="Handle">The effect handle</param>
            <param name="Parameters">The parameters structure to fill. The structure used depends on the effect type.</param>
            <returns>
            If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid.</exception>
            <seealso cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)"/>
            <seealso cref="M:ManagedBass.Bass.FXSetParameters(System.Int32,System.IntPtr)"/>
        </member>
        <member name="M:ManagedBass.Bass.FXReset(System.Int32)">
            <summary>
            Resets the state of an effect or all effects on a channel.
            </summary>
            <param name="Handle">The effect or channel handle... a HFX, HSTREAM, HMUSIC, or HRECORD.</param>
            <returns>
            If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
            <seealso cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)"/>
            <remarks>
            This function flushes the internal buffers of the effect(s).
            Effects are automatically reset by <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)"/>,
            except when called from a "<see cref="F:ManagedBass.SyncFlags.Mixtime"/>" <see cref="T:ManagedBass.SyncProcedure"/>.
            </remarks>
        </member>
        <member name="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)">
            <summary>
            Sets an effect on a stream, MOD music, or recording channel.
            </summary>
            <param name="Handle">The channel Handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="Type">Type of effect, one of <see cref="T:ManagedBass.EffectType" />.</param>
            <param name="Priority">
            The priority of the new FX, which determines it's position in the DSP chain.
            DSP/FX with higher priority are applied before those with lower.
            This parameter has no effect with DX8 effects when the "with FX flag" DX8 effect implementation is used.
            </param>
            <returns>
            If succesful, then the new effect's Handle is returned, else 0 is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid channel.</exception>
            <exception cref="F:ManagedBass.Errors.Type">An illegal <paramref name="Type" /> was specified.</exception>
            <exception cref="F:ManagedBass.Errors.NoFX">DX8 effects are unavailable.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">
            The channel's format is not supported by the effect.
            It may be floating-point (without DX9) or more than stereo.
            </exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
            <remarks>
            <para>
            Multiple effects may be used per channel. Use <see cref="M:ManagedBass.Bass.ChannelRemoveFX(System.Int32,System.Int32)" /> to remove an effect.
            Use <see cref="M:ManagedBass.Bass.FXSetParameters(System.Int32,System.IntPtr)" /> to set an effect's parameters.
            </para>
            <para>
            Effects can be applied to MOD musics and streams, but not samples.
            If you want to apply an effect to a sample, you could use a stream instead.
            </para>
            <para>
            Depending on the DX8 effect implementation being used by the channel, the channel may have to be stopped before adding or removing DX8 effects on it.
            If necessary, that is done automatically and the channel is resumed afterwards.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            DX8 effects are a Windows feature requiring DirectX 8, or DirectX 9 for floating-point support.
            On other platforms, they are emulated by BASS, except for the following which are currently unsupported: DXCompressor, DXGargle, and DX_I3DL2Reverb.
            On Windows CE, only PARAMEQ is supported.
            </para>
            </remarks>
            <seealso cref="M:ManagedBass.Bass.ChannelLock(System.Int32,System.Boolean)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelRemoveFX(System.Int32,System.Int32)"/>
            <seealso cref="M:ManagedBass.Bass.FXGetParameters(System.Int32,System.IntPtr)"/>
            <seealso cref="M:ManagedBass.Bass.FXSetParameters(System.Int32,System.IntPtr)"/>
            <seealso cref="M:ManagedBass.Bass.ChannelSetDSP(System.Int32,ManagedBass.DSPProcedure,System.IntPtr,System.Int32)"/>
        </member>
        <member name="M:ManagedBass.Bass.ChannelRemoveFX(System.Int32,System.Int32)">
            <summary>
            Removes an effect from a stream, MOD music, or recording channel.
            </summary>
            <param name="Handle">The channel Handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="FX">Handle of the effect to remove from the channel (return value of a previous <see cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)" /> call).</param>
            <returns>
            If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Handle">At least one of <paramref name="Handle" /> and <paramref name="FX" /> is not valid.</exception>
            <remarks>
            Depending on the DX8 effect implementation being used by the channel, the channel may have to be stopped before removing a DX8 effect on it.
            If necessary, that is done automatically and the channel is resumed afterwards.
            <para><see cref="M:ManagedBass.Bass.ChannelRemoveDSP(System.Int32,System.Int32)" /> can also be used to remove effects.</para>
            </remarks>
            <seealso cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)"/>
        </member>
        <member name="M:ManagedBass.Bass.FXSetPriority(System.Int32,System.Int32)">
            <summary>
            Sets the priority of an effect or DSP function, which determines its position in the DSP chain.
            </summary>
            <param name="Handle">The DSP/FX handle... a HDSP or HFX.</param>
            <param name="Priority">The new priority of the DSP/FX.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.</returns>
            <remarks>If there are multiple DSP/FX with the same priority value, they will be applied in the order in which they were given that priority.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Priority is not supported on DX8 effects when the "with FX flag" DX8 effect implementation is used.</exception>
        </member>
        <member name="M:ManagedBass.Bass.MusicFree(System.Int32)">
            <summary>
            Frees a MOD music's resources, including any sync/DSP/FX it has.
            </summary>
            <param name="Handle">The MOD music handle.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.MusicLoad(System.String,System.Int64,System.Int32,ManagedBass.BassFlags,System.Int32)">
            <summary>
            Loads a MOD music file - MO3 / IT / XM / S3M / MTM / MOD / UMX formats.
            </summary>
            <param name="File">The file name from where to load the music.</param>
            <param name="Offset">File offset to load the MOD music from.</param>
            <param name="Length">Data length... 0 = use all data up to the end of file. If length over-runs the end of the file, it'll automatically be lowered to the end of the file.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Frequency">Sample rate to render/play the MOD music at... 0 = the rate specified in the <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> call.</param>
            <returns>If successful, the loaded music's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>BASS uses the same code as XMPlay for it's MOD music support, giving the most accurate reproduction of MO3 / IT / XM / S3M / MTM / MOD / UMX files available from any sound system.</para>
            <para>
            MO3s are treated and used in exactly the same way as normal MOD musics.
            The advantage of MO3s is that they can be a lot smaller with virtually identical quality.
            Playing a MO3 does not use any more CPU power than playing the original MOD version does.
            The only difference is a slightly longer load time as the samples are being decoded.
            MO3 files are created using the MO3 encoder available at the BASS website.
            </para>
            <para>
            DMO effects (the same as available with <see cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)" />) can be used in IT and XM files (and MO3 versions of them) created with Modplug Tracker.
            This allows effects to be added to a track without having to resort to an MP3 or OGG version, so it can remain small and still sound fancy.
            Of course, the effects require some CPU, so should not be used carelessly if performance is key.
            DirectX 8 (or above) is required for the effects to be heard - without that, the music can still be played, but the effects are disabled.
            </para>
            <para>
            "Ramping" does not take a lot of extra processing and improves the sound quality by removing clicks, by ramping/smoothing volume and pan changes.
            The start of a sample may also be ramped-in.
            That is always the case with XM files (or MOD files in FT2 mode) when using normal ramping, and possibly with all formats when using sensitive ramping; senstitive ramping will only ramp-in when necessary to avoid a click.
            Generally, normal ramping is recommended for XM files, and sensitive ramping for the other formats, but some XM files may also sound better using sensitive ramping.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            DMO effects are not supported in MOD music on Windows CE, and DirectX 8 (or above) is required on Windows.
            They are always available on other platforms, except for the following: DXCompressor, DXGargle, and DX_I3DL2Reverb.
            When a DMO effect is unavailable, the MOD music can still be played, but the effect will be disabled.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">The <paramref name="File"/> could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The <paramref name="File"/>'s format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.MusicLoad(System.IntPtr,System.Int64,System.Int32,ManagedBass.BassFlags,System.Int32)">
            <summary>
            Loads a MOD music file - MO3 / IT / XM / S3M / MTM / MOD / UMX formats from memory.
            </summary>
            <param name="Memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="Offset">Memory offset to load the MOD music from.</param>
            <param name="Length">Data length.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Frequency">Sample rate to render/play the MOD music at... 0 = the rate specified in the <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> call.</param>
            <returns>If successful, the loaded music's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>BASS uses the same code as XMPlay for it's MOD music support, giving the most accurate reproduction of MO3 / IT / XM / S3M / MTM / MOD / UMX files available from any sound system.</para>
            <para>
            MO3s are treated and used in exactly the same way as normal MOD musics.
            The advantage of MO3s is that they can be a lot smaller with virtually identical quality.
            Playing a MO3 does not use any more CPU power than playing the original MOD version does.
            The only difference is a slightly longer load time as the samples are being decoded.
            MO3 files are created using the MO3 encoder available at the BASS website.
            </para>
            <para>
            DMO effects (the same as available with <see cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)" />) can be used in IT and XM files (and MO3 versions of them) created with Modplug Tracker.
            This allows effects to be added to a track without having to resort to an MP3 or OGG version, so it can remain small and still sound fancy.
            Of course, the effects require some CPU, so should not be used carelessly if performance is key.
            DirectX 8 (or above) is required for the effects to be heard - without that, the music can still be played, but the effects are disabled.
            </para>
            <para>
            "Ramping" does not take a lot of extra processing and improves the sound quality by removing clicks, by ramping/smoothing volume and pan changes.
            The start of a sample may also be ramped-in.
            That is always the case with XM files (or MOD files in FT2 mode) when using normal ramping, and possibly with all formats when using sensitive ramping; senstitive ramping will only ramp-in when necessary to avoid a click.
            Generally, normal ramping is recommended for XM files, and sensitive ramping for the other formats, but some XM files may also sound better using sensitive ramping.
            </para>
            <para>
            When loading a MOD music from memory, Bass does not use the memory after it has loaded the MOD music.
            So you can do whatever you want with the memory after calling this function.
            This means there is no need to pin the memory buffer for this method.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            DMO effects are not supported in MOD music on Windows CE, and DirectX 8 (or above) is required on Windows.
            They are always available on other platforms, except for the following: Compressor, Gargle, and I3DL2Reverb.
            When a DMO effect is unavailable, the MOD music can still be played, but the effect will be disabled.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen"><paramref name="Memory"/> could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat"><paramref name="Memory"/>'s format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.MusicLoad(System.Byte[],System.Int64,System.Int32,ManagedBass.BassFlags,System.Int32)">
            <summary>
            Loads a MOD music file - MO3 / IT / XM / S3M / MTM / MOD / UMX formats from memory.
            </summary>
            <param name="Memory">byte[] containing the music data.</param>
            <param name="Offset">Memory offset to load the MOD music from.</param>
            <param name="Length">Data length.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Frequency">Sample rate to render/play the MOD music at... 0 = the rate specified in the <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> call.</param>
            <returns>If successful, the loaded music's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>BASS uses the same code as XMPlay for it's MOD music support, giving the most accurate reproduction of MO3 / IT / XM / S3M / MTM / MOD / UMX files available from any sound system.</para>
            <para>
            MO3s are treated and used in exactly the same way as normal MOD musics.
            The advantage of MO3s is that they can be a lot smaller with virtually identical quality.
            Playing a MO3 does not use any more CPU power than playing the original MOD version does.
            The only difference is a slightly longer load time as the samples are being decoded.
            MO3 files are created using the MO3 encoder available at the BASS website.
            </para>
            <para>
            DMO effects (the same as available with <see cref="M:ManagedBass.Bass.ChannelSetFX(System.Int32,ManagedBass.EffectType,System.Int32)" />) can be used in IT and XM files (and MO3 versions of them) created with Modplug Tracker.
            This allows effects to be added to a track without having to resort to an MP3 or OGG version, so it can remain small and still sound fancy.
            Of course, the effects require some CPU, so should not be used carelessly if performance is key.
            DirectX 8 (or above) is required for the effects to be heard - without that, the music can still be played, but the effects are disabled.
            </para>
            <para>
            "Ramping" does not take a lot of extra processing and improves the sound quality by removing clicks, by ramping/smoothing volume and pan changes.
            The start of a sample may also be ramped-in.
            That is always the case with XM files (or MOD files in FT2 mode) when using normal ramping, and possibly with all formats when using sensitive ramping; senstitive ramping will only ramp-in when necessary to avoid a click.
            Generally, normal ramping is recommended for XM files, and sensitive ramping for the other formats, but some XM files may also sound better using sensitive ramping.
            </para>
            <para>
            When loading a MOD music from memory, Bass does not use the memory after it has loaded the MOD music.
            So you can do whatever you want with the memory after calling this function.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            DMO effects are not supported in MOD music on Windows CE, and DirectX 8 (or above) is required on Windows.
            They are always available on other platforms, except for the following: Compressor, Gargle, and I3DL2Reverb.
            When a DMO effect is unavailable, the MOD music can still be played, but the effect will be disabled.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen"><paramref name="Memory"/> could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat"><paramref name="Memory"/>'s format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.PluginGetInfo(System.Int32)">
            <summary>
            Retrieves information on a plugin.
            </summary>
            <param name="Handle">The plugin handle - or 0 to retrieve native BASS information.</param>
            <returns>An instance of <see cref="T:ManagedBass.PluginInfo" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The plugin information does not change, so the returned info remains valid for as long as the plugin is loaded.
            <para>Note: There is no guarantee that the check is complete or might contain formats not being supported on your particular OS/machine (due to additional or missing audio codecs).</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.PluginLoad(System.String)">
            <summary>
            Plugs on "add-on" into the standard stream and sample creation functions.
            </summary>
            <param name="FilePath">Filename of the add-on/plugin.</param>
            <returns>If successful, the loaded plugin's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            There are 2 ways in which add-ons can provide support for additional formats.
            They can provide dedicated functions to create streams of the specific format(s) they support and/or they can plug into the standard stream creation functions:
            <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)" />, <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" />,
            and <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" />.
            This function enables the latter method.
            Both methods can be used side by side.
            The obvious advantage of the plugin system is convenience, while the dedicated functions can provide extra options that are not possible via the shared function interfaces.
            See an add-on's documentation for more specific details on it.
            </para>
            <para>As well as the stream creation functions, plugins also add their additional format support to <see cref="M:ManagedBass.Bass.SampleLoad(System.String,System.Int64,System.Int32,System.Int32,ManagedBass.BassFlags)" />.</para>
            <para>Information on what file formats a plugin supports is available via the <see cref="M:ManagedBass.Bass.PluginGetInfo(System.Int32)" /> function.</para>
            <para>
            When using multiple plugins, the stream/sample creation functions will try each of them in the order that they were loaded via this function, until one that accepts the file is found.
            When an add-on is already loaded (eg. if you are using functions from it), the plugin system will use the same instance (the reference count will just be incremented); there will not be 2 copies of the add-on in memory.
            </para>
            <para>Note: Only stream/music add-ons are loaded (e.g. BassFx or BassMix are NOT loaded).</para>
            <para><b>Platform-specific:</b></para>
            <para>
            Dynamic libraries are not permitted on iOS, so add-ons are provided as static libraries instead, which means this function has to work a little differently.
            The add-on needs to be linked into the executable, and a "plugin" symbol declared and passed to this function (instead of a filename).
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.FileOpen">The <paramref name="FilePath" /> could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The <paramref name="FilePath" /> is not a plugin.</exception>
            <exception cref="F:ManagedBass.Errors.Already">The <paramref name="FilePath" /> is already plugged in.</exception>
        </member>
        <member name="M:ManagedBass.Bass.PluginFree(System.Int32)">
            <summary>
            Unplugs an add-on.
            </summary>
            <param name="Handle">The plugin handle... 0 = all plugins.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            If there are streams created by a plugin in existence when it is being freed, the streams will automatically be freed too.
            Samples loaded by the plugin are unaffected as the plugin has nothing to do with them once they are loaded (the sample data is already fully decoded).
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.RecordInit(System.Int32)">
            <summary>
            Initializes a recording device.
            </summary>
            <param name="Device">The device to use... -1 = default device, 0 = first. <see cref="M:ManagedBass.Bass.RecordGetDeviceInfo(System.Int32,ManagedBass.DeviceInfo@)" /> or <see cref="P:ManagedBass.Bass.RecordingDeviceCount" /> can be used to get the total number of devices.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.</returns>
            <remarks>
            This function must be successfully called before using the recording features.
            <para>
            Simultaneously using multiple devices is supported in the BASS API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions.
            <see cref="P:ManagedBass.Bass.CurrentRecordingDevice" /> is used to switch the current recording device.
            When successful, <see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> automatically sets the current thread's device to the one that was just initialized
            </para>
            <para>
            When using the default device (device = -1), <see cref="P:ManagedBass.Bass.CurrentRecordingDevice" /> can be used to find out which device it was mapped to.
            On Windows, it'll always be the first device.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            Recording support requires DirectX 5 (or above) on Windows.
            On Linux, a "Default" device is hardcoded to device number 0, which uses the default input set in the ALSA config;
            that could map directly to one of the other devices or it could use ALSA plugins.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.DirectX">A sufficient version of DirectX is not installed.</exception>
            <exception cref="F:ManagedBass.Errors.Device"><paramref name="Device" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.Already">The device has already been initialized. <see cref="M:ManagedBass.Bass.RecordFree" /> must be called before it can be initialized again.</exception>
            <exception cref="F:ManagedBass.Errors.Driver">There is no available device driver.</exception>
        </member>
        <member name="M:ManagedBass.Bass.RecordFree">
            <summary>
            Frees all resources used by the recording device.
            </summary>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>This function should be called for all initialized recording devices before your program exits.</para>
            <para>When using multiple recording devices, the current thread's device setting (as set with <see cref="P:ManagedBass.Bass.CurrentRecordingDevice" />) determines which device this function call applies to.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> has not been successfully called - there are no initialized devices.</exception>
        </member>
        <member name="M:ManagedBass.Bass.RecordStart(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.RecordProcedure,System.IntPtr)">
            <summary>
            Starts recording.
            </summary>
            <param name="Frequency">The sample rate to record at.</param>
            <param name="Channels">The number of channels... 1 = mono, 2 = stereo, etc.</param>
            <param name="Flags">Any combination of <see cref="F:ManagedBass.BassFlags.Byte"/>, <see cref="F:ManagedBass.BassFlags.Float"/> and <see cref="F:ManagedBass.BassFlags.RecordPause"/>.</param>
            <param name="Procedure">The user defined function to receive the recorded sample data... can be <see langword="null" /> if you do not wish to use a callback.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, the new recording's handle is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.</returns>
            <remarks>
            Use <see cref="M:ManagedBass.Bass.ChannelStop(System.Int32)" /> to stop the recording, and <see cref="M:ManagedBass.Bass.ChannelPause(System.Int32)" /> to pause it.
            Recording can also be started in a paused state (via the <see cref="F:ManagedBass.BassFlags.RecordPause"/> flag), allowing DSP/FX to be set on it before any data reaches the callback function.
            <para>The sample data will generally arrive from the recording device in blocks rather than in a continuous stream, so when specifying a very short period between callbacks, some calls may be skipped due to there being no new data available since the last call.</para>
            <para>
            When not using a callback (proc = <see langword="null" />), the recorded data is instead retrieved via <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" />.
            To keep latency at a minimum, the amount of data in the recording buffer should be monitored (also done via <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" />, with the <see cref="F:ManagedBass.DataFlags.Available"/> flag) to check that there is not too much data;
            freshly recorded data will only be retrieved after the older data in the buffer is.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            Multiple simultaneous recordings can be made from the same device on Windows XP and later, but generally not on older Windows.
            Multiple simultaneous recordings are possible on iOS and OSX, but may not always be on Linux or Windows CE.
            On OSX and iOS, the device is instructed (when possible) to deliver data at the period set in the HIWORD of flags, even when a callback function is not used.
            On other platforms, it is up the the system when data arrives from the device.
            </para>
            <para>
            Unlike Bass.Net, a reference to <paramref name="Procedure"/> doesn't need to be held by you manually.
            ManagedBass automatically holds a reference and frees it when the Channel is freed.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Busy">
            The device is busy.
            An existing recording must be stopped before starting another one.
            Multiple simultaneous recordings can be made from the same device on Windows XP and Vista, but generally not on older Windows.
            </exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">
            The recording device is not available.
            Another application may already be recording with it, or it could be a half-duplex device and is currently being used for playback.
            </exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">
            The specified format is not supported.
            If using the <see cref="F:ManagedBass.BassFlags.Float"/> flag, it could be that floating-point recording is not supported.
            </exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.RecordStart(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int32,ManagedBass.RecordProcedure,System.IntPtr)">
            <summary>
            Starts recording.
            </summary>
            <param name="Frequency">The sample rate to record at.</param>
            <param name="Channels">The number of channels... 1 = mono, 2 = stereo.</param>
            <param name="Flags">Any combination of <see cref="F:ManagedBass.BassFlags.Byte"/>, <see cref="F:ManagedBass.BassFlags.Float"/> and <see cref="F:ManagedBass.BassFlags.RecordPause"/>.</param>
            <param name="Period">
            Set the period (in milliseconds) between calls to the callback function (<see cref="T:ManagedBass.RecordProcedure" />).
            The minimum period is 5ms, the maximum the maximum is half the <see cref="P:ManagedBass.Bass.RecordingBufferLength"/> setting.
            If the period specified is outside this range, it is automatically capped. The default is 100ms.
            </param>
            <param name="Procedure">The user defined function to receive the recorded sample data... can be <see langword="null" /> if you do not wish to use a callback.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, the new recording's handle is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError"/> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Busy">
            The device is busy.
            An existing recording must be stopped before starting another one.
            Multiple simultaneous recordings can be made from the same device on Windows XP and Vista, but generally not on older Windows.
            </exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">
            The recording device is not available.
            Another application may already be recording with it, or it could be a half-duplex device and is currently being used for playback.
            </exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">
            The specified format is not supported.
            If using the <see cref="F:ManagedBass.BassFlags.Float"/> flag, it could be that floating-point recording is not supported.
            </exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="P:ManagedBass.Bass.CurrentRecordingDevice">
            <summary>
            Gets or Sets the recording device setting in the current thread... 0 = first recording device.
            </summary>
            <remarks>
            <para>A value of -1 indicates error. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.  Throws <see cref="T:ManagedBass.BassException"/> on Error while setting value.</para>
            <para>Simultaneously using multiple devices is supported in the BASS API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions. The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.</para>
            <para>The functions that use the recording device selection are the following:
            <see cref="M:ManagedBass.Bass.RecordFree" />, <see cref="M:ManagedBass.Bass.RecordGetInfo(ManagedBass.RecordInfo@)" />, <see cref="M:ManagedBass.Bass.RecordGetInput(System.Int32,System.Single@)" />, <see cref="M:ManagedBass.Bass.RecordGetInputName(System.Int32)" />, <see cref="M:ManagedBass.Bass.RecordSetInput(System.Int32,ManagedBass.InputFlags,System.Single)" />, <see cref="M:ManagedBass.Bass.RecordStart(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.RecordProcedure,System.IntPtr)" />.</para>
            <para>When one of the above functions is called, BASS will check the current thread's recording device setting, and if no device is selected (or the selected device is not initialized), BASS will automatically select the lowest device that is initialized.
            This means that when using a single device, there is no need to use this function - BASS will automatically use the device that's initialized.
            Even if you free the device, and initialize another, BASS will automatically switch to the one that is initialized.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> has not been successfully called - there are no initialized.</exception>
            <exception cref="F:ManagedBass.Errors.Device">Specified device number is invalid.</exception>
            <seealso cref="M:ManagedBass.Bass.RecordInit(System.Int32)"/>
        </member>
        <member name="M:ManagedBass.Bass.RecordGetDeviceInfo(System.Int32,ManagedBass.DeviceInfo@)">
            <summary>
            Retrieves information on a recording device.
            </summary>
            <param name="Device">The device to get the information of... 0 = first.</param>
            <param name="Info">A <see cref="T:ManagedBass.DeviceInfo" /> object to retreive the information into.</param>
            <returns>
            If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <remarks>
            This function can be used to enumerate the available recording devices for a setup dialog.
            <para><b>Platform-specific</b></para>
            <para>
            Recording support requires DirectX 5 (or above) on Windows.
            On Linux, a "Default" device is hardcoded to device number 0, which uses the default input set in the ALSA config.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Device">The device number specified is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.DirectX">A sufficient version of DirectX is not installed.</exception>
        </member>
        <member name="M:ManagedBass.Bass.RecordGetDeviceInfo(System.Int32)">
            <summary>
            Retrieves information on a recording device.
            </summary>
            <param name="Device">The device to get the information of... 0 = first.</param>
            <returns>An instance of the <see cref="T:ManagedBass.DeviceInfo" /> structure is returned.A value of -1 indicates error. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <remarks>
            <para><b>Platform-specific</b></para>
            <para>
            Recording support requires DirectX 5 (or above) on Windows.
            On Linux, a "Default" device is hardcoded to device number 0, which uses the default input set in the ALSA config.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Device">The device number specified is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.DirectX">A sufficient version of DirectX is not installed.</exception>
        </member>
        <member name="M:ManagedBass.Bass.RecordGetInfo(ManagedBass.RecordInfo@)">
            <summary>
            Retrieves information on the recording device being used.
            </summary>
            <param name="info">A <see cref="T:ManagedBass.RecordInfo" /> object to retrieve the information into.</param>
            <returns>
            If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> has not been successfully called - there are no initialized devices.</exception>
        </member>
        <member name="P:ManagedBass.Bass.RecordingInfo">
            <summary>
            Retrieves information on the recording device being used.
            </summary>
            <returns>An instance of the <see cref="T:ManagedBass.RecordInfo" /> structure is returned. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> has not been successfully called - there are no initialized devices.</exception>
        </member>
        <member name="P:ManagedBass.Bass.RecordingBufferLength">
            <summary>
            The Buffer Length for recording channels in milliseconds... 1000 (min) - 5000 (max). default = 2000.
            </summary>
            <remarks>
            If the Length specified is outside this range, it is automatically capped.
            Unlike a playback Buffer, where the aim is to keep the Buffer full, a recording
            Buffer is kept as empty as possible and so this setting has no effect on latency.
            Unless processing of the recorded data could cause significant delays, or you want to
            use a large recording period with <see cref="M:ManagedBass.Bass.RecordStart(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.RecordProcedure,System.IntPtr)"/>, there should be no need to increase this.
            Using this config option only affects the recording channels that are created afterwards,
            not any that have already been created.
            So you can have channels with differing Buffer lengths by using this config option each time before creating them.
            </remarks>
        </member>
        <member name="P:ManagedBass.Bass.RecordingDeviceCount">
            <summary>
            No of Recording devices available.
            </summary>
        </member>
        <member name="M:ManagedBass.Bass.RecordGetInput(System.Int32,System.Single@)">
            <summary>
            Retrieves the settings of a recording input source.
            </summary>
            <param name="Input">The input to get the settings of... 0 = first, -1 = master.</param>
            <param name="Volume">Reference to a variable to receive the current volume.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            If successful, then the settings are returned.
            The <see cref="F:ManagedBass.InputFlags.Off"/> flag will be set if the input is disabled, otherwise the input is enabled.
            The type of input (see <see cref="T:ManagedBass.InputTypeFlags" />) is also indicated in the high 8-bits.
            Use <see cref="F:ManagedBass.InputTypeFlags.InputTypeMask"/> to test the return value.
            If the volume is requested but not available, volume will receive -1.
            </returns>
            <remarks>
            <para><b>Platform-specific</b></para>
            <para>
            The input type information is only available on Windows.
            There is no "what you hear" type of input defined;
            if the device has one, it will typically come under <see cref="F:ManagedBass.InputTypeFlags.Analog"/> or <see cref="F:ManagedBass.InputTypeFlags.Undefined"/>.
            </para>
            <para>On OSX, there is no master input (-1), and only the currently enabled input has its volume setting available (if it has a volume control).</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> has not been successfully called - there are no initialized devices.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Input" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">A master input is not available.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.RecordGetInput(System.Int32)">
            <summary>
            Retrieves the settings of a recording input source (does not retrieve Volume).
            </summary>
            <param name="Input">The input to get the settings of... 0 = first, -1 = master.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            If successful, then the settings are returned.
            The <see cref="F:ManagedBass.InputFlags.Off"/> flag will be set if the input is disabled, otherwise the input is enabled.
            The type of input (see <see cref="T:ManagedBass.InputTypeFlags" />) is also indicated in the high 8-bits.
            Use <see cref="F:ManagedBass.InputTypeFlags.InputTypeMask"/> to test the return value.
            If the volume is requested but not available, volume will receive -1.
            </returns>
            <remarks>
            <para><b>Platform-specific</b></para>
            <para>
            The input type information is only available on Windows.
            There is no "what you hear" type of input defined;
            if the device has one, it will typically come under <see cref="F:ManagedBass.InputTypeFlags.Analog"/> or <see cref="F:ManagedBass.InputTypeFlags.Undefined"/>.
            </para>
            <para>On OSX, there is no master input (-1), and only the currently enabled input has its volume setting available (if it has a volume control).</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> has not been successfully called - there are no initialized devices.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Input" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">A master input is not available.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.RecordGetInputName(System.Int32)">
            <summary>
            Retrieves the text description of a recording input source.
            </summary>
            <param name="Input">The input to get the description of... 0 = first, -1 = master.</param>
            <returns>If succesful, then the description is returned, else <see langword="null" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para><b>Platform-specific</b></para>
            <para>
            The returned string is in ANSI or UTF-8 form on Windows, depending on the UnicodeDeviceInformation setting.
            It is in UTF-16 form ("WCHAR" rather than "char") on Windows CE, and in UTF-8 form on other platforms.
            </para>
            <para>On OSX, there is no master input (-1).</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> has not been successfully called - there are no initialized devices.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Input" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">A master input is not available.</exception>
        </member>
        <member name="M:ManagedBass.Bass.RecordSetInput(System.Int32,ManagedBass.InputFlags,System.Single)">
            <summary>
            Adjusts the settings of a recording input source.
            </summary>
            <param name="Input">The input to adjust the settings of... 0 = first, -1 = master.</param>
            <param name="Setting">The new setting... a combination of <see cref="T:ManagedBass.InputFlags"/>.</param>
            <param name="Volume">The volume level... 0 (silent) to 1 (max), less than 0 = leave current.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            The actual volume level may not be exactly the same as requested, due to underlying precision differences.
            <see cref="M:ManagedBass.Bass.RecordGetInput(System.Int32,System.Single@)" /> can be used to confirm what the volume is.
            </para>
            <para>The volume curve used by this function is always linear, the <see cref="P:ManagedBass.Bass.LogarithmicVolumeCurve"/> config option setting has no effect on this.</para>
            <para>Changes made by this function are system-wide, ie. other software using the device will be affected by it.</para>
            <para><b>Platform-specific</b></para>
            <para>On OSX, there is no master input (-1), and only the currently enabled input has its volume setting available (if it has a volume control).</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.RecordInit(System.Int32)" /> has not been successfully called - there are no initialized devices.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Input" /> or <paramref name="Volume" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The soundcard/driver doesn't allow you to change the input or it's volume.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleGetChannel(System.Int32,System.Boolean)">
            <summary>
            Creates/initializes a playback channel for a sample.
            </summary>
            <param name="Sample">Handle of the sample to play.</param>
            <param name="OnlyNew">Do not recycle/override one of the sample's existing channels?</param>
            <returns>If successful, the handle of the new channel is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Use <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" /> and <see cref="M:ManagedBass.Bass.SampleSetInfo(System.Int32,ManagedBass.SampleInfo)" /> to set a sample's default attributes, which are used when creating a channel.
            After creation, a channel's attributes can be changed via <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />, <see cref="M:ManagedBass.Bass.ChannelSet3DAttributes(System.Int32,ManagedBass.Mode3D,System.Single,System.Single,System.Int32,System.Int32,System.Single)" /> and <see cref="M:ManagedBass.Bass.ChannelSet3DPosition(System.Int32,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)" />.
            <see cref="M:ManagedBass.Bass.Apply3D" /> should be called before starting playback of a 3D sample, even if you just want to use the default settings.
            </para>
            <para>
            If a sample has a maximum number of simultaneous playbacks of 1 (the max parameter was 1 when calling <see cref="M:ManagedBass.Bass.SampleLoad(System.String,System.Int64,System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Bass.CreateSample(System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.BassFlags)" />), then the HCHANNEL handle returned will be identical to the HSAMPLE handle.
            That means you can use the HSAMPLE handle with functions that usually require a HCHANNEL handle, but you must still call this function first to initialize the channel.
            </para>
            <para>
            A sample channel is automatically freed when it's overridden by a new channel, or when stopped manually via <see cref="M:ManagedBass.Bass.ChannelStop(System.Int32)" />, <see cref="M:ManagedBass.Bass.SampleStop(System.Int32)" /> or <see cref="M:ManagedBass.Bass.Stop" />.
            If you wish to stop a channel and re-use it, it should be paused (<see cref="M:ManagedBass.Bass.ChannelPause(System.Int32)" />) instead of stopped.
            Determining whether a channel still exists can be done by trying to use the handle in a function call, eg. <see cref="M:ManagedBass.Bass.ChannelGetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single@)" />.
            </para>
            <para>When channel overriding has been enabled via an override flag and there are multiple candidates for overriding (eg. with identical volume), the oldest of them will be chosen to make way for the new channel.</para>
            <para>
            The new channel will have an initial state of being paused (<see cref="F:ManagedBass.PlaybackState.Paused"/>).
            This prevents the channel being claimed by another call of this function before it has been played, unless it gets overridden due to a lack of free channels.
            </para>
            <para>All of a sample's channels share the same sample data, and just have their own individual playback state information (volume/position/etc).</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Sample" /> is not a valid sample handle.</exception>
            <exception cref="F:ManagedBass.Errors.NoChannel">The sample has no free channels... the maximum number of simultaneous playbacks has been reached, and no override flag was specified for the sample or onlynew = <see langword="true" />.</exception>
            <exception cref="F:ManagedBass.Errors.Timeout">The sample's minimum time gap (<see cref="T:ManagedBass.SampleInfo" />) has not yet passed since the last channel was created.</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleFree(System.Int32)">
            <summary>
            Frees a sample's resources.
            </summary>
            <param name="Handle">The sample handle.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleSetData(System.Int32,System.IntPtr)">
            <summary>
            Sets a sample's data.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Buffer">Pointer to the data to set.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The required length and format of the data can be retrieved via <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" />.
            <para>A sample's data can be set at any time, including during playback.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleSetData(System.Int32,System.Byte[])">
            <summary>
            Sets a sample's data.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Buffer">byte[] containing the data to set.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The required length and format of the data can be retrieved via <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" />.
            <para>A sample's data can be set at any time, including during playback.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleSetData(System.Int32,System.Int32[])">
            <summary>
            Sets a sample's data.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Buffer">int[] containing the data to set.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The required length and format of the data can be retrieved via <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" />.
            <para>A sample's data can be set at any time, including during playback.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleSetData(System.Int32,System.Int16[])">
            <summary>
            Sets a sample's data.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Buffer">short[] containing the data to set.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The required length and format of the data can be retrieved via <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" />.
            <para>A sample's data can be set at any time, including during playback.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleSetData(System.Int32,System.Single[])">
            <summary>
            Sets a sample's data.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Buffer">float[] containing the data to set.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The required length and format of the data can be retrieved via <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" />.
            <para>A sample's data can be set at any time, including during playback.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.CreateSample(System.Int32,System.Int32,System.Int32,System.Int32,ManagedBass.BassFlags)">
            <summary>
            Initiates the creation of a user generated sample.
            </summary>
            <param name="Length">The sample's length, in bytes.</param>
            <param name="Frequency">The default sample rate.</param>
            <param name="Channels">The number of channels... 1 = mono, 2 = stereo, etc... More than stereo requires WDM drivers in Windows.</param>
            <param name="Max">Maximum number of simultaneous playbacks... 1 (min) - 65535 (max)... use one of the override flags to choose the override decider, in the case of there being no free channel available for playback (ie. the sample is already playing max times).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, the new sample's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            The sample's initial content is undefined.
            <see cref="M:ManagedBass.Bass.SampleSetData(System.Int32,System.IntPtr)" /> should be used to set the sample's data.
            </para>
            <para>
            Unless the BassFlags.SoftwareMixing flag is used, the sample will use hardware mixing if hardware resources are available.
            Use <see cref="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)" /> to see if there are hardware mixing resources available, and which sample formats are supported by the hardware.
            The <see cref="F:ManagedBass.BassFlags.VAM"/> flag allows a sample to be played by both hardware and software, with the decision made when the sample is played rather than when it's loaded.
            A sample's VAM options are set via <see cref="M:ManagedBass.Bass.SampleSetInfo(System.Int32,ManagedBass.SampleInfo)" />.
            </para>
            <para>To play a sample, first a channel must be obtained using <see cref="M:ManagedBass.Bass.SampleGetChannel(System.Int32,System.Boolean)" />, which can then be played using <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" />.</para>
            <para>If you want to play a large or one-off sample, then it would probably be better to stream it instead with <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedure,System.IntPtr)" />.</para>
            <para><b>Platform-specific</b></para>
            <para>
            The <see cref="F:ManagedBass.BassFlags.VAM"/> flag requires DirectX 7 (or above).
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Sample functions are not available when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Max" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the sample is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleGetData(System.Int32,System.IntPtr)">
            <summary>
            Retrieves a copy of a sample's data.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Buffer">Pointer to a buffer to receive the data.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The buffer must be big enough to receive the sample's data, the size of which can be retrieved via <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" />.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleGetData(System.Int32,System.Byte[])">
            <summary>
            Retrieves a copy of a sample's data.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Buffer">byte[] to receive the data.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The buffer must be big enough to receive the sample's data, the size of which can be retrieved via <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" />.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleGetData(System.Int32,System.Int16[])">
            <summary>
            Retrieves a copy of a sample's data.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Buffer">short[] to receive the data.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The buffer must be big enough to receive the sample's data, the size of which can be retrieved via <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" />.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleGetData(System.Int32,System.Int32[])">
            <summary>
            Retrieves a copy of a sample's data.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Buffer">int[] to receive the data.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The buffer must be big enough to receive the sample's data, the size of which can be retrieved via <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" />.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleGetData(System.Int32,System.Single[])">
            <summary>
            Retrieves a copy of a sample's data.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Buffer">float[] to receive the data.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The buffer must be big enough to receive the sample's data, the size of which can be retrieved via <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" />.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)">
            <summary>
            Retrieves a sample's default attributes and other information.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Info">An instance of the <see cref="T:ManagedBass.SampleInfo" /> class to store the sample information at.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleGetInfo(System.Int32)">
            <summary>
            Retrieves a sample's default attributes and other information.
            </summary>
            <param name="Handle">The sample handle.</param>
            <returns>An instance of the <see cref="T:ManagedBass.SampleInfo" /> class is returned. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleSetInfo(System.Int32,ManagedBass.SampleInfo)">
            <summary>
            Sets a sample's default attributes.
            </summary>
            <param name="Handle">The sample handle.</param>
            <param name="Info">An instance of the <see cref="T:ManagedBass.SampleInfo" /> class containing the sample information to set.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Use this function and <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" /> to edit a sample's default attributes.
            Changing a sample's default attributes does not affect any existing channels, it only affects channels subsequently created via <see cref="M:ManagedBass.Bass.SampleGetChannel(System.Int32,System.Boolean)" />.
            The exception is the VAM settings, changes to that apply to all the sample's channels at their next playback (<see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" />).
            Use <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" /> and <see cref="M:ManagedBass.Bass.ChannelSet3DAttributes(System.Int32,ManagedBass.Mode3D,System.Single,System.Single,System.Int32,System.Int32,System.Single)" /> to change the attributes of an existing sample channel.
            </para>
            <para>
            The sample's maximum number of simultaneous playbacks can be changed via the <see cref="F:ManagedBass.SampleInfo.Max"/> member.
            If the new maximum is lower than the existing number of channels, the channels will remain existing until they are stopped.
            </para>
            <para>
            <see cref="F:ManagedBass.SampleInfo.Length"/>, <see cref="F:ManagedBass.SampleInfo.OriginalResolution"/> and <see cref="F:ManagedBass.SampleInfo.Channels"/> can't be modified - any changes are ignored.
            <see cref="F:ManagedBass.BassFlags.Byte"/>, <see cref="F:ManagedBass.BassFlags.Mono"/>, <see cref="F:ManagedBass.BassFlags.Bass3D"/>, <see cref="F:ManagedBass.BassFlags.MuteMax"/>, BassFlags.SoftwareMixing and <see cref="F:ManagedBass.BassFlags.VAM"/> also cannot be changed.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleGetChannels(System.Int32)">
            <summary>
            Retrieves an array of a sample's existing channels.
            </summary>
            <param name="Handle">Handle of the sample.</param>
            <returns>
            If successful, the array of existing channels is returned (which might have zero elements), else <see langword="null" /> is returned.
            Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            </returns>
            <remarks>
            This overload only returns the existing channels in the array.
            <para>If you need to determine whether a particular sample channel still exists, it is simplest to just try it in a function call.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid sample handle.</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleStop(System.Int32)">
            <summary>
            Stops all instances of a sample.
            </summary>
            <param name="Handle">The sample handle.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not a valid sample handle.</exception>
            <remarks>If a sample is playing simultaneously multiple times, calling this function will stop them all, which is obviously simpler than calling <see cref="M:ManagedBass.Bass.ChannelStop(System.Int32)" /> multiple times.</remarks>
        </member>
        <member name="M:ManagedBass.Bass.SampleLoad(System.String,System.Int64,System.Int32,System.Int32,ManagedBass.BassFlags)">
            <summary>
            Loads a WAV, AIFF, MP3, MP2, MP1, OGG or plugin supported sample.
            </summary>
            <param name="File">The file name to load the sample from.</param>
            <param name="Offset">File offset to load the sample from.</param>
            <param name="Length">Data length... 0 = use all data up to the end of file. If length over-runs the end of the file, it'll automatically be lowered to the end of the file.</param>
            <param name="MaxNoOfPlaybacks">Maximum number of simultaneous playbacks... 1 (min) - 65535 (max)... use one of the BASS_SAMPLE_OVER flags to choose the override decider, in the case of there being no free channel available for playback (ie. the sample is already playing max times).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, the loaded sample's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>Additional format support is available via the plugin system (see <see cref="M:ManagedBass.Bass.PluginLoad(System.String)" />).</para>
            <para>
            Unless the BassFlags.SoftwareMixing flag is used, the sample will use hardware mixing if hardware resources are available.
            Use <see cref="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)" /> to see if there are hardware mixing resources available, and which sample formats are supported by the hardware.
            The <see cref="F:ManagedBass.BassFlags.VAM"/> flag allows a sample to be played by both hardware and software, with the decision made when the sample is played rather than when it's loaded.
            A sample's VAM options are set via <see cref="M:ManagedBass.Bass.SampleSetInfo(System.Int32,ManagedBass.SampleInfo)" />.
            </para>
            <para>To play a sample, first a channel must be obtained using <see cref="M:ManagedBass.Bass.SampleGetChannel(System.Int32,System.Boolean)" />, which can then be played using <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" />.</para>
            <para>If you want to play a large or one-off sample, then it would probably be better to stream it instead with <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)" />.</para>
            <para><b>Platform-specific</b></para>
            <para>
            The <see cref="F:ManagedBass.BassFlags.VAM"/> flag requires DirectX 7 (or above).
            </para>
            <para>
            On Windows and Windows CE, ACM codecs are supported with compressed WAV files.
            On iOS and OSX, CoreAudio codecs are supported, adding support for any file formats that have a codec installed.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Sample functions are not available when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="MaxNoOfPlaybacks" /> and/or <paramref name="Length" /> is invalid.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">The <paramref name="File" /> could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The <paramref name="File" />'s format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.Codec">The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the sample is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleLoad(System.IntPtr,System.Int64,System.Int32,System.Int32,ManagedBass.BassFlags)">
            <summary>
            Loads a WAV, AIFF, MP3, MP2, MP1, OGG or plugin supported sample.
            <para>This overload uses an unmanaged IntPtr and implements loading a sample from memory.</para>
            </summary>
            <param name="Memory">An unmanaged IntPtr to the allocated memory block at which the sample data resides.</param>
            <param name="Offset">File offset to load the sample from.</param>
            <param name="Length">Data length. Should be set to the length of the data contained in memory.</param>
            <param name="MaxNoOfPlaybacks">Maximum number of simultaneous playbacks... 1 (min) - 65535 (max)... use one of the override flags to choose the override decider, in the case of there being no free channel available for playback (ie. the sample is already playing max times).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/> flags.</param>
            <returns>If successful, the loaded sample's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>Additional format support is available via the plugin system (see <see cref="M:ManagedBass.Bass.PluginLoad(System.String)" />).</para>
            <para>
            Unless the BassFlags.SoftwareMixing flag is used, the sample will use hardware mixing if hardware resources are available.
            Use <see cref="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)" /> to see if there are hardware mixing resources available, and which sample formats are supported by the hardware.
            The <see cref="F:ManagedBass.BassFlags.VAM"/> flag allows a sample to be played by both hardware and software, with the decision made when the sample is played rather than when it's loaded.
            A sample's VAM options are set via <see cref="M:ManagedBass.Bass.SampleSetInfo(System.Int32,ManagedBass.SampleInfo)" />.
            </para>
            <para>To play a sample, first a channel must be obtained using <see cref="M:ManagedBass.Bass.SampleGetChannel(System.Int32,System.Boolean)" />, which can then be played using <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" />.</para>
            <para>If you want to play a large or one-off sample, then it would probably be better to stream it instead with <see cref="M:ManagedBass.Bass.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags)" />.</para>
            <para>There is no need to pin the memory buffer for this method, since after loading a sample from memory, the memory can safely be discarded, as a copy is made.</para>
            <para><b>Platform-specific</b></para>
            <para>
            The <see cref="F:ManagedBass.BassFlags.VAM"/> flag requires DirectX 7 (or above).
            </para>
            <para>
            On Windows and Windows CE, ACM codecs are supported with compressed WAV files.
            On iOS and OSX, CoreAudio codecs are supported, adding support for any file formats that have a codec installed.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Sample functions are not available when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="MaxNoOfPlaybacks" /> and/or <paramref name="Length" /> is invalid. Specifying <paramref name="Length" /> is mandatory when loading from memory.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">The <paramref name="Memory" /> could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The <paramref name="Memory" />'s format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.Codec">The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the sample is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.SampleLoad(System.Byte[],System.Int64,System.Int32,System.Int32,ManagedBass.BassFlags)">
            <summary>
            Loads a WAV, AIFF, MP3, MP2, MP1, OGG or plugin supported sample.
            <para>This overload uses an unmanaged IntPtr and implements loading a sample from memory.</para>
            </summary>
            <param name="Memory">A byte[] with the sample data to load.</param>
            <param name="Offset">File offset to load the sample from.</param>
            <param name="Length">Data length. Should be set to the length of the data contained in memory.</param>
            <param name="MaxNoOfPlaybacks">Maximum number of simultaneous playbacks... 1 (min) - 65535 (max)... use one of the override flags to choose the override decider, in the case of there being no free channel available for playback (ie. the sample is already playing max times).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/> flags.</param>
            <returns>If successful, the loaded sample's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>Additional format support is available via the plugin system (see <see cref="M:ManagedBass.Bass.PluginLoad(System.String)" />).</para>
            <para>
            Unless the BassFlags.SoftwareMixing flag is used, the sample will use hardware mixing if hardware resources are available.
            Use <see cref="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)" /> to see if there are hardware mixing resources available, and which sample formats are supported by the hardware.
            The <see cref="F:ManagedBass.BassFlags.VAM"/> flag allows a sample to be played by both hardware and software, with the decision made when the sample is played rather than when it's loaded.
            A sample's VAM options are set via <see cref="M:ManagedBass.Bass.SampleSetInfo(System.Int32,ManagedBass.SampleInfo)" />.
            </para>
            <para>To play a sample, first a channel must be obtained using <see cref="M:ManagedBass.Bass.SampleGetChannel(System.Int32,System.Boolean)" />, which can then be played using <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" />.</para>
            <para>If you want to play a large or one-off sample, then it would probably be better to stream it instead with <see cref="M:ManagedBass.Bass.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags)" />.</para>
            <para>The <paramref name="Memory"/> can be safely discarded after calling this method, as a copy of it is made by Bass.</para>
            <para><b>Platform-specific</b></para>
            <para>
            The <see cref="F:ManagedBass.BassFlags.VAM"/> flag requires DirectX 7 (or above).
            </para>
            <para>
            On Windows and Windows CE, ACM codecs are supported with compressed WAV files.
            On iOS and OSX, CoreAudio codecs are supported, adding support for any file formats that have a codec installed.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Sample functions are not available when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="MaxNoOfPlaybacks" /> and/or <paramref name="Length" /> is invalid. Specifying <paramref name="Length" /> is mandatory when loading from memory.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">The <paramref name="Memory" /> could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The <paramref name="Memory" />'s format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.Codec">The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the sample is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)">
            <summary>
            Retrieves the decoding/download/end position of a file stream.
            </summary>
            <param name="Handle">The stream's handle.</param>
            <param name="Mode">The file position to retrieve. One of <see cref="T:ManagedBass.FileStreamPosition" /> values.</param>
            <returns>If succesful, then the requested file position is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>ID3 tags (both v1 and v2) and WAVE headers, as well as any other rubbish at the start of the file, are excluded from the calculations of this function.</para>
            <para>This is useful for average bitrate calculations, but it means that the <see cref="F:ManagedBass.FileStreamPosition.Current"/> position may not be the actual file position - the <see cref="F:ManagedBass.FileStreamPosition.Start"/> position can be added to it to get the actual file position.</para>
            <para>
            When streaming a file from the internet or a "buffered" user file stream, the entire file is downloaded even if the audio data ends before that, in case there are tags to be read.
            This means that the <see cref="F:ManagedBass.FileStreamPosition.Download"/> position may go beyond the <see cref="F:ManagedBass.FileStreamPosition.End"/> position.
            </para>
            <para>
            It's unwise to use this function (with mode = <see cref="F:ManagedBass.FileStreamPosition.Current"/>) for syncing purposes because it returns the position that's being decoded, not the position that's being heard.
            Use <see cref="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)" /> for syncing instead.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotFile">The stream is not a file stream.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The requested file position/status is not available.</exception>
        </member>
        <member name="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedure,System.IntPtr)">
            <summary>
            Creates a user sample stream.
            </summary>
            <param name="Frequency">The default sample rate. The sample rate can be changed using <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />.</param>
            <param name="Channels">The number of channels... 1 = mono, 2 = stereo, 4 = quadraphonic, 6 = 5.1, 8 = 7.1. More than stereo requires WDM drivers, and the Speaker flags are ignored.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Procedure">The user defined stream writing function (see <see cref="T:ManagedBass.StreamProcedure" />).</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Sample streams allow any sample data to be played through Bass, and are particularly useful for playing a large amount of sample data without requiring a large amount of memory.
            If you wish to play a sample format that BASS does not support, then you can create a stream and decode the sample data into it.
            </para>
            <para>
            Bass can automatically stream MP3, MP2, MP1, OGG, WAV and AIFF files, using <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags)" />, and also from HTTP and FTP servers,
            using <see cref="M:ManagedBass.Bass.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr)" />, <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> allows streaming from other sources too.
            </para>
            <para>However, the callback method must deliver PCM sample data as specified, so opening an MP3 file and just passing that file data will not work here.</para>
            <para>
            Unlike Bass.Net, a reference to <paramref name="Procedure"/> doesn't need to be held by you manually.
            ManagedBass automatically holds a reference and frees it when the Channel is freed.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding channels (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device. The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is also unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified Speaker flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedureType)">
            <summary>
            Creates a Dummy or Push stream.
            </summary>
            <param name="Frequency">The default sample rate. The sample rate can be changed using <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />.</param>
            <param name="Channels">The number of channels... 1 = mono, 2 = stereo, 4 = quadraphonic, 6 = 5.1, 8 = 7.1. More than stereo requires WDM drivers, and the SPEAKER flags are ignored.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="ProcedureType">The type of stream.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            A dummy stream doesn't have any sample data of its own, but a decoding dummy stream (with <see cref="F:ManagedBass.BassFlags.Decode"/> flag) can be used to apply DSP/FX processing to any sample data,
            by setting DSP/FX on the stream and feeding the data through <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" />.
            <para>The dummy stream should have the same sample format as the data being fed through it.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding channels (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device. The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is also unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified Speaker flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamPutData(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Adds sample data to a "push" stream.
            </summary>
            <param name="Handle">The stream handle (as created with <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedureType)" />).</param>
            <param name="Buffer">Pointer to the sample data (<see cref="F:System.IntPtr.Zero"/> = allocate space in the queue buffer so that there is at least length bytes of free space).</param>
            <param name="Length">The amount of data in bytes, optionally using the <see cref="F:ManagedBass.StreamProcedureType.End"/> flag to signify the end of the stream. 0 can be used to just check how much data is queued.</param>
            <returns>If successful, the amount of queued data is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            As much data as possible will be placed in the stream's playback buffer, and any remainder will be queued for when more space becomes available, ie. as the buffered data is played.
            With a decoding channel, there is no playback buffer, so all data is queued in that case.
            There is no limit to the amount of data that can be queued, besides available memory.
            The queue buffer will be automatically enlarged as required to hold the data, but it can also be enlarged in advance.
            The queue buffer is freed when the stream ends or is reset, eg. via <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" /> (with restart = <see langword="true"/>) or <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> (with Position = 0).
            </para>
            <para>DSP/FX are applied when the data reaches the playback buffer, or the <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> call in the case of a decoding channel.</para>
            <para>
            Data should be provided at a rate sufficent to sustain playback.
            If the buffer gets exhausted, Bass will automatically stall playback of the stream, until more data is provided.
            <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> (<see cref="F:ManagedBass.DataFlags.Available"/>) can be used to check the buffer level, and <see cref="M:ManagedBass.Bass.ChannelIsActive(System.Int32)" /> can be used to check if playback has stalled.
            A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can also be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is not using the push system.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Length" /> is not valid, it must equate to a whole number of samples.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The stream has ended.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamPutData(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Adds sample data to a "push" stream.
            </summary>
            <param name="Handle">The stream handle (as created with <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedureType)" />).</param>
            <param name="Buffer">byte sample data buffer (<see langword="null"/> = allocate space in the queue buffer so that there is at least length bytes of free space).</param>
            <param name="Length">The amount of data in bytes, optionally using the <see cref="F:ManagedBass.StreamProcedureType.End"/> flag to signify the end of the stream. 0 can be used to just check how much data is queued.</param>
            <returns>If successful, the amount of queued data is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            As much data as possible will be placed in the stream's playback buffer, and any remainder will be queued for when more space becomes available, ie. as the buffered data is played.
            With a decoding channel, there is no playback buffer, so all data is queued in that case.
            There is no limit to the amount of data that can be queued, besides available memory.
            The queue buffer will be automatically enlarged as required to hold the data, but it can also be enlarged in advance.
            The queue buffer is freed when the stream ends or is reset, eg. via <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" /> (with restart = <see langword="true"/>) or <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> (with Position = 0).
            </para>
            <para>DSP/FX are applied when the data reaches the playback buffer, or the <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> call in the case of a decoding channel.</para>
            <para>
            Data should be provided at a rate sufficent to sustain playback.
            If the buffer gets exhausted, Bass will automatically stall playback of the stream, until more data is provided.
            <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> (<see cref="F:ManagedBass.DataFlags.Available"/>) can be used to check the buffer level, and <see cref="M:ManagedBass.Bass.ChannelIsActive(System.Int32)" /> can be used to check if playback has stalled.
            A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can also be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is not using the push system.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Length" /> is not valid, it must equate to a whole number of samples.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The stream has ended.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamPutData(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Adds sample data to a "push" stream.
            </summary>
            <param name="Handle">The stream handle (as created with <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedureType)" />).</param>
            <param name="Buffer">short sample data buffer (<see langword="null"/> = allocate space in the queue buffer so that there is at least length bytes of free space).</param>
            <param name="Length">The amount of data in bytes, optionally using the <see cref="F:ManagedBass.StreamProcedureType.End"/> flag to signify the end of the stream. 0 can be used to just check how much data is queued.</param>
            <returns>If successful, the amount of queued data is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            As much data as possible will be placed in the stream's playback buffer, and any remainder will be queued for when more space becomes available, ie. as the buffered data is played.
            With a decoding channel, there is no playback buffer, so all data is queued in that case.
            There is no limit to the amount of data that can be queued, besides available memory.
            The queue buffer will be automatically enlarged as required to hold the data, but it can also be enlarged in advance.
            The queue buffer is freed when the stream ends or is reset, eg. via <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" /> (with restart = <see langword="true"/>) or <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> (with Position = 0).
            </para>
            <para>DSP/FX are applied when the data reaches the playback buffer, or the <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> call in the case of a decoding channel.</para>
            <para>
            Data should be provided at a rate sufficent to sustain playback.
            If the buffer gets exhausted, Bass will automatically stall playback of the stream, until more data is provided.
            <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> (<see cref="F:ManagedBass.DataFlags.Available"/>) can be used to check the buffer level, and <see cref="M:ManagedBass.Bass.ChannelIsActive(System.Int32)" /> can be used to check if playback has stalled.
            A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can also be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is not using the push system.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Length" /> is not valid, it must equate to a whole number of samples.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The stream has ended.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamPutData(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Adds sample data to a "push" stream.
            </summary>
            <param name="Handle">The stream handle (as created with <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedureType)" />).</param>
            <param name="Buffer">int sample data buffer (<see langword="null"/> = allocate space in the queue buffer so that there is at least length bytes of free space).</param>
            <param name="Length">The amount of data in bytes, optionally using the <see cref="F:ManagedBass.StreamProcedureType.End"/> flag to signify the end of the stream. 0 can be used to just check how much data is queued.</param>
            <returns>If successful, the amount of queued data is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            As much data as possible will be placed in the stream's playback buffer, and any remainder will be queued for when more space becomes available, ie. as the buffered data is played.
            With a decoding channel, there is no playback buffer, so all data is queued in that case.
            There is no limit to the amount of data that can be queued, besides available memory.
            The queue buffer will be automatically enlarged as required to hold the data, but it can also be enlarged in advance.
            The queue buffer is freed when the stream ends or is reset, eg. via <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" /> (with restart = <see langword="true"/>) or <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> (with Position = 0).
            </para>
            <para>DSP/FX are applied when the data reaches the playback buffer, or the <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> call in the case of a decoding channel.</para>
            <para>
            Data should be provided at a rate sufficent to sustain playback.
            If the buffer gets exhausted, Bass will automatically stall playback of the stream, until more data is provided.
            <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> (<see cref="F:ManagedBass.DataFlags.Available"/>) can be used to check the buffer level, and <see cref="M:ManagedBass.Bass.ChannelIsActive(System.Int32)" /> can be used to check if playback has stalled.
            A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can also be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is not using the push system.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Length" /> is not valid, it must equate to a whole number of samples.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The stream has ended.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamPutData(System.Int32,System.Single[],System.Int32)">
            <summary>
            Adds sample data to a "push" stream.
            </summary>
            <param name="Handle">The stream handle (as created with <see cref="M:ManagedBass.Bass.CreateStream(System.Int32,System.Int32,ManagedBass.BassFlags,ManagedBass.StreamProcedureType)" />).</param>
            <param name="Buffer">float sample data buffer (<see langword="null"/> = allocate space in the queue buffer so that there is at least length bytes of free space).</param>
            <param name="Length">The amount of data in bytes, optionally using the <see cref="F:ManagedBass.StreamProcedureType.End"/> flag to signify the end of the stream. 0 can be used to just check how much data is queued.</param>
            <returns>If successful, the amount of queued data is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            As much data as possible will be placed in the stream's playback buffer, and any remainder will be queued for when more space becomes available, ie. as the buffered data is played.
            With a decoding channel, there is no playback buffer, so all data is queued in that case.
            There is no limit to the amount of data that can be queued, besides available memory.
            The queue buffer will be automatically enlarged as required to hold the data, but it can also be enlarged in advance.
            The queue buffer is freed when the stream ends or is reset, eg. via <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" /> (with restart = <see langword="true"/>) or <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> (with Position = 0).
            </para>
            <para>DSP/FX are applied when the data reaches the playback buffer, or the <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> call in the case of a decoding channel.</para>
            <para>
            Data should be provided at a rate sufficent to sustain playback.
            If the buffer gets exhausted, Bass will automatically stall playback of the stream, until more data is provided.
            <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> (<see cref="F:ManagedBass.DataFlags.Available"/>) can be used to check the buffer level, and <see cref="M:ManagedBass.Bass.ChannelIsActive(System.Int32)" /> can be used to check if playback has stalled.
            A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can also be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is not using the push system.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Length" /> is not valid, it must equate to a whole number of samples.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The stream has ended.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamPutFileData(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Adds data to a "push buffered" user file stream's buffer.
            </summary>
            <param name="Handle">The stream handle (as created with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> and the <see cref="F:ManagedBass.StreamSystem.BufferPush"/> system flag.).</param>
            <param name="Buffer">Pointer to the file data.</param>
            <param name="Length">The amount of data in bytes, or <see cref="F:ManagedBass.StreamProcedureType.End"/> to end the file.</param>
            <returns>If successful, the number of bytes read from buffer is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>If there is not enough space in the stream's file buffer to receive all of the data, then only the amount that will fit is read from buffer. <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" /> can be used to check the amount of space in the buffer.</para>
            <para>
            File data should be provided at a rate sufficent to sustain playback.
            If there is insufficient file data, and the playback buffer is subsequently exhausted, Bass will automatically stall playback of the stream, until more data is available.
            A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is not using the <see cref="F:ManagedBass.StreamSystem.BufferPush"/> file system.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The stream has ended.</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamPutFileData(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Adds data to a "push buffered" user file stream's buffer.
            </summary>
            <param name="Handle">The stream handle (as created with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> and the <see cref="F:ManagedBass.StreamSystem.BufferPush"/> system flag.).</param>
            <param name="Buffer">byte buffer.</param>
            <param name="Length">The amount of data in bytes, or <see cref="F:ManagedBass.StreamProcedureType.End"/> to end the file.</param>
            <returns>If successful, the number of bytes read from buffer is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>If there is not enough space in the stream's file buffer to receive all of the data, then only the amount that will fit is read from buffer. <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" /> can be used to check the amount of space in the buffer.</para>
            <para>
            File data should be provided at a rate sufficent to sustain playback.
            If there is insufficient file data, and the playback buffer is subsequently exhausted, Bass will automatically stall playback of the stream, until more data is available.
            A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is not using the <see cref="F:ManagedBass.StreamSystem.BufferPush"/> file system.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The stream has ended.</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamPutFileData(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Adds data to a "push buffered" user file stream's buffer.
            </summary>
            <param name="Handle">The stream handle (as created with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> and the <see cref="F:ManagedBass.StreamSystem.BufferPush"/> system flag.).</param>
            <param name="Buffer">short buffer.</param>
            <param name="Length">The amount of data in bytes, or <see cref="F:ManagedBass.StreamProcedureType.End"/> to end the file.</param>
            <returns>If successful, the number of bytes read from buffer is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>If there is not enough space in the stream's file buffer to receive all of the data, then only the amount that will fit is read from buffer. <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" /> can be used to check the amount of space in the buffer.</para>
            <para>
            File data should be provided at a rate sufficent to sustain playback.
            If there is insufficient file data, and the playback buffer is subsequently exhausted, Bass will automatically stall playback of the stream, until more data is available.
            A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is not using the <see cref="F:ManagedBass.StreamSystem.BufferPush"/> file system.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The stream has ended.</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamPutFileData(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Adds data to a "push buffered" user file stream's buffer.
            </summary>
            <param name="Handle">The stream handle (as created with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> and the <see cref="F:ManagedBass.StreamSystem.BufferPush"/> system flag.).</param>
            <param name="Buffer">int buffer.</param>
            <param name="Length">The amount of data in bytes, or <see cref="F:ManagedBass.StreamProcedureType.End"/> to end the file.</param>
            <returns>If successful, the number of bytes read from buffer is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>If there is not enough space in the stream's file buffer to receive all of the data, then only the amount that will fit is read from buffer. <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" /> can be used to check the amount of space in the buffer.</para>
            <para>
            File data should be provided at a rate sufficent to sustain playback.
            If there is insufficient file data, and the playback buffer is subsequently exhausted, Bass will automatically stall playback of the stream, until more data is available.
            A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is not using the <see cref="F:ManagedBass.StreamSystem.BufferPush"/> file system.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The stream has ended.</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamPutFileData(System.Int32,System.Single[],System.Int32)">
            <summary>
            Adds data to a "push buffered" user file stream's buffer.
            </summary>
            <param name="Handle">The stream handle (as created with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" /> and the <see cref="F:ManagedBass.StreamSystem.BufferPush"/> system flag.).</param>
            <param name="Buffer">float buffer.</param>
            <param name="Length">The amount of data in bytes, or <see cref="F:ManagedBass.StreamProcedureType.End"/> to end the file.</param>
            <returns>If successful, the number of bytes read from buffer is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>If there is not enough space in the stream's file buffer to receive all of the data, then only the amount that will fit is read from buffer. <see cref="M:ManagedBass.Bass.StreamGetFilePosition(System.Int32,ManagedBass.FileStreamPosition)" /> can be used to check the amount of space in the buffer.</para>
            <para>
            File data should be provided at a rate sufficent to sustain playback.
            If there is insufficient file data, and the playback buffer is subsequently exhausted, Bass will automatically stall playback of the stream, until more data is available.
            A <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync can be set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, to be triggered upon playback stalling or resuming.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is not using the <see cref="F:ManagedBass.StreamSystem.BufferPush"/> file system.</exception>
            <exception cref="F:ManagedBass.Errors.Ended">The stream has ended.</exception>
        </member>
        <member name="M:ManagedBass.Bass.StreamFree(System.Int32)">
            <summary>
            Frees a sample stream's resources, including any SYNC/DSP/FX it has.
            </summary>
            <param name="Handle"> The stream handle.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Init"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="T:ManagedBass.BassInfo">
            <summary>
            Used with <see cref="M:ManagedBass.Bass.GetInfo(ManagedBass.BassInfo@)" /> to retrieve information on the current device.
            </summary>
            <remarks>
            The DSCAPS_SECONDARY flags only indicate which sample formats are supported by hardware mixing.
            <para><b>Platform-specific</b></para>
            <para>
            On Windows, it is possible for speakers to mistakenly be 2 with some devices/drivers when the device in fact supports more speakers.
            In that case, the <see cref="F:ManagedBass.DeviceInitFlags.CPSpeakers"/> flag can be used (with <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/>) to use the Windows control panel setting,
            or the <see cref="F:ManagedBass.DeviceInitFlags.ForcedSpeakerAssignment"/> flag can be used to force the enabling of speaker assignment to up to 8 speakers,
            even though the device may not really support that many speakers.
            The result of assigning channels to nonexistent speakers is undefined;
            they may be heard on other speakers or not heard at all.
            </para>
            <para>
            The flags, hwsize, hwfree, freesam, free3d, minrate, maxrate, eax, and dsver members are only used on Windows, as DirectSound and hardware mixing are only available there.
            The freq member is not available on Windows prior to Vista.
            </para>
            <para>On Windows, the availability of the latency and minbuf values depends on the <see cref="F:ManagedBass.DeviceInitFlags.Latency"/> flag being used when <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> was called.</para>
            </remarks>
        </member>
        <member name="P:ManagedBass.BassInfo.TotalHardwareMemory">
            <summary>
            The device's total amount of hardware memory.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.FreeHardwareMemory">
            <summary>
            The device's amount of free hardware memory.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.FreeSampleSlots">
            <summary>
            The number of free sample slots in the hardware.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.Free3DSampleSlots">
            <summary>
            The number of free 3D sample slots in the hardware.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.MinSampleRate">
            <summary>
            The minimum sample rate supported by the hardware.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.MaxSampleRate">
            <summary>
            The maximum sample rate supported by the hardware.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.EAXEnabled">
            <summary>The device supports EAX and has it enabled?
            <para>The device's "Hardware acceleration" needs to be set to "Full" in it's "Advanced Properties" setup, else EAX is disabled.</para>
            <para>This is always <see langword="false" /> if <see cref="F:ManagedBass.DeviceInitFlags.Device3D"/> was not used when <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> was called.</para>
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.MinBufferLength">
            <summary>The minimum Buffer Length (rounded up to the nearest millisecond) recommended for use with the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> config option.
            <para>Requires that <see cref="F:ManagedBass.DeviceInitFlags.Latency"/> was used when <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> was called.</para>
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.DSVersion">
            <summary>
            DirectSound version.
            <para>
            9 = DX9/8/7/5 features are available,
            8 = DX8/7/5 features are available,
            7 = DX7/5 features are available,
            5 = DX5 features are available.
            0 = none of the DX9/8/7/5 features are available.
            </para>
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.Latency">
            <summary>The delay (rounded up to the nearest millisecond) for playback of HSTREAM/HMUSIC channels to start and be heard.
            <para>Requires that <see cref="F:ManagedBass.DeviceInitFlags.Latency"/> was used when <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> was called.</para>
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.InitFlags">
            <summary>
            The flags parameter of the <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> call (<see cref="T:ManagedBass.DeviceInitFlags" />).
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.SpeakerCount">
            <summary>The number of speakers the device/drivers supports... 2 means that there is no support for speaker assignment - this will always be the case with non-WDM drivers in Windows.
            <para>It's also possible that it could mistakenly be 2 with some devices/drivers, when the device in fact supports more speakers.</para>
            <para>In that case the <see cref="F:ManagedBass.DeviceInitFlags.ForcedSpeakerAssignment"/> or <see cref="F:ManagedBass.DeviceInitFlags.CPSpeakers"/> flag can be used in the <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> call to force the enabling of speaker assignment.</para>
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.SampleRate">
            <summary>
            The device's current output sample rate. This is only available on Windows Vista and OSX.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.IsCertified">
            <summary>
            The device driver has been certified by Microsoft. Always true for WDM drivers.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.Supports16BitSamples">
            <summary>
            16-bit samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.Supports8BitSamples">
            <summary>
            8-bit samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.SupportsContinuousRate">
            <summary>
            The device supports all sample rates between minrate and maxrate.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.SupportsDirectSound">
            <summary>
            The device's drivers has DirectSound support
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.SupportsMonoSamples">
            <summary>
            Mono samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="P:ManagedBass.BassInfo.SupportsStereoSamples">
            <summary>
            Stereo samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="T:ManagedBass.ChannelInfo">
            <summary>
            Used with <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" /> to retrieve information on a channel.
            </summary>
            <remarks>
            A "channel" can be a playing sample (HCHANNEL), a sample stream (HSTREAM), a MOD music (HMUSIC), or a recording (HRECORD).
            <para>Each "Channel" function can be used with one or more of these channel types.</para>
            <para>
            The BassFlags.SoftwareMixing flag indicates whether or not the channel's sample data is being mixed into the final output by the hardware.
            It does not indicate (in the case of a stream or MOD music) whether the processing required to generate the sample data is being done by the hardware, this processing is always done in software.
            </para>
            <para>
            BASS supports 8/16/32-bit sample data, so if a WAV file, for example, uses another sample resolution, it'll have to be converted by BASS.
            The <see cref="P:ManagedBass.ChannelInfo.OriginalResolution"/> member can be used to check what the resolution originally was.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.ChannelInfo.Frequency">
            <summary>
            Default playback rate.
            </summary>
        </member>
        <member name="P:ManagedBass.ChannelInfo.Channels">
            <summary>
            Number of channels... 1=mono, 2=stereo, etc.
            </summary>
        </member>
        <member name="P:ManagedBass.ChannelInfo.Flags">
            <summary>
            Sample/Stream/Music/Speaker flags.
            A combination of <see cref="T:ManagedBass.BassFlags"/>.
            </summary>
            <remarks><b>Platform-specific</b>
            <para>
            On Linux/iOS/OSX, the <see cref="F:ManagedBass.BassFlags.Unicode"/> flag may not be present even if it was used in the stream's creation, as BASS will have translated the filename to the native UTF-8 form.
            On Windows CE, the opposite is true: the <see cref="F:ManagedBass.BassFlags.Unicode"/> flag may be present even if it was not used in the stream's creation, as BASS will have translated the filename to the native UTF-16 form.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.ChannelInfo.ChannelType">
            <summary>
            The Type of Channel
            </summary>
        </member>
        <member name="P:ManagedBass.ChannelInfo.Plugin">
            <summary>
            The plugin that is handling the channel... 0 = not using a plugin.
            <para>
            Note this is only available with streams created using the plugin system via the standard BASS stream creation functions, not those created by add-on functions.
            Information on the plugin can be retrieved via <see cref="M:ManagedBass.Bass.PluginGetInfo(System.Int32)" />.
            </para>
            </summary>
        </member>
        <member name="P:ManagedBass.ChannelInfo.Sample">
            <summary>
            The sample that is playing on the channel. (HCHANNEL only)
            </summary>
        </member>
        <member name="P:ManagedBass.ChannelInfo.Resolution">
            <summary>
            The resolution which Bass uses for the stream.
            </summary>
        </member>
        <member name="P:ManagedBass.ChannelInfo.OriginalResolution">
            <summary>
            The original resolution (bits per sample)... 0 = undefined.
            </summary>
        </member>
        <member name="P:ManagedBass.ChannelInfo.FileName">
            <summary>
            The filename associated with the channel. (HSTREAM only)
            </summary>
        </member>
        <member name="P:ManagedBass.ChannelInfo.IsDecodingChannel">
            <summary>
            Is the channel a decoding channel?
            </summary>
        </member>
        <member name="T:ManagedBass.DeviceInfo">
            <summary>
            Used with <see cref="M:ManagedBass.Bass.GetDeviceInfo(System.Int32,ManagedBass.DeviceInfo@)" /> or <see cref="M:ManagedBass.Bass.RecordGetDeviceInfo(System.Int32,ManagedBass.DeviceInfo@)" /> to retrieve information on a device.
            </summary>
            <remarks>
            <para>
            When a device is disabled/disconnected, it is still retained in the device list, but the IsEnabled is set to <see langword="false" /> flag is removed from it.
            If the device is subsequently re-enabled, it may become available again with the same device number, or the system may add a new entry for it.
            </para>
            <para>
            When a new device is connected, it can affect the other devices and result in the system moving them to new device entries.
            If an affected device is initialized, it will stop working and will need to be reinitialized using its new device number.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            On Windows, <see cref="P:ManagedBass.DeviceInfo.Driver"/> can reveal the Type of driver being used on systems that support both VxD and WDM drivers (Windows Me/98SE).
            Further information can be obtained from the file via the GetFileVersionInfo function.
            On Vista and newer, the device's endpoint ID is given rather than its driver filename.
            On OSX, driver is the device's UID, and on Linux it is the ALSA device name.
            It is unused on other platforms.
            The device Type is only available on Windows (Vista and newer) and OSX.
            On Windows, DisplayPort devices will have <see cref="F:ManagedBass.DeviceType.HDMI"/> rather than <see cref="F:ManagedBass.DeviceType.DisplayPort"/>.
            </para>
            <para>
            Depending on the Bass.UnicodeDeviceInformation config setting, <see cref="P:ManagedBass.DeviceInfo.Name"/> and <see cref="P:ManagedBass.DeviceInfo.Driver"/> can be in ANSI or UTF-8 form on Windows.
            They are always in UTF-16 form on Windows CE, and UTF-8 on other platforms.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.DeviceInfo.Name">
            <summary>
            The description of the device.
            </summary>
        </member>
        <member name="P:ManagedBass.DeviceInfo.Driver">
            <summary>
            The filename of the driver being used... <see langword="null" /> = no driver (ie. <see cref="F:ManagedBass.Bass.NoSoundDevice"/> device).
            <para>On systems that can use both VxD and WDM drivers (Windows Me/98SE), this will reveal which Type of driver is being used.</para>
            <para>Further information can be obtained from the file using the GetFileVersionInfo Win32 API function.</para>
            </summary>
        </member>
        <member name="P:ManagedBass.DeviceInfo.IsDefault">
            <summary>
            The device is the system default device.
            </summary>
        </member>
        <member name="P:ManagedBass.DeviceInfo.IsEnabled">
            <summary>
            The device is enabled and can be used.
            </summary>
        </member>
        <member name="P:ManagedBass.DeviceInfo.IsInitialized">
            <summary>
            The device is already initialized.
            </summary>
        </member>
        <member name="P:ManagedBass.DeviceInfo.Type">
            <summary>
            The device's Type.
            </summary>
        </member>
        <member name="T:ManagedBass.FileProcedures">
            <summary>
            Table of callback functions used with <see cref="M:ManagedBass.Bass.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr)" />.
            </summary>
            <remarks>
            A copy is made of the <see cref="T:ManagedBass.FileProcedures"/> callback function table, so it does not have to persist beyond this function call.
            Unlike Bass.Net, a reference to <see cref="T:ManagedBass.FileProcedures"/> doesn't need to be held by you manually.
            ManagedBass automatically holds a reference and frees it when the Channel is freed.
            </remarks>
        </member>
        <member name="F:ManagedBass.FileProcedures.Close">
            <summary>
            Callback function to close the file.
            </summary>
        </member>
        <member name="F:ManagedBass.FileProcedures.Length">
            <summary>
            Callback function to get the file Length.
            </summary>
        </member>
        <member name="F:ManagedBass.FileProcedures.Read">
            <summary>
            Callback function to read from the file.
            </summary>
        </member>
        <member name="F:ManagedBass.FileProcedures.Seek">
            <summary>
            Callback function to seek in the file. Not used by buffered file streams.
            </summary>
        </member>
        <member name="T:ManagedBass.PluginFormat">
            <summary>
            Used with <see cref="M:ManagedBass.Bass.PluginGetInfo(System.Int32)" /> to retrieve information on the supported plugin formats.
            </summary>
            <remarks>
            The plugin information does not change, so the returned pointer remains valid for as long as the plugin is loaded.
            <para>
            The extension filter is for information only.
            A plugin will check the file contents rather than file extension, to verify that it is a supported format.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.PluginFormat.ChannelType">
            <summary>
            The channel Type, as would appear in the <see cref="T:ManagedBass.ChannelInfo" /> structure.
            </summary>
        </member>
        <member name="P:ManagedBass.PluginFormat.Name">
            <summary>
            The Format description or name.
            </summary>
        </member>
        <member name="P:ManagedBass.PluginFormat.FileExtensions">
            <summary>
            File extension filter, in the form of "*.ext1;*.ext2;etc...".
            </summary>
            <remarks>
            The extension filter is for information only.
            A plugin will check the file contents rather than file extension, to verify that it is a supported format.
            </remarks>
        </member>
        <member name="T:ManagedBass.PluginInfo">
            <summary>
            Used with <see cref="M:ManagedBass.Bass.PluginGetInfo(System.Int32)" /> to retrieve information on a plugin.
            </summary>
        </member>
        <member name="P:ManagedBass.PluginInfo.Version">
            <summary>
            Plugin version.
            </summary>
        </member>
        <member name="P:ManagedBass.PluginInfo.Formats">
            <summary>
            The collection of supported formats.
            </summary>
            <remarks>
            Note: There is no guarantee that the list of supported formats is complete or might contain formats not being supported on your particular OS/machine (due to additional or missing audio codecs).
            </remarks>
        </member>
        <member name="T:ManagedBass.RecordInfo">
            <summary>
            Used with <see cref="M:ManagedBass.Bass.RecordGetInfo(ManagedBass.RecordInfo@)" /> to retrieve information on the current recording device.
            </summary>
            <remarks>
            <para>The <see cref="P:ManagedBass.RecordInfo.SupportedFormats"/> member does not represent all the formats supported by the device, just the "standard" ones.</para>
            <para>If there is no DirectSound driver for the device (ie. it's being emulated), then the driver member will contain something like "WaveIn" instead of a filename.</para>
            <para><b>Platform-specific</b></para>
            <para>
            The <see cref="P:ManagedBass.RecordInfo.IsCertified"/> and <see cref="P:ManagedBass.RecordInfo.SupportsDirectSound"/> members are only used on Windows.
            The <see cref="P:ManagedBass.RecordInfo.SupportedFormats"/> member is only used on Windows/OSX/iOS, and only for the device's channel count in the case of OSX and iOS.
            On Windows, it does not necessarily represent all of the formats supported by the device, just the "standard" ones.
            <see cref="P:ManagedBass.RecordInfo.Frequency"/> is also only available on Windows/OSX/iOS, but not on Windows prior to Vista.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.RecordInfo.SupportedFormats">
            <summary>
            The standard wave formats supported by the device (default is <see cref="F:ManagedBass.RecordFormatFlags.WF4S16"/>).
            </summary>
        </member>
        <member name="P:ManagedBass.RecordInfo.Inputs">
            <summary>
            The number of Input sources available to the device
            </summary>
        </member>
        <member name="P:ManagedBass.RecordInfo.SingleInput">
            <summary>
            <see langword="true" /> = only one Input may be active at a time
            </summary>
        </member>
        <member name="P:ManagedBass.RecordInfo.Frequency">
            <summary>
            The device's current Input sample rate. This is only available on Windows Vista and OSX.
            </summary>
        </member>
        <member name="P:ManagedBass.RecordInfo.Channels">
            <summary>
            Gets the available channel count for a recording Input.
            </summary>
        </member>
        <member name="P:ManagedBass.RecordInfo.IsCertified">
            <summary>
            The device driver has been certified by Microsoft. Always true for WDM drivers.
            </summary>
        </member>
        <member name="P:ManagedBass.RecordInfo.SupportsDirectSound">
            <summary>
            The device's drivers has DirectSound support
            </summary>
        </member>
        <member name="T:ManagedBass.SampleInfo">
            <summary>
            Used with <see cref="M:ManagedBass.Bass.SampleGetInfo(System.Int32,ManagedBass.SampleInfo@)" /> and <see cref="M:ManagedBass.Bass.SampleSetInfo(System.Int32,ManagedBass.SampleInfo)" /> to retrieve and set the default playback attributes of a sample.
            </summary>
            <remarks>
            <para>
            When a sample has 3D functionality, the <see cref="F:ManagedBass.SampleInfo.InsideAngle"/> and <see cref="F:ManagedBass.SampleInfo.OutsideAngle"/> angles decide how wide the sound is projected around the orientation angle (as set via <see cref="M:ManagedBass.Bass.ChannelSet3DPosition(System.Int32,ManagedBass.Vector3D,ManagedBass.Vector3D,ManagedBass.Vector3D)" />).
            Within the inside angle the volume level is the level set in the volume member (or the <see cref="F:ManagedBass.ChannelAttribute.Volume" /> attribute when the sample is playing).
            Outside the outer angle, the volume changes according to the outvol value.
            Between the inner and outer angles, the volume gradually changes between the inner and outer volume levels.
            If the inner and outer angles are 360 degrees, then the sound is transmitted equally in all directions.
            </para>
            <para>When VAM is enabled, and neither the <see cref="F:ManagedBass.VAMMode.Hardware"/> or <see cref="F:ManagedBass.VAMMode.Software"/> flags are specified, then the sample will be played in hardware if resources are available, and in software if no hardware resources are available.</para>
            </remarks>
        </member>
        <member name="F:ManagedBass.SampleInfo.Frequency">
            <summary>
            Default playback rate (set to 44100 by default).
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.Volume">
            <summary>
            Default volume... 0 (silent) to 1 (full, default).
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.Pan">
            <summary>
            Default panning position -1 (full left) to +1 (full right) - defaulted to 0 = centre.
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.Flags">
            <summary>
            A combination of <see cref="T:ManagedBass.BassFlags"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.Length">
            <summary>
            The Length in bytes.
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.Max">
            <summary>
            Maximum number of simultaneous playbacks (defaulted to 1).
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.OriginalResolution">
            <summary>
            The original resolution (bits per sample)... 0 = undefined (default).
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.Channels">
            <summary>
            Number of channels... 1=mono, 2=stereo (default), etc.
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.MinGap">
            <summary>
            Minimum time gap in milliseconds between creating channels using <see cref="M:ManagedBass.Bass.SampleGetChannel(System.Int32,System.Boolean)" />.
            This can be used to prevent flanging effects caused by playing a sample multiple times very close to eachother.
            The default setting, when loading/creating a sample, is 0 (disabled).
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.Mode3D">
            <summary>
            The 3D processing mode...
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.MinDistance">
            <summary>
            The minimum distance (default 0). The sample's volume is at maximum when the listener is within this distance.
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.MaxDistance">
            <summary>
            The maximum distance (default 0). The sample's volume stops decreasing when the listener is beyond this distance.
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.InsideAngle">
            <summary>
            The angle of the inside projection cone in degrees... 0 (no cone, default) - 360 (sphere).
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.OutsideAngle">
            <summary>
            The angle of the outside projection cone in degrees... 0 (no cone, default) - 360 (sphere).
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.OutsideVolume">
            <summary>
            The delta-volume outside the outer projection cone... 0 (silent) to 1 (full, default) - same as inside the cone.
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.VAM">
            <summary>
            The sample's DX7 voice allocation/management settings (if VAM is enabled)...a combination of <see cref="T:ManagedBass.VAMMode" /> flags.
            </summary>
        </member>
        <member name="F:ManagedBass.SampleInfo.Priority">
            <summary>
            Priority, used with the <see cref="F:ManagedBass.VAMMode.TerminatePriority"/> flag... 0 (min, default) - 0xFFFFFFFF (max)
            </summary>
        </member>
        <member name="T:ManagedBass.Vector3D">
            <summary>
            Structure used by the 3D functions to describe positions, velocities, and orientations in the left-handed coordinate system.
            </summary>
        </member>
        <member name="F:ManagedBass.Vector3D.X">
            <summary>
            +values=right, -values=left (default=0)
            </summary>
        </member>
        <member name="F:ManagedBass.Vector3D.Y">
            <summary>
            +values=up, -values=down (default=0)
            </summary>
        </member>
        <member name="F:ManagedBass.Vector3D.Z">
            <summary>
            +values=front, -values=behind (default=0)
            </summary>
        </member>
        <member name="M:ManagedBass.Vector3D.#ctor">
            <summary>
            Creates a new instance of <see cref="T:ManagedBass.Vector3D"/>.
            </summary>
        </member>
        <member name="M:ManagedBass.Vector3D.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Creates a new instance of Vector3D and initialises members.
            </summary>
        </member>
        <member name="M:ManagedBass.Vector3D.ToString">
            <summary>
            Returns a string representation of this Vector.
            </summary>
        </member>
        <member name="T:ManagedBass.BitHelper">
            <summary>
            Helps perform certain operations on primative types that deal with bits
            </summary>
        </member>
        <member name="M:ManagedBass.BitHelper.HiDword(System.Int64)">
            <summary>
            The return value is the high-order double word of the specified value.
            </summary>
        </member>
        <member name="M:ManagedBass.BitHelper.LoDword(System.Int64)">
            <summary>
            The return value is the low-order word of the specified value.
            </summary>
        </member>
        <member name="M:ManagedBass.BitHelper.HiWord(System.Int32)">
            <summary>
            The return value is the high-order word of the specified value.
            </summary>
        </member>
        <member name="M:ManagedBass.BitHelper.LoWord(System.Int32)">
            <summary>
            The return value is the low-order word of the specified value.
            </summary>
        </member>
        <member name="M:ManagedBass.BitHelper.HiByte(System.Int16)">
            <summary>
            The return value is the high-order byte of the specified value.
            </summary>
        </member>
        <member name="M:ManagedBass.BitHelper.LoByte(System.Int16)">
            <summary>
            The return value is the low-order byte of the specified value.
            </summary>
        </member>
        <member name="M:ManagedBass.BitHelper.MakeWord(System.Byte,System.Byte)">
            <summary>
            Make an short from 2-bytes.
            </summary>
        </member>
        <member name="M:ManagedBass.BitHelper.MakeLong(System.Int16,System.Int16)">
            <summary>
            Make an integer putting <paramref name="low"/> in low 2-bytes and <paramref name="high"/> in high 2-bytes.
            </summary>
        </member>
        <member name="T:ManagedBass.DirectX8.DXChorusParameters">
            <summary>
            Parameters for DX8 Chorus Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXChorusParameters.fWetDryMix">
            <summary>
            Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0 (default) through 100 (all wet).
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXChorusParameters.fDepth">
            <summary>
            Percentage by which the delay time is modulated by the low-frequency oscillator, in hundredths of a percentage point. Must be in the range from 0 through 100. The default value is 25.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXChorusParameters.fFeedback">
            <summary>
            Percentage of output signal to feed back into the effect's input, in the range from -99 to 99. The default value is 0.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXChorusParameters.fFrequency">
            <summary>
            Frequency of the LFO, in the range from 0 to 10. The default value is 0.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXChorusParameters.lWaveform">
            <summary>
            Waveform of the LFO. Default = <see cref="F:ManagedBass.DXWaveform.Sine"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXChorusParameters.fDelay">
            <summary>
            Number of milliseconds the input is delayed before it is played back, in the range from 0 to 20. The default value is 0 ms.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXChorusParameters.lPhase">
            <summary>
            Phase differential between left and right LFOs. Default is <see cref="F:ManagedBass.DXPhase.Zero"/>.
            </summary>
        </member>
        <member name="P:ManagedBass.DirectX8.DXChorusParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.DirectX8.DXDistortionParameters">
            <summary>
            Parameters for DX8 Distortion Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXDistortionParameters.fGain">
            <summary>
            Amount of signal change after distortion, in the range from -60 through 0. The default value is 0 dB.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXDistortionParameters.fEdge">
            <summary>
            Percentage of distortion intensity, in the range in the range from 0 through 100. The default value is 50 percent.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXDistortionParameters.fPostEQCenterFrequency">
            <summary>
            Center frequency of harmonic content addition, in the range from 100 through 8000. The default value is 4000 Hz.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXDistortionParameters.fPostEQBandwidth">
            <summary>
            Width of frequency band that determines range of harmonic content addition, in the range from 100 through 8000. The default value is 4000 Hz.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXDistortionParameters.fPreLowpassCutoff">
            <summary>
            Filter cutoff for high-frequency harmonics attenuation, in the range from 100 through 8000. The default value is 4000 Hz.
            </summary>
        </member>
        <member name="P:ManagedBass.DirectX8.DXDistortionParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.DirectX8.DXEchoParameters">
            <summary>
            Parameters for DX8 Echo Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXEchoParameters.fWetDryMix">
            <summary>
            Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0 (default) through 100 (all wet).
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXEchoParameters.fFeedback">
            <summary>
            Percentage of output fed back into input, in the range from 0 through 100. The default value is 0.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXEchoParameters.fLeftDelay">
            <summary>
            Delay for left channel, in milliseconds, in the range from 1 through 2000. The default value is 333 ms.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXEchoParameters.fRightDelay">
            <summary>
            Delay for right channel, in milliseconds, in the range from 1 through 2000. The default value is 333 ms.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXEchoParameters.lPanDelay">
            <summary>
            Value that specifies whether to swap left and right delays with each successive echo. The default value is <see langword="false" />, meaning no swap.
            </summary>
        </member>
        <member name="P:ManagedBass.DirectX8.DXEchoParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.DirectX8.DXFlangerParameters">
            <summary>
            Parameters for DX8 Flanger Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXFlangerParameters.fWetDryMix">
            <summary>
            Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0 (default) through 100 (all wet).
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXFlangerParameters.fDepth">
            <summary>
            Percentage by which the delay time is modulated by the low-frequency oscillator (LFO), in hundredths of a percentage point. Must be in the range from 0 through 100. The default value is 25.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXFlangerParameters.fFeedback">
            <summary>
            Percentage of output signal to feed back into the effect's input, in the range from -99 to 99. The default value is 0.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXFlangerParameters.fFrequency">
            <summary>
            Frequency of the LFO, in the range from 0 to 10. The default value is 0.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXFlangerParameters.lWaveform">
            <summary>
            Waveform of the LFO. Default = <see cref="F:ManagedBass.DXWaveform.Sine"/>.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXFlangerParameters.fDelay">
            <summary>
            Number of milliseconds the input is delayed before it is played back, in the range from 0 to 4. The default value is 0 ms.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXFlangerParameters.lPhase">
            <summary>
            Phase differential between left and right LFOs. Default = <see cref="F:ManagedBass.DXPhase.Zero"/>.
            </summary>
        </member>
        <member name="P:ManagedBass.DirectX8.DXFlangerParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.DirectX8.DXParamEQParameters">
            <summary>
            Parameters for DX8 ParamEQ Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXParamEQParameters.fCenter">
            <summary>
            Center frequency, in hertz, in the range from 80 to 16000. This value cannot exceed one-third of the frequency of the channel. Default 100 Hz.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXParamEQParameters.fBandwidth">
            <summary>
            Bandwidth, in semitones, in the range from 1 to 36. Default 18 semitones.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXParamEQParameters.fGain">
            <summary>
            Gain, in the range from -15 to 15. Default 0 dB.
            </summary>
        </member>
        <member name="P:ManagedBass.DirectX8.DXParamEQParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.DirectX8.DXReverbParameters">
            <summary>
            Parameters for DX8 Reverb Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXReverbParameters.fInGain">
            <summary>
            Input gain of signal, in decibels (dB), in the range from -96 through 0. The default value is 0 dB.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXReverbParameters.fReverbMix">
            <summary>
            Reverb mix, in dB, in the range from -96 through 0. The default value is 0 dB.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXReverbParameters.fReverbTime">
            <summary>
            Reverb time, in milliseconds, in the range from 0.001 through 3000. The default value is 1000.
            </summary>
        </member>
        <member name="F:ManagedBass.DirectX8.DXReverbParameters.fHighFreqRTRatio">
            <summary>
            In the range from 0.001 through 0.999. The default value is 0.001.
            </summary>
        </member>
        <member name="P:ManagedBass.DirectX8.DXReverbParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Errors">
            <summary>
            Bass Error Codes returned by <see cref="P:ManagedBass.Bass.LastError" /> and BassAsio.LastError.
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Unknown">
            <summary>
            Some other mystery error
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.OK">
            <summary>
            No Error
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Memory">
            <summary>
            Memory Error
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.FileOpen">
            <summary>
            Can't open the file
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Driver">
            <summary>
            Can't find a free/valid driver
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.BufferLost">
            <summary>
            The sample Buffer was lost
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Handle">
            <summary>
            Invalid Handle
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.SampleFormat">
            <summary>
            Unsupported sample format
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Position">
            <summary>
            Invalid playback position
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Init">
            <summary>
            <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/> has not been successfully called
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Start">
            <summary>
            <see cref="M:ManagedBass.Bass.Start"/> has not been successfully called
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.SLL">
            <summary>
            SSL/HTTPS support isn't available.
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NoCD">
            <summary>
            No CD in drive
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.CDTrack">
            <summary>
            Invalid track number
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Already">
            <summary>
            Already initialized/paused/whatever
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NotPaused">
            <summary>
            Not paused
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NotAudioTrack">
            <summary>
            Not an audio track
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NoChannel">
            <summary>
            Can't get a free channel
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Type">
            <summary>
            An illegal Type was specified
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Parameter">
            <summary>
            An illegal parameter was specified
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.No3D">
            <summary>
            No 3D support
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NoEAX">
            <summary>
            No EAX support
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Device">
            <summary>
            Illegal device number
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NotPlaying">
            <summary>
            Not playing
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.SampleRate">
            <summary>
            Illegal sample rate
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NotFile">
            <summary>
            The stream is not a file stream
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NoHW">
            <summary>
            No hardware voices available
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Empty">
            <summary>
            The MOD music has no sequence data
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NoInternet">
            <summary>
            No internet connection could be opened
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Create">
            <summary>
            Couldn't create the file
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NoFX">
            <summary>
            Effects are not available
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Playing">
            <summary>
            The channel is playing
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.NotAvailable">
            <summary>
            Requested data is not available
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Decode">
            <summary>
            The channel is a 'Decoding Channel'
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.DirectX">
            <summary>
            A sufficient DirectX version is not installed
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Timeout">
            <summary>
            Connection timedout
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.FileFormat">
            <summary>
            Unsupported file format
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Speaker">
            <summary>
            Unavailable speaker
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Version">
            <summary>
            Invalid BASS version (used by add-ons)
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Codec">
            <summary>
            Codec is not available/supported
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Ended">
            <summary>
            The channel/file has ended
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Busy">
            <summary>
            The device is busy (eg. in "exclusive" use by another process)
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.AcmCancel">
            <summary>
            BassEnc: ACM codec selection cancelled
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.CastDenied">
            <summary>
            BassEnc: Access denied (invalid password)
            </summary>
        </member>
        <member name="F:ManagedBass.Errors.Mp4NoStream">
            <summary>
            BassAAC: Non-Streamable due to MP4 atom order ("mdat" before "moov")
            </summary>
        </member>
        <member name="T:ManagedBass.Extensions">
            <summary>
            Contains Helper and Extension methods.
            </summary>
        </member>
        <member name="M:ManagedBass.Extensions.Clip``1(``0,``0,``0)">
            <summary>
            Clips a value between a Minimum and a Maximum.
            </summary>
        </member>
        <member name="M:ManagedBass.Extensions.Is``1(``0,``0[])">
            <summary>
            Checks for equality of an item with any element of an array of items.
            </summary>
        </member>
        <member name="M:ManagedBass.Extensions.ToBassFlag(ManagedBass.Resolution)">
            <summary>
            Converts <see cref="T:ManagedBass.Resolution"/> to <see cref="T:ManagedBass.BassFlags"/>
            </summary>
        </member>
        <member name="M:ManagedBass.Extensions.SpeakerN(System.Int32)">
            <summary>
            Returns the <param name="N">n'th (max 15)</param> pair of Speaker Assignment Flags
            </summary>
        </member>
        <member name="P:ManagedBass.Extensions.SupportsFloatingPoint">
            <summary>
            Check whether Floating point streams are supported in the Current Environment.
            </summary>
        </member>
        <member name="M:ManagedBass.Extensions.ChannelCountToString(System.Int32)">
            <summary>
            Returns a string representation for given number of channels.
            </summary>
        </member>
        <member name="M:ManagedBass.Extensions.ExtractMultiStringAnsi(System.IntPtr)">
            <summary>
            Extract an array of strings from a pointer to ANSI null-terminated string ending with a double null.
            </summary>
        </member>
        <member name="M:ManagedBass.Extensions.ExtractMultiStringUtf8(System.IntPtr)">
            <summary>
            Extract an array of strings from a pointer to UTF-8 null-terminated string ending with a double null.
            </summary>
        </member>
        <member name="M:ManagedBass.Extensions.PtrToStringUtf8(System.IntPtr)">
            <summary>
            Returns a Unicode string from a pointer to a Utf-8 string.
            </summary>
        </member>
        <member name="T:ManagedBass.IEffectParameter">
            <summary>
            Parameters for an Effect.
            </summary>
        </member>
        <member name="P:ManagedBass.IEffectParameter.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Plugin">
            <summary>
            Wraps Plugins AddOns.
            </summary>
        </member>
        <member name="P:ManagedBass.Plugin.DllName">
            <summary>
            FileName of the Plugin.
            </summary>
        </member>
        <member name="P:ManagedBass.Plugin.Version">
            <summary>
            Gets the Version of the Plugin.
            </summary>
        </member>
        <member name="P:ManagedBass.Plugin.SupportedFormats">
            <summary>
            Gets the Formats supported by the Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.Plugin.Load(System.String)">
            <summary>
            Load the plugin into memory.
            <param name="Folder">Folder to load the plugin from... <see langword="null"/> (default), Load from Current Directory.</param>
            </summary>
        </member>
        <member name="M:ManagedBass.Plugin.Unload">
            <summary>
            Unloads the Plugin from Memory
            </summary>
        </member>
        <member name="T:ManagedBass.Resolution">
            <summary>
            Bits per Sample of a Channel
            </summary>
        </member>
        <member name="F:ManagedBass.Resolution.Short">
            <summary>
            16-Bit PCM (Default)
            </summary>
        </member>
        <member name="F:ManagedBass.Resolution.Byte">
            <summary>
            8-Bit PCM
            </summary>
        </member>
        <member name="F:ManagedBass.Resolution.Float">
            <summary>
            32-Bit IEEE Floating Point
            </summary>
        </member>
        <member name="T:ManagedBass.Tags.BextTag">
            <summary>
            BWF BEXT block tag structure.
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.BextTag.Description">
            <summary>
            The description or title (Max 256 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.BextTag.Originator">
            <summary>
            The name of the originator or artist (Max 32 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.BextTag.OriginatorReference">
            <summary>
            The reference of the originator or encoded by (Max 32 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.BextTag.OriginationDate">
            <summary>
            The date of creation (Max 10 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.BextTag.OriginationTime">
            <summary>
            The time of creation (max. 10 characters).
            </summary>
        </member>
        <member name="P:ManagedBass.Tags.BextTag.OriginationDateTime">
            <summary>
            The Date and Time of creation.
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.BextTag.TimeReference">
            <summary>
            First sample count since midnight (little-endian).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.BextTag.Version">
            <summary>
            The BWF version (little-endian)
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.BextTag.UMID">
            <summary>
            The SMPTE UMID.
            </summary>
        </member>
        <member name="P:ManagedBass.Tags.BextTag.CodingHistory">
            <summary>
            Coding history.
            </summary>
        </member>
        <member name="M:ManagedBass.Tags.BextTag.Read(System.Int32)">
            <summary>
            Reads the tag from a channel.
            </summary>
            <param name="Channel">The Channel to read the tag from.</param>
        </member>
        <member name="T:ManagedBass.Tags.CartTimer">
            <summary>
            BWF CART Timer structure.
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTimer.Usage">
            <summary>
            Usage
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTimer.Value">
            <summary>
            Value
            </summary>
        </member>
        <member name="T:ManagedBass.Tags.CartTag">
            <summary>
            BWF CART block tag structure.
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.Version">
            <summary>
            Version of the data structure.
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.Title">
            <summary>
            Title of cart audio sequence (Max 64 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.Artist">
            <summary>
            Artist or Creator name (Max 64 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.CutID">
            <summary>
            Cut Number Identification (Max 64 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.ClientID">
            <summary>
            Client Identification (Max 64 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.Category">
            <summary>
            Category ID (e.g. PSA, NEWS, etc | Max 64 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.Classification">
            <summary>
            Classification or Auxiliary Key (Max 64 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.OutCue">
            <summary>
            Out Cue Text (Max 64 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.ProducerAppID">
            <summary>
            Name of vendor or application (Max 64 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.ProducerAppVersion">
            <summary>
            Version of producer application (Max 64 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.UserDef">
            <summary>
            User defined text (Max 64 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.dwLevelReference">
            <summary>
            Sample value for 0 dB reference.
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.PostTimer">
            <summary>
            8 time markers after head.
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.CartTag.URL">
            <summary>
            Uniform resource locator.
            </summary>
        </member>
        <member name="P:ManagedBass.Tags.CartTag.TagText">
            <summary>
            Free form text for scripts or tags.
            </summary>
        </member>
        <member name="P:ManagedBass.Tags.CartTag.StartTime">
            <summary>
            Start time.
            </summary>
        </member>
        <member name="P:ManagedBass.Tags.CartTag.EndTime">
            <summary>
            End time.
            </summary>
        </member>
        <member name="M:ManagedBass.Tags.CartTag.Read(System.Int32)">
            <summary>
            Read the tag from a Channel.
            </summary>
        </member>
        <member name="T:ManagedBass.Tags.ID3v1Tag">
            <summary>
            Wraps an ID3v1 tag
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.ID3v1Tag.Title">
            <summary>
            Returns the Title (Max 30 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.ID3v1Tag.Artist">
            <summary>
            Returns the Artist (Max 30 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.ID3v1Tag.Album">
            <summary>
            Returns the Album (Max 30 characters).
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.ID3v1Tag.Year">
            <summary>
            Returns the Year.
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.ID3v1Tag.genre">
            <summary>
            Genre ID.
            </summary>
        </member>
        <member name="F:ManagedBass.Tags.ID3v1Tag.Genres">
            <summary>
            An array of Genres arranged by ID.
            </summary>
        </member>
        <member name="M:ManagedBass.Tags.ID3v1Tag.Read(System.Int32)">
            <summary>
            Reads an <see cref="T:ManagedBass.Tags.ID3v1Tag"/>.
            </summary>
            <param name="Channel">The Channel to read from.</param>
        </member>
        <member name="P:ManagedBass.Tags.ID3v1Tag.Comment">
            <summary>
            Gets the Comment.
            </summary>
        </member>
        <member name="P:ManagedBass.Tags.ID3v1Tag.Genre">
            <summary>
            Gets the Genre.
            </summary>
        </member>
        <member name="P:ManagedBass.Tags.ID3v1Tag.TrackNo">
            <summary>
            Gets the Track Number.
            </summary>
        </member>
        <member name="T:ManagedBass.Mix.BassMix">
            <summary>
            Wraps BassMix: bassmix.dll
            </summary>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.CreateSplitStream(System.Int32,ManagedBass.BassFlags,System.Int32[])">
            <summary>
            Creates a splitter stream (adds a reader channel to a decoding source channel).
            </summary>
            <param name="Channel">The handle of the decoding source channel to split... a HMUSIC, HSTREAM or HRECORD.</param>
            <param name="Flags">The channel falgs to be used to create the reader channel.</param>
            <param name="ChannelMap">The target (readers) channel mapping definition, which is an array of source channel index values (0=1st channel, 1=2nd channel, 2=3rd channel, 3=4th channel etc.) ending with a final -1 element (use <see langword="null" /> to create a 1:1 reader).</param>
            <returns>If successful, the new reader stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            A "splitter" basically does the opposite of a mixer: it splits a single source into multiple streams rather then mixing multiple sources into a single stream.
            Like mixer sources, splitter sources must be decoding channels.
            <para>
            The splitter stream will have the same sample rate and resolution as its source, but it can have a different number of channels, as dictated by the mapping parameter.
            Even when the number of channels is different (and so the amount of data produced is different), <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" /> will give the source length, and <see cref="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)" /> will give the source position that is currently being output by the splitter stream.
            </para>
            <para>
            All splitter streams with the same source share a buffer to access its sample data.
            The length of the buffer is determined by the <see cref="P:ManagedBass.Mix.BassMix.SplitBufferLength"/> config option;
            the splitter streams should not be allowed to drift apart beyond that, otherwise those left behind will suffer buffer overflows. 
            A splitter stream's buffer state can be reset via <see cref="M:ManagedBass.Mix.BassMix.SplitStreamReset(System.Int32)" />;
            that can also be used to reset a splitter stream that has ended, so that it can be played again.
            </para>
            <para>
            If the <see cref="F:ManagedBass.BassFlags.SplitSlave"/> flag is used, the splitter stream will only receive data from the buffer and will not request more data from the source, so it can only receive data that has already been received by another splitter stream with the same source.
            The <see cref="F:ManagedBass.BassFlags.SplitSlave"/> flag can be toggled at any time via <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)" />.
            </para>
            <para>
            When <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> is used on a splitter stream, its source will be set to the requested position and the splitter stream's buffer state will be reset so that it immediately receives data from the new position. 
            The position change will affect all of the source's splitter streams, but the others will not have their buffer state reset;
            they will continue to receive any buffered data before reaching the data from the new position. 
            <see cref="M:ManagedBass.Mix.BassMix.SplitStreamReset(System.Int32)" /> can be used to reset the buffer state.
            </para>
            <para>
            Use <see cref="M:ManagedBass.Bass.StreamFree(System.Int32)"/> with a splitter channel to remove it from the source.
            When a source is freed, all of its splitter streams are automatically freed.
            </para>
            <para>
            The <paramref name="ChannelMap" /> array defines the channel number to be created for the reader as well as which source channels should be used for each.
            This enables you to create a reader stream which extract certain source channels (e.g. create a mono reader based on a stereo source), remaps the channel order (e.g. swap left and right in the reader) or even contains more channels than the source (e.g. create a 5.1 reader based on a stereo source).
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Channel" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Decode">The <paramref name="Channel" /> is not a decoding channel.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">The <paramref name="ChannelMap" /> contains an invalid channel index.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding streams (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/>. The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is also unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported (ie. no WDM drivers).</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The device/drivers do not support the requested speaker(s), or you're attempting to assign a stereo stream to a mono speaker.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficent memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Couldn't initialize 3D support for the stream.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.SplitStreamGetAvailable(System.Int32)">
            <summary>
            Retrieves the amount of buffered data available to a splitter stream, or the amount of data in a splitter source buffer.
            </summary>
            <param name="Handle">The splitter (as obtained by <see cref="M:ManagedBass.Mix.BassMix.CreateSplitStream(System.Int32,ManagedBass.BassFlags,System.Int32[])" />) or the source channel handle.</param>
            <returns>If successful, then the amount of buffered data (in bytes) is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            With a splitter source, this function reports how much data is in the buffer that is shared by all of its splitter streams.
            With a splitter stream, this function reports how much data is ahead of it in the buffer, before it will receive any new data from the source.
            A splitter stream can be repositioned within the buffer via the <see cref="M:ManagedBass.Mix.BassMix.SplitStreamReset(System.Int32,System.Int32)" /> function.
            <para>The amount of data that can be buffered is limited by the buffer size, which is determined by the <see cref="P:ManagedBass.Mix.BassMix.SplitBufferLength" /> config option.</para>
            <para>The returned buffered byte count is always based on the source's sample format, even with splitter streams that were created with a different channel count.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Handle" /> is neither a splitter stream or source.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.SplitStreamReset(System.Int32)">
            <summary>
            Resets a splitter stream or all splitter streams of a source.
            </summary>
            <param name="Handle">The splitter (as obtained by <see cref="M:ManagedBass.Mix.BassMix.CreateSplitStream(System.Int32,ManagedBass.BassFlags,System.Int32[])" />) or the source channel handle.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function resets the splitter stream's buffer state, so that the next sample data it receives will be from the source's current position. 
            If the stream has ended, that is reset too, so that it can be played again.
            Unless called from within a mixtime sync callback, the stream's output buffer (if it has one) is also flushed.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Handle" /> is neither a splitter stream or source.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.SplitStreamReset(System.Int32,System.Int32)">
            <summary>
            Resets a splitter stream and sets its position in the source buffer.
            </summary>
            <param name="Handle">The splitter (as obtained by <see cref="M:ManagedBass.Mix.BassMix.CreateSplitStream(System.Int32,ManagedBass.BassFlags,System.Int32[])" />) or the source channel handle.</param>
            <param name="Offset">
            How far back (in bytes) to position the splitter in the source buffer.
            This is based on the source's sample format, which may have a different channel count to the splitter.
            </param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function is the same as <see cref="M:ManagedBass.Mix.BassMix.SplitStreamReset(System.Int32)" /> except that it also provides the ability to position the splitter stream within the buffer that is shared by all of the splitter streams of the same source.
            A splitter stream's buffer position determines what data it will next receive.
            For example, if its position is half a second back, it will receive half a second of buffered data before receiving new data from the source.
            Calling this function with <paramref name="Offset"/> = 0 will result in the next data that the splitter stream receives being new data from the source, and is identical to using <see cref="M:ManagedBass.Mix.BassMix.SplitStreamReset(System.Int32)" />.
            <para>
            <paramref name="Offset" /> is automatically limited to the amount of data that the source buffer contains, which is in turn limited to the buffer size, determined by the <see cref="P:ManagedBass.Mix.BassMix.SplitBufferLength" /> config option.
            The amount of source data buffered, as well as a splitter stream's position within it, is available from <see cref="M:ManagedBass.Mix.BassMix.SplitStreamGetAvailable(System.Int32)" />.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Handle" /> is neither a splitter stream or source.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.SplitStreamGetSource(System.Int32)">
            <summary>
            Retrieves the source of a splitter stream.
            </summary>
            <param name="Handle">The splitter stream handle (which was add via <see cref="M:ManagedBass.Mix.BassMix.CreateSplitStream(System.Int32,ManagedBass.BassFlags,System.Int32[])" /> beforehand).</param>
            <returns>If successful, the source stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle">The <paramref name="Handle" /> is not a splitter stream.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.SplitStreamGetSplits(System.Int32)">
            <summary>
            Retrieves the channel's splitters.
            </summary>
            <param name="Handle">The handle to check.</param>
            <returns>The array of splitter handles (<see langword="null" /> on error, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code).</returns>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.CreateMixerStream(System.Int32,System.Int32,ManagedBass.BassFlags)">
            <summary>
            Creates a mixer stream.
            </summary>
            <param name="Frequency">The sample rate of the mixer output (e.g. 44100).</param>
            <param name="Channels">The number of channels... 1 = mono, 2 = stereo, 4 = quadraphonic, 6 = 5.1, 8 = 7.1. More than stereo requires WDM drivers (or the <see cref="F:ManagedBass.BassFlags.Decode"/> flag) in Windows, and the Speaker flags are ignored.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>..</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Source channels are "plugged" into a mixer using the <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> functions, and "unplugged" using the <see cref="M:ManagedBass.Mix.BassMix.MixerRemoveChannel(System.Int32)" /> function.
            Sources can be added and removed at any time, so a mixer does not have a predetermined length and <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)" /> is not applicable.
            Likewise, seeking is not possible, except to position 0, as described below.
            </para>
            <para>
            If the mixer output is being played (it is not a decoding channel), then there will be some delay in the effect of adding/removing source channels or changing their attributes being heard.
            This latency can be reduced by making use of the <see cref="P:ManagedBass.Bass.PlaybackBufferLength" /> and <see cref="P:ManagedBass.Bass.UpdatePeriod" /> config options.
            The playback buffer can be flushed by calling <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" /> (Restart = true) or <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> (Position = 0).
            That can also be done to restart a mixer that has ended.
            </para>
            <para>
            Unless the <see cref="F:ManagedBass.BassFlags.MixerEnd"/> flag is specified, a mixer stream will never end.
            When there are no sources (or the sources have ended/stalled), it'll produce no output until there's an active source. 
            That's unless the <see cref="F:ManagedBass.BassFlags.MixerNonStop"/> flag is used, in which case it will produce silent output while there are no active sources.
            The <see cref="F:ManagedBass.BassFlags.MixerEnd"/> and <see cref="F:ManagedBass.BassFlags.MixerNonStop"/> flags can be toggled at any time, using <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)" />.
            </para>
            <para>
            Besides mixing channels, a mixer stream can be used as a resampler.
            In that case the freq parameter would be set the new sample rate, and the source channel's attributes would be left at their defaults. 
            A mixer stream can also be used to downmix, upmix and generally rearrange channels, set using the <see cref="M:ManagedBass.Mix.BassMix.ChannelSetMatrix(System.Int32,System.Single[0:,0:])"/>.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding streams (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/>.</exception>
            <exception cref="F:ManagedBass.Errors.SampleRate"><paramref name="Frequency"/> is out of range. See <see cref="P:ManagedBass.BassInfo.MinSampleRate"/> and <see cref="P:ManagedBass.BassInfo.MaxSampleRate"/> members.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported (ie. no WDM drivers).</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The device/drivers do not support the requested speaker(s), or you're attempting to assign a stereo stream to a mono speaker.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficent memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Couldn't initialize 3D support for the stream.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)">
            <summary>
            Plugs a channel into a mixer.
            </summary>
            <param name="Handle">The mixer handle (created with <see cref="M:ManagedBass.Mix.BassMix.CreateMixerStream(System.Int32,System.Int32,ManagedBass.BassFlags)" />).</param>
            <param name="Channel">The handle of the channel to plug into the mixer... a HMUSIC, HSTREAM or HRECORD.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Internally, a mixer will use the <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> function to get data from its source channels.
            That means that the source channels must be decoding channels (not using a <see cref="T:ManagedBass.RecordProcedure" /> in the case of a recording channel).
            Plugging a channel into more than one mixer at a time is not possible because the mixers would be taking data away from each other.
            An advantage of this is that there is no need for a mixer's handle to be provided with the channel functions.
            It is actually possible to plug a channel into multiple mixers via the use of splitter streams.</para>
            <para>
            Channels are 'unplugged' using the <see cref="M:ManagedBass.Mix.BassMix.MixerRemoveChannel(System.Int32)" /> function.
            Channels are also automatically unplugged when they are freed.
            </para>
            <para>
            When mixing a channel, the mixer makes use of the channel's attributes (freq/volume/pan), as set with <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" /> or <see cref="M:ManagedBass.Bass.ChannelSlideAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single,System.Int32)" />.
            The <see cref="P:ManagedBass.Bass.LogarithmicVolumeCurve"/> and <see cref="P:ManagedBass.Bass.LogarithmicPanningCurve"/> config option settings are also used.
            </para>
            <para>
            If a multi-channel stream has more channels than the mixer output, the extra channels will be discarded.
            For example, if a 5.1 stream is plugged into a stereo mixer, only the front-left/right channels will be retained.
            That is unless matrix mixing is used.
            </para>
            <para>
            The mixer processing is performed in floating-point, so it makes sense (for both quality and efficiency reasons) for the source channels to be floating-point too, though they do not have to be.
            It is also more efficient if the source channels have the same sample rate as the mixer output because no sample rate conversion is required then.
            When sample rate conversion is required, windowed sinc interpolation is used and the source's <see cref="F:ManagedBass.ChannelAttribute.SampleRateConversion" /> attribute determines how many points/samples are used in that, as follows:
            0 (or below) = 4 points, 1 = 8 points, 2 = 16 points, 3 = 32 points, 4 = 64 points, 5 = 128 points, 6 (or above) = 256 points.
            8 points are used if the <see cref="F:ManagedBass.ChannelAttribute.SampleRateConversion" /> attribute is unavailable (old BASS version).
            A higher number of points results in better sound quality (less aliasing and smaller transition band in the low-pass filter), but also higher CPU usage.
            </para>
            <para><b>Platform-specific:</b></para>
            <para>
            The sample rate conversion processing is limited to 128 points on iOS and Android.
            The mixer processing is also performed in fixed-point rather than floating-point on Android.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">At least one of <paramref name="Handle" /> and <paramref name="Channel" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Decode"><paramref name="Channel" /> is not a decoding channel.</exception>
            <exception cref="F:ManagedBass.Errors.Already"><paramref name="Channel" /> is already plugged into a mixer. It must be unplugged first.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The mixer does not support the requested speaker(s), or you're attempting to assign a stereo stream to a mono speaker.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)">
            <summary>
            Plugs a channel into a mixer, optionally delaying the start and limiting the length.
            </summary>
            <param name="Handle">The mixer handle (created with <see cref="M:ManagedBass.Mix.BassMix.CreateMixerStream(System.Int32,System.Int32,ManagedBass.BassFlags)" />).</param>
            <param name="Channel">The handle of the channel to plug into the mixer... a HMUSIC, HSTREAM or HRECORD.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Start">Delay (in bytes) before the channel is mixed in.</param>
            <param name="Length">The maximum amount of data (in bytes) to mix... 0 = no limit. Once this end point is reached, the channel will be removed from the mixer.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function is identical to <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" />, but with the additional ability to specify a delay and duration for the channel.
            <para>
            The <paramref name="Start" /> and <paramref name="Length" /> parameters relate to the mixer output.
            So when calculating these values, use the mixer stream's sample format rather than the source channel's. 
            The start parameter is automatically rounded-down to the nearest sample boundary, while the length parameter is rounded-up to the nearest sample boundary.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">At least one of <paramref name="Handle" /> and <paramref name="Channel" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Decode"><paramref name="Channel" /> is not a decoding channel.</exception>
            <exception cref="F:ManagedBass.Errors.Already"><paramref name="Channel" /> is already plugged into a mixer. It must be unplugged first.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The mixer does not support the requested speaker(s), or you're attempting to assign a stereo stream to a mono speaker.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.MixerRemoveChannel(System.Int32)">
            <summary>
            Unplugs a channel from a mixer.
            </summary>
            <param name="Handle">The handle of the mixer source channel to unplug (which was addded via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" />) beforehand).</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle">The channel is not plugged into a mixer.</exception>
        </member>
        <member name="P:ManagedBass.Mix.BassMix.SplitBufferLength">
            <summary>
            The splitter Buffer Length in milliseconds... 100 (min) to 5000 (max).
            </summary>
            <remarks>
            If the value specified is outside this range, it is automatically capped.
            When a source has its first splitter stream created, a Buffer is allocated
            for its sample data, which all of its subsequently created splitter streams
            will share. This config option determines how big that Buffer is. The default
            is 2000ms.
            The Buffer will always be kept as empty as possible, so its size does not
            necessarily affect latency; it just determines how far splitter streams can
            drift apart before there are Buffer overflow issues for those left behind.
            Changes do not affect buffers that have already been allocated; any sources
            that have already had splitter streams created will continue to use their
            existing buffers.
            </remarks>
        </member>
        <member name="P:ManagedBass.Mix.BassMix.MixerBufferLength">
            <summary>
            The source channel Buffer size multiplier... 1 (min) to 5 (max). 
            </summary>
            <remarks>
            If the value specified is outside this range, it is automatically capped.
            When a source channel has buffering enabled, the mixer will Buffer the decoded data,
            so that it is available to the <see cref="M:ManagedBass.Mix.BassMix.ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> and <see cref="M:ManagedBass.Mix.BassMix.ChannelGetLevel(System.Int32)"/> functions.
            To reach the source channel's Buffer size, the multiplier (multiple) is applied to the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/>
            setting at the time of the mixer's creation.
            If the source is played at it's default rate, then the Buffer only need to be as big as the mixer's Buffer.
            But if it's played at a faster rate, then the Buffer needs to be bigger for it to contain the data that 
            is currently being heard from the mixer.
            For example, playing a channel at 2x its normal speed would require the Buffer to be 2x the normal size (multiple = 2).
            Larger buffers obviously require more memory, so the multiplier should not be set higher than necessary.
            The default multiplier is 2x. 
            Changes only affect subsequently setup channel buffers.
            An existing channel can have its Buffer reinitilized by disabling and then re-enabling 
            the <see cref="F:ManagedBass.BassFlags.MixerBuffer"/> flag using <see cref="M:ManagedBass.Mix.BassMix.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)"/>.
            </remarks>
        </member>
        <member name="P:ManagedBass.Mix.BassMix.MixerPositionEx">
            <summary>
            BASSmix add-on: How far back to keep record of source positions
            to make available for <see cref="M:ManagedBass.Mix.BassMix.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags,System.Int32)"/>, in milliseconds.
            </summary>
            <remarks>
            If a mixer is not a decoding channel (not using the BassFlag.Decode flag),
            this config setting will just be a minimum and the mixer will 
            always have a position record at least equal to its playback Buffer Length, 
            as determined by the PlaybackBufferLength config option.
            The default setting is 2000ms.
            Changes only affect newly created mixers, not any that already exist.
            </remarks>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)">
            <summary>
            Modifies and/or retrieves a channel's mixer flags.
            </summary>
            <param name="Handle">The handle of the mixer source channel to modify (which was add via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" />) beforehand).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Mask">
            The flags (as above) to modify.
            Flags that are not included in this are left as they are, so it can be set to 0 (<see cref="F:ManagedBass.BassFlags.Default" />) in order to just retrieve the current flags. 
            To modify the speaker flags, any of the Speaker flags can be used in the mask (no need to include all of them).
            </param>
            <returns>If successful, the channel's updated flags are returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function only deals with the channel's mixer related flags.
            The channel's standard flags, for example looping (<see cref="F:ManagedBass.BassFlags.Loop"/>), are unaffected - use <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)" /> to modify them.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The channel is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The mixer does not support the requested speaker(s), or the channel has matrix mixing enabled.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelHasFlag(System.Int32,ManagedBass.BassFlags)">
            <summary>
            Gets whether a flag is present.
            </summary>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelAddFlag(System.Int32,ManagedBass.BassFlags)">
            <summary>
            Adds a flag to Mixer.
            </summary>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelRemoveFlag(System.Int32,ManagedBass.BassFlags)">
            <summary>
            Removes a flag from Mixer.
            </summary>
            <param name="handle"></param>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetData(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a mixer source channel.
            </summary>
            <param name="Handle">The handle of the mixer source channel (which was addded via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand).</param>
            <param name="Buffer">Location to write the data as an <see cref="T:System.IntPtr" /> (can be <see cref="F:System.IntPtr.Zero" /> when handle is a recording channel (HRECORD), to discard the requested amount of data from the recording buffer).</param>
            <param name="Length">Number of bytes wanted, and/or <see cref="T:ManagedBass.DataFlags"/>.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>
            This function is like the standard <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" />, but it gets the data from the channel's buffer instead of decoding it from the channel, which means that the mixer doesn't miss out on any data.
            In order to do this, the source channel must have buffering enabled, via the <see cref="F:ManagedBass.BassFlags.MixerBuffer"/> flag.
            </para>
            <para>
            If the mixer is a decoding channel, then the channel's most recent data will be returned.
            Otherwise, the data will be in sync with what is currently being heard from the mixer, unless the buffer is too small so that the currently heard data isn't in it. 
            The <see cref="P:ManagedBass.Mix.BassMix.MixerBufferLength"/> config option can be used to set the buffer size.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The channel does not have buffering (<see cref="F:ManagedBass.BassFlags.MixerBuffer"/>) enabled.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetData(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a mixer source channel.
            </summary>
            <param name="Handle">The handle of the mixer source channel (which was addded via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand).</param>
            <param name="Buffer">byte[] to write the data to.</param>
            <param name="Length">Number of bytes wanted, and/or <see cref="T:ManagedBass.DataFlags"/>.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>
            This function is like the standard <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.Byte[],System.Int32)" />, but it gets the data from the channel's buffer instead of decoding it from the channel, which means that the mixer doesn't miss out on any data.
            In order to do this, the source channel must have buffering enabled, via the <see cref="F:ManagedBass.BassFlags.MixerBuffer"/> flag.
            </para>
            <para>
            If the mixer is a decoding channel, then the channel's most recent data will be returned.
            Otherwise, the data will be in sync with what is currently being heard from the mixer, unless the buffer is too small so that the currently heard data isn't in it. 
            The <see cref="P:ManagedBass.Mix.BassMix.MixerBufferLength"/> config option can be used to set the buffer size.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The channel does not have buffering (<see cref="F:ManagedBass.BassFlags.MixerBuffer"/>) enabled.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetData(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a mixer source channel.
            </summary>
            <param name="Handle">The handle of the mixer source channel (which was addded via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand).</param>
            <param name="Buffer">short[] to write the data to.</param>
            <param name="Length">Number of bytes wanted, and/or <see cref="T:ManagedBass.DataFlags"/>.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>
            This function is like the standard <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.Int16[],System.Int32)" />, but it gets the data from the channel's buffer instead of decoding it from the channel, which means that the mixer doesn't miss out on any data.
            In order to do this, the source channel must have buffering enabled, via the <see cref="F:ManagedBass.BassFlags.MixerBuffer"/> flag.
            </para>
            <para>
            If the mixer is a decoding channel, then the channel's most recent data will be returned.
            Otherwise, the data will be in sync with what is currently being heard from the mixer, unless the buffer is too small so that the currently heard data isn't in it. 
            The <see cref="P:ManagedBass.Mix.BassMix.MixerBufferLength"/> config option can be used to set the buffer size.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The channel does not have buffering (<see cref="F:ManagedBass.BassFlags.MixerBuffer"/>) enabled.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetData(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a mixer source channel.
            </summary>
            <param name="Handle">The handle of the mixer source channel (which was addded via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand).</param>
            <param name="Buffer">int[] to write the data to.</param>
            <param name="Length">Number of bytes wanted, and/or <see cref="T:ManagedBass.DataFlags"/>.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>
            This function is like the standard <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.Int32[],System.Int32)" />, but it gets the data from the channel's buffer instead of decoding it from the channel, which means that the mixer doesn't miss out on any data.
            In order to do this, the source channel must have buffering enabled, via the <see cref="F:ManagedBass.BassFlags.MixerBuffer"/> flag.
            </para>
            <para>
            If the mixer is a decoding channel, then the channel's most recent data will be returned.
            Otherwise, the data will be in sync with what is currently being heard from the mixer, unless the buffer is too small so that the currently heard data isn't in it. 
            The <see cref="P:ManagedBass.Mix.BassMix.MixerBufferLength"/> config option can be used to set the buffer size.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The channel does not have buffering (<see cref="F:ManagedBass.BassFlags.MixerBuffer"/>) enabled.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetData(System.Int32,System.Single[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a mixer source channel.
            </summary>
            <param name="Handle">The handle of the mixer source channel (which was addded via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand).</param>
            <param name="Buffer">float[] to write the data to.</param>
            <param name="Length">Number of bytes wanted, and/or <see cref="T:ManagedBass.DataFlags"/>.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the <see cref="F:ManagedBass.DataFlags.Float"/> flag).</para>
            <para>When using the <see cref="F:ManagedBass.DataFlags.Available"/> flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>
            This function is like the standard <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.Single[],System.Int32)" />, but it gets the data from the channel's buffer instead of decoding it from the channel, which means that the mixer doesn't miss out on any data.
            In order to do this, the source channel must have buffering enabled, via the <see cref="F:ManagedBass.BassFlags.MixerBuffer"/> flag.
            </para>
            <para>
            If the mixer is a decoding channel, then the channel's most recent data will be returned.
            Otherwise, the data will be in sync with what is currently being heard from the mixer, unless the buffer is too small so that the currently heard data isn't in it. 
            The <see cref="P:ManagedBass.Mix.BassMix.MixerBufferLength"/> config option can be used to set the buffer size.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The channel does not have buffering (<see cref="F:ManagedBass.BassFlags.MixerBuffer"/>) enabled.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetLevel(System.Int32)">
            <summary>
            Retrieves the level (peak amplitude) of a mixer source channel.
            </summary>
            <param name="Handle">The handle of the mixer source channel (which was add via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" />) beforehand).</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            <para>
            If successful, the level of the left channel is returned in the low word (low 16-bits), and the level of the right channel is returned in the high word (high 16-bits).
            If the channel is mono, then the low word is duplicated in the high word. 
            The level ranges linearly from 0 (silent) to 32768 (max). 0 will be returned when a channel is stalled.
            </para>
            </returns>
            <remarks>
            <para>
            This function is like the standard <see cref="M:ManagedBass.Bass.ChannelGetLevel(System.Int32)" />, but it gets the level from the channel's buffer instead of decoding data from the channel, which means that the mixer doesn't miss out on any data. 
            In order to do this, the source channel must have buffering enabled, via the <see cref="F:ManagedBass.BassFlags.MixerBuffer"/> flag.
            </para>
            <para>
            If the mixer is a decoding channel, then the channel's most recent data will be used to get the level.
            Otherwise, the level will be in sync with what is currently being heard from the mixer, unless the buffer is too small so that the currently heard data isn't in it. 
            The <see cref="P:ManagedBass.Mix.BassMix.MixerBufferLength"/> config option can be used to set the buffer size.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The channel does not have buffering (<see cref="F:ManagedBass.BassFlags.MixerBuffer"/>) enabled.</exception>
            <exception cref="F:ManagedBass.Errors.NotPlaying">The mixer is not playing.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetLevel(System.Int32,System.Single[],System.Single,ManagedBass.LevelRetrievalFlags)">
            <summary>
            Retrieves the level of a mixer source channel.
            </summary>
            <param name="Handle">The handle of the mixer source channel (which was add via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" />) beforehand).</param>
            <param name="Levels">An array to receive the levels.</param>
            <param name="Length">The amount of data to inspect to calculate the level, in seconds. The maximum is 1 second. Less data than requested may be used if the full amount is not available, eg. if the source's buffer (determined by the <see cref="P:ManagedBass.Mix.BassMix.MixerBufferLength"/> config option) is shorter.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.LevelRetrievalFlags"/>.</param>
            <returns>
            If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.
            <para>
            If successful, the level of the left channel is returned in the low word (low 16-bits), and the level of the right channel is returned in the high word (high 16-bits).
            If the channel is mono, then the low word is duplicated in the high word. 
            The level ranges linearly from 0 (silent) to 32768 (max). 0 will be returned when a channel is stalled.
            </para>
            </returns>
            <remarks>
            <para>
            This function is like the standard <see cref="M:ManagedBass.Bass.ChannelGetLevel(System.Int32,System.Single[],System.Single,ManagedBass.LevelRetrievalFlags)" />, but it gets the level from the channel's buffer instead of decoding data from the channel, which means that the mixer doesn't miss out on any data. 
            In order to do this, the source channel must have buffering enabled, via the <see cref="F:ManagedBass.BassFlags.MixerBuffer"/> flag.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The channel does not have buffering (<see cref="F:ManagedBass.BassFlags.MixerBuffer"/>) enabled.</exception>
            <exception cref="F:ManagedBass.Errors.NotPlaying">The mixer is not playing.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetMatrix(System.Int32,System.Single[0:,0:])">
            <summary>
            Retrieves a channel's mixing matrix, if it has one.
            </summary>
            <param name="Handle">The mixer source channel handle (which was add via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" />) beforehand).</param>
            <param name="Matrix">The 2-dimentional array (float[,]) where to write the matrix.</param>
            <returns>If successful, a <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            For more details see <see cref="M:ManagedBass.Mix.BassMix.ChannelSetMatrix(System.Int32,System.Single[0:,0:])" />.
            The array must be big enough to get the matrix.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The channel is not using matrix mixing.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetMixer(System.Int32)">
            <summary>
            Retrieves the mixer that a channel is plugged into.
            </summary>
            <param name="Handle">The mixer source channel handle (which was add via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand).</param>
            <returns>If successful, the mixer stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle">The channel is not plugged into a mixer.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelSetMatrix(System.Int32,System.Single[0:,0:])">
            <summary>
            Sets a channel's mixing matrix, if it has one.
            </summary>
            <param name="Handle">The mixer source channel handle (which was addded via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand)</param>
            <param name="Matrix">The 2-dimensional array (float[,]) of the mixing matrix.</param>
            <returns>If successful, a <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Normally when mixing channels, the source channels are sent to the output in the same order - the left input is sent to the left output, and so on.
            Sometimes something a bit more complex than that is required.
            For example, if the source has more channels than the output, you may want to "downmix" the source so that all channels are present in the output.
            Equally, if the source has fewer channels than the output, you may want to "upmix" it so that all output channels have sound.
            Or you may just want to rearrange the channels. Matrix mixing allows all of these.
            </para>
            <para>
            A matrix mixer is created on a per-source basis (you can mix'n'match normal and matrix mixing), by using the <see cref="F:ManagedBass.BassFlags.MixerMatrix" /> and/or <see cref="F:ManagedBass.BassFlags.MixerDownMix" /> flag when calling <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" />. 
            The matrix itself is a 2-dimensional array of floating-point mixing levels, with the source channels on one axis, and the output channels on the other.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The channel is not using matrix mixing.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelSetMatrix(System.Int32,System.Single[0:,0:],System.Single)">
            <summary>
            Sets a channel's mixing matrix, transitioning from the current matrix.
            </summary>
            <param name="Handle">The mixer source channel handle (which was add via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand).</param>
            <param name="Matrix">The 2-dimensional array (float[,]) of the new mixing matrix.</param>
            <param name="Time">The time to take (in seconds) to transition from the current matrix to the specified matrix.</param>
            <returns>If successful, a <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This method is identical to <see cref="M:ManagedBass.Mix.BassMix.ChannelSetMatrix(System.Int32,System.Single[0:,0:])" /> but with the option of transitioning over time to the specified matrix.
            If this function or <see cref="M:ManagedBass.Mix.BassMix.ChannelSetMatrix(System.Int32,System.Single[0:,0:])"/> is called while a previous matrix transition is still in progress, then that transition will be stopped.
            If <see cref="M:ManagedBass.Mix.BassMix.ChannelGetMatrix(System.Int32,System.Single[0:,0:])"/> is called mid-transition, it will give the mid-transition matrix values.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The channel is not using matrix mixing.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)">
            <summary>
            Retrieves the playback position of a mixer source channel.
            </summary>
            <param name="Handle">The mixer source channel handle (which was addded via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand).</param>
            <param name="Mode">Position mode... default = <see cref="F:ManagedBass.PositionFlags.Bytes"/>.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. If successful, the position is returned.</returns>
            <remarks>
            This function is like the standard <see cref="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)" />, but it compensates for the mixer's buffering to return the source channel position that is currently being heard.
            So when used with a decoding channel (eg. a mixer source channel), this method will return the current decoding position.
            But if the mixer output is being played, then there is a playback buffer involved.
            This function compensates for that, to return the position that is currently being heard. 
            If the mixer itself is a decoding channel, then this function is identical to using <see cref="M:ManagedBass.Bass.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)" />.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The requested position is not available.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags,System.Int32)">
            <summary>
            Retrieves the playback position of a mixer source channel, optionally accounting for some latency.
            </summary>
            <param name="Handle">The mixer source channel handle (which was addded via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand).</param>
            <param name="Mode">Position mode.</param>
            <param name="Delay">How far back (in bytes) in the mixer output to get the source channel's position from.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code. If successful, the channel's position is returned.</returns>
            <remarks>
            <see cref="M:ManagedBass.Mix.BassMix.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)" /> compensates for the mixer's playback buffering to give the position that is currently being heard, but if the mixer is feeding some other output system, it will not know how to compensate for that.
            This function fills that gap by allowing the latency to be specified in the call.
            This functionality requires the mixer to keep a record of its sources' position going back some time, and that is enabled via the <see cref="F:ManagedBass.BassFlags.MixerPositionEx" /> flag when a mixer is created, with the <see cref="P:ManagedBass.Mix.BassMix.MixerPositionEx" /> config option determining how far back the position record goes.
            If the mixer is not a decoding channel (not using the <see cref="F:ManagedBass.BassFlags.Decode" /> flag), then it will automatically have a position record at least equal to its playback buffer length.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The requested position is not available, or delay goes beyond where the mixer has record of the source channel's position.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)">
            <summary>
            Sets the playback position of a mixer source channel.
            </summary>
            <param name="Handle">The mixer source channel handle (which was addded via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" /> beforehand).</param>
            <param name="Position">The position, in bytes. With MOD musics, the position can also be set in orders and rows instead of bytes.</param>
            <param name="Mode">Position Mode... default = <see cref="F:ManagedBass.PositionFlags.Bytes"/>.</param>
            <returns>If successful, then <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function works exactly like the standard <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" />, except that it also resets things for the channel in the mixer, well as supporting the <see cref="F:ManagedBass.BassFlags.MixerNoRampin"/> flag.
            See <see cref="M:ManagedBass.Mix.BassMix.ChannelGetPosition(System.Int32,ManagedBass.PositionFlags)" /> for details.
            <para>For custom looping purposes (eg. in a mixtime <see cref="T:ManagedBass.SyncProcedure"/>), the standard <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> function should be used instead of this</para>
            <para>The playback buffer of the mixer can be flushed by using pos = 0.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The channel is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.NotFile">The stream is not a file stream.</exception>
            <exception cref="F:ManagedBass.Errors.Position">The requested position is illegal.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The download has not yet reached the requested position.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)">
            <summary>
            Sets up a synchronizer on a mixer source channel.
            </summary>
            <param name="Handle">The mixer source channel handle.</param>
            <param name="Type">The type of sync.</param>
            <param name="Parameter">The sync parameters, depends on the sync type.</param>
            <param name="Procedure">The callback function which should be invoked with the sync.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If succesful, then the new synchronizer's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            When used on a decoding channel (eg. a mixer source channel), syncs set with <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> are automatically <see cref="F:ManagedBass.SyncFlags.Mixtime"/>, 
            which means that they will be triggered as soon as the sync event is encountered during decoding. 
            But if the mixer output is being played, then there is a playback buffer involved, which will delay the hearing of the sync event. 
            This function compensates for that, delaying the triggering of the sync until the event is actually heard. 
            If the mixer itself is a decoding channel, or the <see cref="F:ManagedBass.SyncFlags.Mixtime"/> flag is used, then there is effectively no real difference between this function and <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />.
            One sync type that is slightly different is the <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync, which can be either mixtime or not.
            </para>
            <para>
            Sync types that would automatically be mixtime when using <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> are not so when using this function. 
            The <see cref="F:ManagedBass.SyncFlags.Mixtime"/> flag should be specified in those cases, or <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> used instead.
            </para>
            <para>
            When a source is removed from a mixer, any syncs that have been set on it via this function are automatically removed. 
            If the channel is subsequently plugged back into a mixer, the previous syncs will not still be set on it.
            Syncs set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> are unaffected.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The channel is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.Type">An illegal <paramref name="Type" /> was specified.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">An illegal <paramref name="Parameter" /> was specified.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.Mix.SyncProcedureEx,System.IntPtr)">
            <summary>
            Sets up an extended synchronizer on a mixer source channel.
            </summary>
            <param name="Handle">The mixer source channel handle.</param>
            <param name="Type">The type of sync.</param>
            <param name="Parameter">The sync parameters, depends on the sync type.</param>
            <param name="Procedure">The callback function which should be invoked with the sync.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If succesful, then the new synchronizer's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            The main difference between this method and <see cref="M:ManagedBass.Mix.BassMix.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> is, that this method invokes the <see cref="T:ManagedBass.Mix.SyncProcedureEx" /> callback.
            This callback contains an extra 'Offset' parameter, which defines the position of the sync occurrence within the current update cycle of the source converted to the mixer stream position.
            This offset might be used to calculate more accurate non-mixtime sync triggers (as with non-mixtime sync's a variable delay is to be expected, as the accuracy depends on the sync thread waking in time, and there is no guarantee when that will happen) - 
            as well as mixtime syncs are only accurate to the current update period, as they are triggered within such.
            So a mixtime sync is being triggered ahead of the actual mixer position being heard.
            The 'Offset' parameter might be used to compensate for that.
            </para>
            <para>
            When used on a decoding channel (eg. a mixer source channel), syncs set with <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> are automatically <see cref="F:ManagedBass.SyncFlags.Mixtime"/>, 
            which means that they will be triggered as soon as the sync event is encountered during decoding. 
            But if the mixer output is being played, then there is a playback buffer involved, which will delay the hearing of the sync event. 
            This function compensates for that, delaying the triggering of the sync until the event is actually heard. 
            If the mixer itself is a decoding channel, or the <see cref="F:ManagedBass.SyncFlags.Mixtime"/> flag is used, then there is effectively no real difference between this function and <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />.
            One sync type that is slightly different is the <see cref="F:ManagedBass.SyncFlags.Stalled"/> sync, which can be either mixtime or not.
            </para>
            <para>
            Sync types that would automatically be mixtime when using <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> are not so when using this function. 
            The <see cref="F:ManagedBass.SyncFlags.Mixtime"/> flag should be specified in those cases, or <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> used instead.
            </para>
            <para>
            When a source is removed from a mixer, any syncs that have been set on it via this function are automatically removed. 
            If the channel is subsequently plugged back into a mixer, the previous syncs will not still be set on it.
            Syncs set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> are unaffected.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle">The channel is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.Type">An illegal <paramref name="Type" /> was specified.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">An illegal <paramref name="Parameter" /> was specified.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelRemoveSync(System.Int32,System.Int32)">
            <summary>
            Removes a synchronizer from a mixer source channel.
            </summary>
            <param name="Handle">The mixer source channel handle (as returned by <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" />).</param>
            <param name="Sync">Handle of the synchronizer to remove (return value of a previous <see cref="M:ManagedBass.Mix.BassMix.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> call).</param>
            <returns>If succesful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>This function can only remove syncs that were set via <see cref="M:ManagedBass.Mix.BassMix.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />, not those that were set via <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" />.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle">At least one of <paramref name="Handle" /> and <paramref name="Sync" /> is not valid.</exception>        
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelGetEnvelopePosition(System.Int32,ManagedBass.Mix.MixEnvelope,System.Single@)">
            <summary>
            Retrieves the current position and value of an envelope on a channel.
            </summary>
            <param name="Handle">The mixer source channel handle (which was add via <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags)" /> or <see cref="M:ManagedBass.Mix.BassMix.MixerAddChannel(System.Int32,System.Int32,ManagedBass.BassFlags,System.Int64,System.Int64)" />) beforehand).</param>
            <param name="Type">The envelope to get the position/value of.</param>
            <param name="Value">A reference to a variable to receive the envelope value at the current position.</param>
            <returns>If successful, the current position of the envelope is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The envelope's current position is not necessarily what is currently being heard, due to buffering.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Type" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">There is no envelope of the requested type on the channel.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelSetEnvelopePosition(System.Int32,ManagedBass.Mix.MixEnvelope,System.Int64)">
            <summary>
            Sets the current position of an envelope on a channel.
            </summary>
            <param name="Handle">The mixer source channel handle.</param>
            <param name="Type">The envelope to set the position/value of.</param>
            <param name="Position">The new envelope position, in bytes. If this is beyond the end of the envelope it will be capped or looped, depending on whether the envelope has looping enabled.</param>
            <returns>If successful, the current position of the envelope is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            During playback, the effect of changes are not heard instantaneously, due to buffering. To reduce the delay, use the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> config option config option to reduce the buffer length.
            <para>
            Note: Envelopes deal in mixer positions, not sources!
            So when you are changing the source position (e.g. via <see cref="M:ManagedBass.Mix.BassMix.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> the envelope's positions doesn't change with it.
            You might use this method to align the envelope position accorting to the new source position
            .</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Type" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">There is no envelope of the requested type on the channel.</exception>
        </member>
        <member name="M:ManagedBass.Mix.BassMix.ChannelSetEnvelope(System.Int32,ManagedBass.Mix.MixEnvelope,ManagedBass.Mix.MixerNode[],System.Int32)">
            <summary>
            Sets an envelope to modify the sample rate, volume or pan of a channel over a period of time.
            </summary>
            <param name="Handle">The mixer source channel handle.</param>
            <param name="Type">The envelope to get the position/value of.</param>
            <param name="Nodes">The array of envelope nodes, which should have sequential positions.</param>
            <param name="Length">The number of elements in the nodes array... 0 = no envelope.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Envelopes are applied on top of the channel's attributes, as set via <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />. 
            In the case of <see cref="F:ManagedBass.Mix.MixEnvelope.Frequency"/> and <see cref="F:ManagedBass.Mix.MixEnvelope.Volume"/>, 
            the final sample rate and volume is a product of the channel attribute and the envelope. 
            While in the <see cref="F:ManagedBass.Mix.MixEnvelope.Pan"/> case, the final panning is a sum of the channel attribute and envelope.
            </para>
            <para>
            <see cref="M:ManagedBass.Mix.BassMix.ChannelGetEnvelopePosition(System.Int32,ManagedBass.Mix.MixEnvelope,System.Single@)" /> can be used to get the current envelope position, 
            and a <see cref="F:ManagedBass.SyncFlags.MixerEnvelope"/> sync can be set via <see cref="M:ManagedBass.Mix.BassMix.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> to be informed of when an envelope ends.
            The function can be called again from such a sync, in order to set a new envelope to follow the old one.
            </para>
            <para>
            Any previous envelope of the same type is replaced by the new envelope.
            A copy is made of the nodes array, so it does not need to persist beyond this function call.
            </para>
            <para>Note: Envelopes deal in mixer positions, not sources!
            You might use <see cref="M:ManagedBass.Mix.BassMix.ChannelSetEnvelopePosition(System.Int32,ManagedBass.Mix.MixEnvelope,System.Int64)" /> to adjust the envelope to a source channel position.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not plugged into a mixer.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Type" /> is not valid.</exception>
        </member>
        <member name="T:ManagedBass.Mix.MixEnvelope">
            <summary>
            Mixer envelope attribute types, used with <see cref="M:ManagedBass.Mix.BassMix.ChannelSetEnvelope(System.Int32,ManagedBass.Mix.MixEnvelope,ManagedBass.Mix.MixerNode[],System.Int32)" />, <see cref="M:ManagedBass.Mix.BassMix.ChannelGetEnvelopePosition(System.Int32,ManagedBass.Mix.MixEnvelope,System.Single@)" /> and <see cref="M:ManagedBass.Mix.BassMix.ChannelSetEnvelopePosition(System.Int32,ManagedBass.Mix.MixEnvelope,System.Int64)" /> to set/retrieve an envelope on a mixer source channel.
            </summary>
        </member>
        <member name="F:ManagedBass.Mix.MixEnvelope.Frequency">
            <summary>
            Sample rate.
            <para>Envelopes are applied on top of the channel's attributes.
            The final sample rate is the product of the channel attribute and the envelope.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Mix.MixEnvelope.Volume">
            <summary>
            Volume.
            <para>Envelopes are applied on top of the channel's attributes. 
            The final volume is the product of the channel attribute and the envelope.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Mix.MixEnvelope.Pan">
            <summary>
            Panning/Balance.
            <para>Envelopes are applied on top of the channel's attributes. 
            The final panning is a sum of the channel attribute and envelope.</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Mix.MixEnvelope.Loop">
            <summary>
            Loop the envelope (flag).
            </summary>
        </member>
        <member name="T:ManagedBass.Mix.MixerNode">
            <summary>
            Used with <see cref="M:ManagedBass.Mix.BassMix.ChannelSetEnvelope(System.Int32,ManagedBass.Mix.MixEnvelope,ManagedBass.Mix.MixerNode[],System.Int32)" /> to set an envelope on a mixer source channel.
            </summary>
            <remarks>
            <para>Envelopes are applied on top of the channel's attributes, as set via <see cref="M:ManagedBass.Bass.ChannelSetAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single)" />. 
            In the case of <see cref="F:ManagedBass.Mix.MixEnvelope.Frequency"/> and <see cref="F:ManagedBass.Mix.MixEnvelope.Volume"/>, 
            the final sample rate and volume is a product of the channel attribute and the envelope. 
            While in the <see cref="F:ManagedBass.Mix.MixEnvelope.Pan"/> case, the final panning is a sum of the channel attribute and envelope.</para>
            </remarks>
        </member>
        <member name="F:ManagedBass.Mix.MixerNode.Position">
            <summary>
            The postion of the node in bytes. This is based on the mixer's sample format, not the source channel's format!
            </summary>
            <remarks>Note: Envelopes deal with mixer positions, not sources!</remarks>
        </member>
        <member name="F:ManagedBass.Mix.MixerNode.Value">
            <summary>
            The envelope value at the position.
            </summary>
        </member>
        <member name="T:ManagedBass.Mix.SyncProcedureEx">
            <summary>
            User defined extended mixer synchronizer callback function (see <see cref="M:ManagedBass.Mix.BassMix.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.Mix.SyncProcedureEx,System.IntPtr)" /> for details).
            </summary>
            <param name="Handle">The sync handle that has occured (as returned by <see cref="M:ManagedBass.Mix.BassMix.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.Mix.SyncProcedureEx,System.IntPtr)" />).</param>
            <param name="Channel">The channel that the sync occured on (the mixer source channel).</param>
            <param name="Data">Additional data associated with the sync's occurance.</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.Mix.BassMix.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.Mix.SyncProcedureEx,System.IntPtr)" /> was called.</param>
            <param name="Offset">The offset in bytes containing the position of the sync occurrence within the update cycle converted to the mixer stream.</param>
            <remarks>
            <para>
            A sync callback function should be very quick as other syncs can't be processed until it has finished.
            Attribute slides (<see cref="M:ManagedBass.Bass.ChannelSlideAttribute(System.Int32,ManagedBass.ChannelAttribute,System.Single,System.Int32)" />) are also performed by the sync thread, so are also affected if a sync callback takes a long time.
            </para>
            <para>
            If the sync is a <see cref="F:ManagedBass.SyncFlags.Mixtime"/> sync, then depending on the sync type, the callback will be executed in the update thread.
            The <paramref name="Offset" /> specifies the position of the sync within the update buffer converted to the mixer stream position.
            Note that the <paramref name="Offset" /> is based on the mixer's sample format, so you'll need to convert that to the source's format if using the sync to trigger things on the source.
            </para>
            <para>
            The usual restrictions on which BASS functions can be called that apply to stream callbacks (<see cref="T:ManagedBass.StreamProcedure" />) also apply here. 
            It is also unsafe to call <see cref="M:ManagedBass.Bass.ChannelSetSync(System.Int32,ManagedBass.SyncFlags,System.Int64,ManagedBass.SyncProcedure,System.IntPtr)" /> on the same channel from a mixtime sync callback.
            <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> can be used in a mixtime sync to implement custom looping, eg. set a <see cref="F:ManagedBass.SyncFlags.Position"/> sync at the loop end position and seek to the loop start position in the callback.
            </para>
            </remarks>
        </member>
        <member name="T:ManagedBass.Midi.MidiEventsMode">
            <summary>
            The type of event data to apply, to be used with <see cref="M:ManagedBass.Midi.BassMidi.StreamEvents(System.Int32,ManagedBass.Midi.MidiEventsMode,System.IntPtr,System.Int32)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventsMode.Struct">
            <summary>
            An array of <see cref="T:ManagedBass.Midi.MidiEvent" /> structures (Default).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventsMode.Raw">
            <summary>
            Raw MIDI event data, as would be sent to a MIDI device. 
            Running status is supported.
            To overcome the 16 channel limit, the event data's channel information can optionally be overridden by adding the new channel number to this parameter, where +1 = the 1st channel.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventsMode.Sync">
            <summary>
            Trigger event syncs
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventsMode.NoRunningStatus">
            <summary>
            No running status
            </summary>
        </member>
        <member name="T:ManagedBass.Midi.MidiEventType">
            <summary>
            The MIDI event type, to be used with <see cref="M:ManagedBass.Midi.BassMidi.StreamEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,System.Int32)" /> or <see cref="M:ManagedBass.Midi.BassMidi.StreamGetEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType)" /> or <see cref="M:ManagedBass.Midi.BassMidi.CreateStream(ManagedBass.Midi.MidiEvent[],System.Int32,ManagedBass.BassFlags,System.Int32)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.End">
            <summary>
            Used with <see cref="M:ManagedBass.Midi.BassMidi.CreateStream(ManagedBass.Midi.MidiEvent[],System.Int32,ManagedBass.BassFlags,System.Int32)" /> to mark the end of the event array.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.None">
            <summary>
            No event.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Note">
            <summary>
            Press or release a key, or stop without sustain/decay.
            param : LOBYTE = key number (0-127, 60=middle C), HIBYTE = velocity (0=release, 1-127=press, 255=stop).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Program">
            <summary>
            Select the preset/instrument to use. Standard soundfont presets follow the
            General MIDI standard, and generally also include Roland GS variations in other banks (accessible via the <see cref="F:ManagedBass.Midi.MidiEventType.Bank"/> event).
            param : preset number (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChannelPressure">
            <summary>
            Set the channel pressure.
            param : pressure level (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Pitch">
            <summary>
            Set the pitch wheel.
            param : pitch wheel position (0-16383, 8192=normal/middle).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.PitchRange">
            <summary>
            Set pitch wheel range (MIDI RPN 0).
            param : range in semitones.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Drums">
            <summary>
            Set the percussion/drums channel switch. 
            The bank and program are reset to 0 when this changes.
            param : use drums? (0=no, 1=yes).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.FineTune">
            <summary>
            Set the fine tuning (MIDI RPN 1).
            param : finetune in cents (0-16383, 0=-100, 8192=normal, 16383=+100).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.CoarseTune">
            <summary>
            Set the coarse tuning (MIDI RPN 2).
            param : finetune in semitones (0-127, 0=-64, 64=normal, 127=+63).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.MasterVolume">
            <summary>
            Set the master volume.
            param : volume level (0-16383, 0=silent, 16363=normal/full).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Bank">
            <summary>
            Select the bank to use (MIDI controller 0).
            param : bank number (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Modulation">
            <summary>
            Set the modulation (MIDI controller 1).
            param : modulation level (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Volume">
            <summary>
            Set the volume (MIDI controller 7).
            param : volume level (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Pan">
            <summary>
            Set the pan position (MIDI controller 10).
            param : pan position (0-128, 0=left, 64=middle, 127=right, 128=random).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Expression">
            <summary>
            Set the expression (MIDI controller 11).
            param : expression level (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Sustain">
            <summary>
            Set the sustain switch (MIDI controller 64).
            param : enable sustain? (0-63=no, 64-127=yes).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.SoundOff">
            <summary>
            Stop all sounds (MIDI controller 120).
            param : not used.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Reset">
            <summary>
            Reset controllers (MIDI controller 121), that is modulation=0, expression=127,
            sustain=0, pitch wheel=8192, channel pressure=0.
            param : not used.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.NotesOff">
            <summary>
            Release all keys (MIDI controller 123).
            param : not used.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Portamento">
            <summary>
            Set the portamento switch (MIDI controller 65).
            param : enable portamento? (0-63=no, 64-127=yes).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.PortamentoTime">
            <summary>
            Set the portamento time (MIDI controller 5).
            param : portamento time (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.PortamentoNote">
            <summary>
            Set the portamento start key - the next note starts at this key (MIDI controller 84).
            param : key number (1-127, 60=middle C).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Mode">
            <summary>
            Set poly/mono mode (MIDI controllers 126 and 127).
            param : mode (0=poly, 1=mono).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Reverb">
            <summary>
            Set the reverb send level (MIDI controller 91).
            param : reverb level (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Chorus">
            <summary>
            Set the chorus send level (MIDI controller 93).
            param : chorus level (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.CutOff">
            <summary>
            Set the low-pass filter cutoff (MIDI controller 74, NRPN 120h).
            param : cutoff level (0-127, 0=-64, 64=normal, 127=+63).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Resonance">
            <summary>
            Set the low-pass filter resonance (MIDI controller 71, NRPN 121h).
            param : resonance level (0-127, 0=-64, 64=normal, 127=+63).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Release">
            <summary>
            Set the release time (MIDI controller 72, NRPN 166h).
            param : release time (0-127, 0=-64, 64=normal, 127=+63).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Attack">
            <summary>
            Set the attack time (MIDI controller 73, NRPN 163h).
            param : attack time (0-127, 0=-64, 64=normal, 127=+63).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ReverbMacro">
            <summary>
            To be defined.
            param : to be defined.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChorusMacro">
            <summary>
            To be defined.
            param : to be defined.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ReverbTime">
            <summary>
            Set the reverb time.
            param : reverb time in milliseconds.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ReverbDelay">
            <summary>
            Set the reverb delay.
            param : reverb delay in millisecond 10ths.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ReverbLowPassCutOff">
            <summary>
            Set the reverb low-pass cutoff.
            param : reverb low-pass cutoff in hertz (0=off).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ReverbHighPassCutOff">
            <summary>
            Set the reverb high-pass cutoff.
            param : reverb high-pass cutoff in hertz (0=off).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ReverbLevel">
            <summary>
            Set the reverb level.
            param : reverb level (0=off, 100=0dB, 200=+6dB).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChorusDelay">
            <summary>
            Set the chorus delay.
            param : chorus delay in millisecond 10ths.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChorusDepth">
            <summary>
            Set the chorus depth.
            param : chorus depth in millisecond 10ths.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChorusRate">
            <summary>
            Set the chorus rate.
            param : chorus rate in hertz 100ths.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChorusFeedback">
            <summary>
            Set the chorus feedback level.
            param : chorus feedback level (0=-100%, 100=off, 200=+100%).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChorusLevel">
            <summary>
            Set the chorus level.
            param : chorus level (0=off, 100=0dB, 200=+6dB).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChorusReverb">
            <summary>
            Set the chorus send to reverb level.
            param : chorus send to reverb level (0=off, 100=0dB, 200=+6dB).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.DrumFineTune">
            <summary>
            Set the fine tuning of a drum key (MIDI NRPN 19knh).
            param : LOBYTE = key number (0-127), HIBYTE = finetune in cents (0-127, 0=-100, 64=normal, 127=+100).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.DrumCoarseTune">
            <summary>
            Set the coarse tuning of a drum key (MIDI NRPN 18knh).
            param : LOBYTE = key number (0-127), HIBYTE = finetune in semitones (0-127, 0=-64, 64=normal, 127=+63).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.DrumPan">
            <summary>
            Set the pan position of a drum key (MIDI NRPN 1Cknh).
            param : LOBYTE = key number (0-127), HIBYTE = pan position (0-127, 0=random, 64=middle).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.DrumReverb">
            <summary>
            Set the reverb send level of a drum key (MIDI NRPN 1Dknh).
            param : LOBYTE = key number (0-127), HIBYTE = reverb level (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.DrumChorus">
            <summary>
            Set the chorus send level of a drum key (MIDI NRPN 1Eknh).
            param : LOBYTE = key number (0-127), HIBYTE = chorus level (0-127).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.DrumCutOff">
            <summary>
            Set the low-pass filter cutoff of a drum key (MIDI NRPN 14knh).
            param : LOBYTE = key number (0-127), HIBYTE = cutoff level (0-127, 0=-64, 64=normal, 127=+63).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.DrumResonance">
            <summary>
            Set the low-pass filter resonance of a drum key (MIDI NRPN 15knh).
            param : LOBYTE = key number (0-127), HIBYTE = resonance level (0-127, 0=-64, 64=normal, 127=+63).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.DrumLevel">
            <summary>
            Set the drum level NRPN of a drum key (MIDI NRPN 16knh).
            param : LOBYTE = key number (0-127), HIBYTE = level (0-127, 127=full/normal).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Soft">
            <summary>
            Set the soft pedal/switch (MIDI controller 67).
            param : soft is on? (0-63=no, 64-127=yes).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.System">
            <summary>
            Set the system mode, resetting everything to the system's defaults.
            <see cref="F:ManagedBass.Midi.MidiSystem.Default"/> is identical to <see cref="F:ManagedBass.Midi.MidiSystem.GS"/>, except that channel 10 is melodic if there are not 16 channels.
            This does not reset things in any additional channels allocated to a MIDI file stream via the <see cref="F:ManagedBass.ChannelAttribute.MidiChannels"/> attribute,
            while <see cref="F:ManagedBass.Midi.MidiEventType.SystemEx"/> does.
            param : system mode (see <see cref="T:ManagedBass.Midi.MidiSystem"/>).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Tempo">
            <summary>
            Set the tempo (MIDI meta event 81).
            Changing the tempo affects the stream Length, and the <see cref="M:ManagedBass.Bass.ChannelGetLength(System.Int32,ManagedBass.PositionFlags)"/> value will no longer be valid.
            param : tempo in microseconds per quarter note.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ScaleTuning">
            <summary>
            Set the tuning of a note in every octave.
            param : LOWORD = tuning change in cents (0-16383, 0=-100, 8192=normal, 16383=+100), HIWORD = note (0-11, 0=C).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Control">
            <summary>
            Control event.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChangePresetVibrato">
            <summary>
            Change Preset Vibrato.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChangePresetPitch">
            <summary>
            Change Preset Pitch.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChangePresetFilter">
            <summary>
            Change Preset Filter.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ChangePresetVolume">
            <summary>
            Change Preset Volume.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.ModRange">
            <summary>
            Mod Range.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.BankLSB">
            <summary>
            Bank LSB.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Level">
            <summary>
            Set the level.
            param : the level (0=silent, 100=0dB, 200=+6dB).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.Transpose">
            <summary>
            Transpose all notes. 
            Changes take effect from the next note played, and affect melodic channels only (not drum channels).
            param : transposition amount in semitones (0=-100, 100=normal, 200=+100).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.SystemEx">
            <summary>
            Set the system mode, resetting everything to the system's defaults. 
            <see cref="F:ManagedBass.Midi.MidiSystem.Default"/> is identical to <see cref="F:ManagedBass.Midi.MidiSystem.GS"/>, except that channel 10 is melodic if there are not 16 channels.
            <see cref="F:ManagedBass.Midi.MidiEventType.System"/> does not reset things in any additional channels allocated to a MIDI file stream 
            via the <see cref="F:ManagedBass.ChannelAttribute.MidiChannels"/> attribute, while this does.
            param : system mode (see <see cref="T:ManagedBass.Midi.MidiSystem"/>).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.EndTrack">
            <summary>
            Used with <see cref="M:ManagedBass.Midi.BassMidi.CreateStream(ManagedBass.Midi.MidiEvent[],System.Int32,ManagedBass.BassFlags,System.Int32)"/> to mark the end of a track (the next event will be in a new track).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEventType.NoRunningStatus">
            <summary>
            Flag: no running status.
            </summary>
        </member>
        <member name="T:ManagedBass.Midi.MidiMarkerType">
            <summary>
            The Marker type, to be used with <see cref="M:ManagedBass.Midi.BassMidi.StreamGetMark(System.Int32,ManagedBass.Midi.MidiMarkerType,System.Int32,ManagedBass.Midi.MidiMarker@)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiMarkerType.Marker">
            <summary>
            Marker events (MIDI meta event 6).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiMarkerType.CuePoint">
            <summary>
            Cue events (MIDI meta event 7).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiMarkerType.Lyric">
            <summary>
            Lyric events (MIDI meta event 5).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiMarkerType.Text">
            <summary>
            Text events (MIDI meta event 1).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiMarkerType.TimeSignature">
            <summary>
            Time signature event (MIDI meta event 88).
            The time signature events are given in the form of "numerator/denominator metronome-pulse 32nd-notes-per-MIDI-quarter-note", eg. "4/4 24 8".
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiMarkerType.KeySignature">
            <summary>
            Key signature events (MIDI meta event 89).
            That gives the key signature (in <see cref="P:ManagedBass.Midi.MidiMarker.Text"/>) in the form of "a b", where "a" is the number of sharps (if positive) or flats (if negative) and "b" signifies major (if 0) or minor (if 1).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiMarkerType.Copyright">
            <summary>
            Copyright notice (MIDI meta event 2).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiMarkerType.TrackName">
            <summary>
            Track name events (MIDI meta event 3).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiMarkerType.InstrumentName">
            <summary>
            Instrument name events (MIDI meta event 4). 
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiMarkerType.Tick">
            <summary>
            FLAG: get position in ticks instead of bytes
            </summary>
        </member>
        <member name="T:ManagedBass.Midi.MidiSystem">
            <summary>
            System mode parameter, to be used with <see cref="F:ManagedBass.Midi.MidiEventType.System" />, <see cref="F:ManagedBass.Midi.MidiEventType.SystemEx" />.
            </summary>
            <remarks>
            <see cref="F:ManagedBass.Midi.MidiSystem.Default"/> is identical to <see cref="F:ManagedBass.Midi.MidiSystem.GS"/>, except that channel 10 is melodic if there are not 16 channels.
            </remarks>
        </member>
        <member name="F:ManagedBass.Midi.MidiSystem.Default">
            <summary>
            System default. 
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiSystem.GM1">
            <summary>
            General MIDI Level 1.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiSystem.GM2">
            <summary>
            General MIDI Level 2.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiSystem.XG">
            <summary>
            XG-Format (Yamaha).
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiSystem.GS">
            <summary>
            GS-Format (Roland).
            </summary>
        </member>
        <member name="T:ManagedBass.Midi.BassMidi">
            <summary>
            Wraps BassMidi: bassmidi.dll
            
            <para>Supports: .midi, .mid, .rmi, .kar</para>
            </summary>
            <summary>
            Wraps BassMidi: bassmidi.dll
            
            <para>Supports: .midi, .mid, .rmi, .kar</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.BassMidi.ChorusChannel">
            <summary>
            Chorus Mix Channel.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.BassMidi.ReverbChannel">
            <summary>
            Reverb Mix Channel.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.BassMidi.UserFXChannel">
            <summary>
            User FX Channel.
            </summary>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.CreateStream(System.Int32,ManagedBass.BassFlags,System.Int32)">
            <summary>
            Creates a sample stream to render real-time MIDI events.
            </summary>
            <param name="Channels">The number of MIDI channels: 1 (min) - 128 (max).</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Frequency">Sample rate (in Hz) to render/play the MIDI at (0 = the rate specified in the <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> call; 1 = the device's current output rate or the <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/> rate if that is not available).</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            This function creates a stream solely for real-time MIDI events.
            As it's not based on any file, the stream has no predetermined length and is never-ending.
            Seeking isn't possible, but it is possible to reset everything, including playback buffer, by calling <see cref="M:ManagedBass.Bass.ChannelPlay(System.Int32,System.Boolean)" /> (Restart = <see langword="true" />) or <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" /> (Position = 0).
            </para>
            <para>
            MIDI events are applied using the <see cref="M:ManagedBass.Midi.BassMidi.StreamEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,System.Int32)" /> function.
            If the stream is being played (it's not a decoding channel), then there will be some delay in the effect of the events being heard. 
            This latency can be reduced by making use of the <see cref="P:ManagedBass.Bass.PlaybackBufferLength" /> and <see cref="P:ManagedBass.Bass.UpdatePeriod" /> options.
            </para>
            <para>
            If a stream has 16 MIDI channels, then channel 10 defaults to percussion/drums and the rest melodic, otherwise they are all melodic.
            That can be changed using <see cref="M:ManagedBass.Midi.BassMidi.StreamEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,System.Int32)" /> and <see cref="F:ManagedBass.Midi.MidiEventType.Drums"/>.
            </para>
            <para>
            Soundfonts provide the sounds that are used to render a MIDI stream.
            A default soundfont configuration is applied initially to the new MIDI stream, which can subsequently be overriden using <see cref="M:ManagedBass.Midi.BassMidi.StreamSetFonts(System.Int32,ManagedBass.Midi.MidiFont[],System.Int32)" />.
            </para>
            <para>To play a MIDI file, use <see cref="M:ManagedBass.Midi.BassMidi.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags,System.Int32)" />.</para>
            <para><b>Platform-specific</b></para>
            <para>
            On Android and iOS, sinc interpolation requires a NEON-supporting CPU; the <see cref="F:ManagedBass.BassFlags.SincInterpolation"/> flag will otherwise be ignored.
            Sinc interpolation is not available on Windows CE.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding channels (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/>. The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is also unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Channels" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified Speaker Flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.CreateStream(ManagedBass.Midi.MidiEvent[],System.Int32,ManagedBass.BassFlags,System.Int32)">
            <summary>
            Creates a sample stream from a sequence of MIDI events.
            </summary>
            <param name="Events">An array of <see cref="T:ManagedBass.Midi.MidiEvent" />s containing the event sequence to play (the array should be terminated with a <see cref="F:ManagedBass.Midi.MidiEventType.End"/> event).</param>
            <param name="PulsesPerQuarterNote">The number of pulses per quarter note (or ticks per beat) value of the MIDI stream to create.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <param name="Frequency">Sample rate to render/play the MIDI at (0 = the rate specified in the <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> call; 1 = the device's current output rate (or the <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)"/> BASS_Init rate if that is not available).</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            This function creates a 16 channel MIDI stream to play a predefined sequence of MIDI events.
            Any of the standard MIDI events can be used, but <see cref="F:ManagedBass.Midi.MidiEventType.Level"/>, <see cref="F:ManagedBass.Midi.MidiEventType.Transpose"/>, and <see cref="F:ManagedBass.Midi.MidiEventType.SystemEx"/> events are not available and will be ignored.
            The sequence should end with a <see cref="F:ManagedBass.Midi.MidiEventType.End"/> event.
            Multiple tracks are possible via the <see cref="F:ManagedBass.Midi.MidiEventType.EndTrack"/> event, which signals the end of a track; the next event will be in a new track.
            Any <see cref="F:ManagedBass.Midi.MidiEventType.Tempo"/> events should be in the first track.
            </para>
            <para>The event sequence is copied, so the events array does not need to persist beyond the function call.</para>
            <para>
            Soundfonts provide the sounds that are used to render a MIDI stream.
            A default soundfont configuration is applied initially to the new MIDI stream, which can subsequently be overridden using <see cref="M:ManagedBass.Midi.BassMidi.StreamSetFonts(System.Int32,ManagedBass.Midi.MidiFont[],System.Int32)" />.
            </para>
            <para><b>Platform-specific</b></para>
            <para>
            On Android and iOS, sinc interpolation requires a NEON-supporting CPU; the <see cref="F:ManagedBass.BassFlags.SincInterpolation"/> flag will otherwise be ignored.
            Sinc interpolation is not available on Windows CE.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">Only decoding channels (<see cref="F:ManagedBass.BassFlags.Decode"/>) are allowed when using the <see cref="F:ManagedBass.Bass.NoSoundDevice"/>. The <see cref="F:ManagedBass.BassFlags.AutoFree"/> flag is also unavailable to decoding channels.</exception>
            <exception cref="F:ManagedBass.Errors.NoInternet">No internet connection could be opened. Can be caused by a bad <see cref="P:ManagedBass.Bass.NetProxy"/> setting.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Events" /> are not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Timeout">The server did not respond to the request within the timeout period, as set with the <see cref="P:ManagedBass.Bass.NetTimeOut"/> config option.</exception>
            <exception cref="F:ManagedBass.Errors.FileOpen">The file could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The file's format is not recognised/supported.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The sample format is not supported by the device/drivers. If the stream is more than stereo or the <see cref="F:ManagedBass.BassFlags.Float"/> flag is used, it could be that they are not supported.</exception>
            <exception cref="F:ManagedBass.Errors.Speaker">The specified Speaker Flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</exception>
            <exception cref="F:ManagedBass.Errors.Memory">There is insufficient memory.</exception>
            <exception cref="F:ManagedBass.Errors.No3D">Could not initialize 3D support.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,System.Int32)">
            <summary>
            Applies an event to a MIDI stream.
            </summary>
            <param name="Handle">The MIDI stream to apply the event to (as returned by <see cref="M:ManagedBass.Midi.BassMidi.CreateStream(System.Int32,ManagedBass.BassFlags,System.Int32)" />).</param>
            <param name="Channel">The MIDI channel to apply the event to... 0 = channel 1.</param>
            <param name="Event">The event to apply (see <see cref="T:ManagedBass.Midi.MidiEventType" /> for details).</param>
            <param name="Parameter">The event parameter (see <see cref="T:ManagedBass.Midi.MidiEventType" /> for details).</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>Apart from the "global" events, all events apply only to the specified MIDI channel.</para>
            <para>
            Except for the "non-MIDI" events, events applied to a MIDI file stream can subsequently be overridden by events in the file itself, and will also be overridden when seeking or looping.
            That can be avoided by using additional channels, allocated via the <see cref="F:ManagedBass.ChannelAttribute.MidiChannels"/> attribute.
            </para>
            <para>
            Event syncs (see <see cref="T:ManagedBass.SyncFlags" />) are not triggered by this function.
            If sync triggering is wanted, <see cref="M:ManagedBass.Midi.BassMidi.StreamEvents(System.Int32,ManagedBass.Midi.MidiEventsMode,ManagedBass.Midi.MidiEvent[],System.Int32)" /> can be used instead.
            </para>
            <para>
            If the MIDI stream is being played (it's not a decoding channel), then there will be some delay in the effect of the event being heard. 
            This latency can be reduced by making use of the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> and <see cref="P:ManagedBass.Bass.UpdatePeriod"/> config options when creating the stream.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">One of the other parameters is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,System.Byte,System.Byte)">
            <summary>
            Applies an event to a MIDI stream.
            </summary>
            <param name="Handle">The MIDI stream to apply the event to (as returned by <see cref="M:ManagedBass.Midi.BassMidi.CreateStream(System.Int32,ManagedBass.BassFlags,System.Int32)" />).</param>
            <param name="Channel">The MIDI channel to apply the event to... 0 = channel 1.</param>
            <param name="Event">The event to apply (see <see cref="T:ManagedBass.Midi.MidiEventType" /> for details).</param>
            <param name="LowParameter">The event parameter (LOBYTE), (see <see cref="T:ManagedBass.Midi.MidiEventType" /> for details).</param>
            <param name="HighParameter">The event parameter (HIBYTE), (see <see cref="T:ManagedBass.Midi.MidiEventType" /> for details).</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>Apart from the "global" events, all events apply only to the specified MIDI channel.</para>
            <para>
            Except for the "non-MIDI" events, events applied to a MIDI file stream can subsequently be overridden by events in the file itself, and will also be overridden when seeking or looping.
            That can be avoided by using additional channels, allocated via the <see cref="F:ManagedBass.ChannelAttribute.MidiChannels"/> attribute.
            </para>
            <para>
            Event syncs (see <see cref="T:ManagedBass.SyncFlags" />) are not triggered by this function.
            If sync triggering is wanted, <see cref="M:ManagedBass.Midi.BassMidi.StreamEvents(System.Int32,ManagedBass.Midi.MidiEventsMode,ManagedBass.Midi.MidiEvent[],System.Int32)" /> can be used instead.
            </para>
            <para>
            If the MIDI stream is being played (it's not a decoding channel), then there will be some delay in the effect of the event being heard. 
            This latency can be reduced by making use of the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> and <see cref="P:ManagedBass.Bass.UpdatePeriod"/> config options when creating the stream.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">One of the other parameters is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamEvents(System.Int32,ManagedBass.Midi.MidiEventsMode,System.IntPtr,System.Int32)">
            <summary>
            Applies any number of events to a MIDI stream.
            </summary>
            <param name="Handle">The MIDI stream to apply the events to.</param>
            <param name="Mode">Midi Events Mode.</param>
            <param name="Events">The event data (raw data - byte[]).</param>
            <param name="Length">Length of Events data according to <paramref name="Mode"/>.</param>
            <returns>If successful, the number of events processed is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Events applied to a MIDI file stream can subsequently be overridden by events in the file itself, and will also be overridden when seeking or looping.
            That can be avoided by using additional channels, allocated via the <see cref="F:ManagedBass.ChannelAttribute.MidiChannels" /> attribute.
            </para>
            <para>
            If the MIDI stream is being played (it's not a decoding channel), then there will be some delay in the effect of the event being heard. 
            This latency can be reduced by making use of the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> and <see cref="P:ManagedBass.Bass.UpdatePeriod"/> config options when creating the stream.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Mode"/> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamEvents(System.Int32,ManagedBass.Midi.MidiEventsMode,ManagedBass.Midi.MidiEvent[],System.Int32)">
            <summary>
            Applies any number of events to a MIDI stream.
            </summary>
            <param name="Handle">The MIDI stream to apply the events to.</param>
            <param name="Mode">Midi Events Mode.</param>
            <param name="Events">The event data (an array of <see cref="T:ManagedBass.Midi.MidiEvent" /> structures).</param>
            <param name="Length">No of <see cref="T:ManagedBass.Midi.MidiEvent"/> items... 0 = No of items in <paramref name="Events"/> array.</param>
            <returns>If successful, the number of events processed is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Events applied to a MIDI file stream can subsequently be overridden by events in the file itself, and will also be overridden when seeking or looping.
            That can be avoided by using additional channels, allocated via the <see cref="F:ManagedBass.ChannelAttribute.MidiChannels" /> attribute.
            </para>
            <para>
            If the MIDI stream is being played (it's not a decoding channel), then there will be some delay in the effect of the event being heard. 
            This latency can be reduced by making use of the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> and <see cref="P:ManagedBass.Bass.UpdatePeriod"/> config options when creating the stream.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Mode"/> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamEvents(System.Int32,ManagedBass.Midi.MidiEventsMode,System.Byte[],System.Int32)">
            <summary>
            Applies any number of events to a MIDI stream.
            </summary>
            <param name="Handle">The MIDI stream to apply the events to.</param>
            <param name="Mode">Midi Events Mode.</param>
            <param name="Raw">The event data (raw data - byte[]).</param>
            <param name="Length">No of <see cref="T:System.Byte"/>s... 0 = No of items in <paramref name="Raw"/> array.</param>
            <returns>If successful, the number of events processed is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Events applied to a MIDI file stream can subsequently be overridden by events in the file itself, and will also be overridden when seeking or looping.
            That can be avoided by using additional channels, allocated via the <see cref="F:ManagedBass.ChannelAttribute.MidiChannels" /> attribute.
            </para>
            <para>
            If the MIDI stream is being played (it's not a decoding channel), then there will be some delay in the effect of the event being heard. 
            This latency can be reduced by making use of the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> and <see cref="P:ManagedBass.Bass.UpdatePeriod"/> config options when creating the stream.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Mode"/> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamEvents(System.Int32,ManagedBass.Midi.MidiEventsMode,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Applies any number of events to a MIDI stream.
            </summary>
            <param name="Handle">The MIDI stream to apply the events to.</param>
            <param name="Mode">Midi Events Mode.</param>
            <param name="Channel">To overcome the 16 channel limit, the event data's channel information can optionally be overridden by adding the new channel number to this parameter, where 1 = the 1st channel - else leave to 0.</param>
            <param name="Raw">The event data (raw data - byte[]).</param>
            <param name="Length">No of <see cref="T:System.Byte"/>s... 0 = No of items in <paramref name="Raw"/> array.</param>
            <returns>If successful, the number of events processed is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Events applied to a MIDI file stream can subsequently be overridden by events in the file itself, and will also be overridden when seeking or looping.
            That can be avoided by using additional channels, allocated via the <see cref="F:ManagedBass.ChannelAttribute.MidiChannels" /> attribute.
            </para>
            <para>
            If the MIDI stream is being played (it's not a decoding channel), then there will be some delay in the effect of the event being heard. 
            This latency can be reduced by making use of the <see cref="P:ManagedBass.Bass.PlaybackBufferLength"/> and <see cref="P:ManagedBass.Bass.UpdatePeriod"/> config options when creating the stream.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle"/> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Mode"/> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetChannel(System.Int32,System.Int32)">
            <summary>
            Gets a HSTREAM handle for a MIDI channel (e.g. to set DSP/FX on individual MIDI channels).
            </summary>
            <param name="Handle">The midi stream to get a channel from.</param>
            <param name="Channel">The MIDI channel... 0 = channel 1. Or one of the following special channels:
            <para><see cref="F:ManagedBass.Midi.BassMidi.ChorusChannel"/> = Chorus mix channel. The default chorus processing is replaced by the stream's processing.</para>
            <para><see cref="F:ManagedBass.Midi.BassMidi.ReverbChannel"/> = Reverb mix channel. The default reverb processing is replaced by the stream's processing.</para>
            <para><see cref="F:ManagedBass.Midi.BassMidi.UserFXChannel"/> = User effect mix channel.</para>
            </param>
            <returns>If successful, the channel handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            By default, MIDI channels do not have streams assigned to them;
            a MIDI channel only gets a stream when this function is called, which it then keeps until the MIDI stream is freed. 
            MIDI channel streams can also be freed before then via <see cref="M:ManagedBass.Bass.StreamFree(System.Int32)" />.
            Each MIDI channel stream increases the CPU usage slightly, even if there are no DSP/FX set on them, so for optimal performance they should not be activated when unnecessary.
            </para>
            <para>
            The MIDI channel streams have a different path to the final mix than the BASSMIDI reverb/chorus processing, which means that the reverb/chorus will not be present in the data received by any DSP/FX set on the streams and nor will the reverb/chorus be applied to the DSP/FX output; 
            the reverb/chorus processing will use the channel's original data.
            </para>
            <para>
            The MIDI channel streams can only be used to set DSP/FX on the channels. 
            They cannot be used with <see cref="M:ManagedBass.Bass.ChannelGetData(System.Int32,System.IntPtr,System.Int32)" /> or <see cref="M:ManagedBass.Bass.ChannelGetLevel(System.Int32)" /> to visualise the channels, for example, 
            but that could be achieved via a DSP function instead.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable"><paramref name="Channel" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType)">
            <summary>
            Retrieves the current value of an event in a MIDI stream channel.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the event from (as returned by <see cref="M:ManagedBass.Midi.BassMidi.CreateStream(System.Int32,ManagedBass.BassFlags,System.Int32)"/>.</param>
            <param name="Channel">The MIDI channel to get the event value from... 0 = channel 1.</param>
            <param name="Event">
            The event value to retrieve.
            With the drum key events (<see cref="F:ManagedBass.Midi.MidiEventType.DrumCutOff"/>/etc) and the <see cref="F:ManagedBass.Midi.MidiEventType.Note"/> and <see cref="F:ManagedBass.Midi.MidiEventType.ScaleTuning"/> events, the HIWORD can be used to specify which key/note to get the value from.</param>
            <returns>The event parameter if successful - else -1 (use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code).</returns>
            <remarks>SYNCs can be used to be informed of when event values change.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">One of the other parameters is invalid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetEvents(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,ManagedBass.Midi.MidiEvent[])">
            <summary>
            Retrieves the events in a MIDI file stream.
            </summary>
            <param name="Handle">The MIDI stream to get the events from.</param>
            <param name="Track">The track to get the events from... 0 = 1st track.</param>
            <param name="Filter">The type of event to retrieve (use <see cref="F:ManagedBass.Midi.MidiEventType.None"/> to retrieve all events).</param>
            <param name="Events">An array of <see cref="T:ManagedBass.Midi.MidiEvent" />s to retrieve the events (<see langword="null" /> = get the number of events without getting the events themselves).</param>
            <returns>If successful, the number of events is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function should first be called with <paramref name="Events" /> = <see langword="null" /> to get the number of events, before allocating an array of the required size and retrieving the events.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is for real-time events only, so does not have an event sequence.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Track" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetEvents(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType)">
            <summary>
            Retrieves the events in a MIDI file stream.
            </summary>
            <param name="Handle">The MIDI stream to get the events from.</param>
            <param name="Track">The track to get the events from... 0 = 1st track.</param>
            <param name="Filter">The type of event to retrieve (use <see cref="F:ManagedBass.Midi.MidiEventType.None"/> to retrieve all events).</param>
            <returns>An array of <see cref="T:ManagedBass.Midi.MidiEvent" /> configuration entries on success, <see langword="null" /> on error.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is for real-time events only, so does not have an event sequence.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Track" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetFonts(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Retrieves the soundfont configuration of a MIDI stream, or the default soundfont configuration.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the soundfont configuration of... 0 = get default soundfont configuration.</param>
            <param name="Fonts">An <see cref="T:System.IntPtr"/> to retrieve the soundfont configuration.</param>
            <param name="Count">The maximum number of elements to retrieve. This and fonts can be 0, to get the number of elements in the soundfont configuration.</param>
            <returns>If successful, the number of soundfonts in the configuration (which can be higher than count) is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>When a soundfont matching the MIDI file is loaded, it will be the first element in the returned configuration.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetFonts(System.Int32,ManagedBass.Midi.MidiFont[],System.Int32)">
            <summary>
            Retrieves the soundfont configuration of a MIDI stream, or the default soundfont configuration.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the soundfont configuration of... 0 = get default soundfont configuration.</param>
            <param name="Fonts">An array to retrieve the soundfont configuration.</param>
            <param name="Count">The maximum number of elements to retrieve in the fonts array. This and fonts can be 0, to get the number of elements in the soundfont configuration.</param>
            <returns>If successful, the number of soundfonts in the configuration (which can be higher than count) is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>When a soundfont matching the MIDI file is loaded, it will be the first element in the returned configuration.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetFonts(System.Int32)">
            <summary>
            Retrieves the soundfont configuration of a MIDI stream, or the default soundfont configuration.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the soundfont configuration of... 0 = get default soundfont configuration.</param>
            <returns>An array of <see cref="T:ManagedBass.Midi.MidiFont" /> configuration entries if successfull - or <see langword="null" /> on error.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetFonts(System.Int32,ManagedBass.Midi.MidiFontEx[],System.Int32)">
            <summary>
            Retrieves the soundfont configuration of a MIDI stream, or the default soundfont configuration.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the soundfont configuration of... 0 = get default soundfont configuration.</param>
            <param name="Fonts">An array to retrieve the soundfont configuration.</param>
            <param name="Count">The maximum number of elements to retrieve in the fonts array. This and fonts can be 0, to get the number of elements in the soundfont configuration.</param>
            <returns>If successful, the number of soundfonts in the configuration (which can be higher than count) is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>When a soundfont matching the MIDI file is loaded, it will be the first element in the returned configuration.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetFontsEx(System.Int32)">
            <summary>
            Retrieves the soundfont configuration of a MIDI stream, or the default soundfont configuration.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the soundfont configuration of... 0 = get default soundfont configuration.</param>
            <returns>An array of <see cref="T:ManagedBass.Midi.MidiFontEx" /> configuration entries if successfull - or <see langword="null" /> on error.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetFontsCount(System.Int32)">
            <summary>
            Retrieves the number of elements in the soundfont configuration.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the soundfont configuration of... 0 = get default soundfont configuration.</param>
            <returns>If successful, the number of soundfonts in the configuration is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetMark(System.Int32,ManagedBass.Midi.MidiMarkerType,System.Int32,ManagedBass.Midi.MidiMarker@)">
            <summary>
            Retrieves a marker from a MIDI stream.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the marker from.</param>
            <param name="Type">The type of marker to retrieve.</param>
            <param name="Index">The marker to retrieve... 0 = the first.</param>
            <param name="Mark">The <see cref="T:ManagedBass.Midi.MidiMarker" /> structure to receive the marker details into.</param>
            <returns><see langword="true" /> on success, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The markers are ordered chronologically.
            <para>Syncs can be used to be informed of when markers are encountered during playback.</para>
            <para>
            If a lyric marker text begins with a '/' (slash) character, that means a new line should be started.
            If the text begins with a '\' (backslash) character, the display should be cleared. 
            Lyrics can sometimes be found in <see cref="F:ManagedBass.Midi.MidiMarkerType.Text"/> instead of <see cref="F:ManagedBass.Midi.MidiMarkerType.Lyric"/> markers.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Type" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Index" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetMark(System.Int32,ManagedBass.Midi.MidiMarkerType,System.Int32)">
            <summary>
            Retrieves a marker from a MIDI stream.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the marker from.</param>
            <param name="Type">The type of marker to retrieve.</param>
            <param name="Index">The marker to retrieve... 0 = the first.</param>
            <returns>On success, an instance of the <see cref="T:ManagedBass.Midi.MidiMarker" /> structure is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            The markers are ordered chronologically.
            <para>Syncs can be used to be informed of when markers are encountered during playback.</para>
            <para>
            If a lyric marker text begins with a '/' (slash) character, that means a new line should be started.
            If the text begins with a '\' (backslash) character, the display should be cleared. 
            Lyrics can sometimes be found in <see cref="F:ManagedBass.Midi.MidiMarkerType.Text"/> instead of <see cref="F:ManagedBass.Midi.MidiMarkerType.Lyric"/> markers.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Type" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Index" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetMarks(System.Int32,System.Int32,ManagedBass.Midi.MidiMarkerType,ManagedBass.Midi.MidiMarker[])">
            <summary>
            Retrieves the markers in a MIDI file stream.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the markers from.</param>
            <param name="Track">The track to get the markers from... 0 = 1st track, -1 = all tracks.</param>
            <param name="Type">The type of marker to retrieve.</param>
            <param name="Marks">An array of <see cref="T:ManagedBass.Midi.MidiMarker"/>s to receive the data into. Can be null to get the no of markers.</param>
            <returns>No of markers in the array on success, -1 on failure. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>The markers are ordered chronologically, and by track number (lowest first) if multiple markers have the same position.</para>
            <para>SYNCs can be used to be informed of when markers are encountered during playback.</para>
            <para>
            If a lyric marker text begins with a / (slash) character, that means a new line should be started.
            If the text begins with a \ (backslash) character, the display should be cleared.
            Lyrics can sometimes be found in <see cref="F:ManagedBass.Midi.MidiMarkerType.Text"/> instead of <see cref="F:ManagedBass.Midi.MidiMarkerType.Lyric"/> markers.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Type" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Track" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamGetMarks(System.Int32,System.Int32,ManagedBass.Midi.MidiMarkerType)">
            <summary>
            Retrieves the markers in a MIDI file stream.
            </summary>
            <param name="Handle">The MIDI stream to retrieve the markers from.</param>
            <param name="Track">The track to get the markers from... 0 = 1st track, -1 = all tracks.</param>
            <param name="Type">The type of marker to retrieve.</param>
            <returns>On success, an array of <see cref="T:ManagedBass.Midi.MidiMarker" /> instances is returned, else <see langword="null" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>The markers are ordered chronologically, and by track number (lowest first) if multiple markers have the same position.</para>
            <para>SYNCs can be used to be informed of when markers are encountered during playback.</para>
            <para>
            If a lyric marker text begins with a / (slash) character, that means a new line should be started.
            If the text begins with a \ (backslash) character, the display should be cleared.
            Lyrics can sometimes be found in <see cref="F:ManagedBass.Midi.MidiMarkerType.Text"/> instead of <see cref="F:ManagedBass.Midi.MidiMarkerType.Lyric"/> markers.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Type"><paramref name="Type" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter"><paramref name="Track" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamLoadSamples(System.Int32)">
            <summary>
            Preloads the samples required by a MIDI file stream.
            </summary>
            <param name="Handle">The MIDI stream handle.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Samples are normally loaded as they are needed while rendering a MIDI stream, which can result in CPU spikes, particularly with packed soundfonts.
            That generally won't cause any problems, but when smooth/constant performance is critical this function can be used to preload the samples before rendering, so avoiding the need to load them while rendering.
            </para>
            <para>Preloaded samples can be compacted/unloaded just like any other samples, so it is probably wise to disable the <see cref="P:ManagedBass.Midi.BassMidi.Compact"/> option when preloading samples, to avoid any chance of the samples subsequently being automatically unloaded.</para>
            <para>This function should not be used while the MIDI stream is being rendered, as that could interrupt the rendering.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The stream is for real-time events only, so it's not possible to know what presets are going to be used. Use <see cref="M:ManagedBass.Midi.BassMidi.FontLoad(System.Int32,System.Int32,System.Int32)" /> instead.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamSetFonts(System.Int32,ManagedBass.Midi.MidiFont[],System.Int32)">
            <summary>
            Applies a soundfont configuration to a MIDI stream, or sets the default soundfont configuration.
            </summary>
            <param name="Handle">The MIDI stream to apply the soundfonts to... 0 = set default soundfont configuration.</param>
            <param name="Fonts">An array of <see cref="T:ManagedBass.Midi.MidiFont" /> soundfonts to apply.</param>
            <param name="Count">The number of elements in the fonts array.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Multiple soundfonts can be stacked, each providing different presets, for example.
            When a preset is present in multiple soundfonts, the earlier soundfont in the array has priority.
            When a soundfont matching the MIDI file is loaded, that remains loaded when calling this function, and has priority over all other soundfonts.
            When a preset is not available on a non-0 bank in any soundfont, BASSMIDI will try to fall back to bank 0; first the LSB and then the MSB if still unsuccessful.
            <para>
            Changing the default configuration only affects subsequently created MIDI streams.
            Existing streams that are using the previous default configuration will continue to use that previous configuration.
            </para>
            <para>On Windows, the default default configuration will be to use the Creative 4MB (CT4MGM.SF2) or 2MB (CT2MGM.SF2) soundfont when present in the Windows system directory.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">Something in the <paramref name="Fonts" /> array is invalid, check the soundfont handles.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.StreamSetFonts(System.Int32,ManagedBass.Midi.MidiFontEx[],System.Int32)">
            <summary>
            Applies a soundfont configuration to a MIDI stream, or sets the default soundfont configuration.
            </summary>
            <param name="Handle">The MIDI stream to apply the soundfonts to... 0 = set default soundfont configuration.</param>
            <param name="Fonts">An array of <see cref="T:ManagedBass.Midi.MidiFontEx" /> soundfonts to apply.</param>
            <param name="Count">The number of elements in the fonts array.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Multiple soundfonts can be stacked, each providing different presets, for example.
            When a preset is present in multiple soundfonts, the earlier soundfont in the array has priority.
            When a soundfont matching the MIDI file is loaded, that remains loaded when calling this function, and has priority over all other soundfonts.
            When a preset is not available on a non-0 bank in any soundfont, BASSMIDI will try to fall back to bank 0; first the LSB and then the MSB if still unsuccessful.
            <para>
            Changing the default configuration only affects subsequently created MIDI streams.
            Existing streams that are using the previous default configuration will continue to use that previous configuration.
            </para>
            <para>On Windows, the default default configuration will be to use the Creative 4MB (CT4MGM.SF2) or 2MB (CT2MGM.SF2) soundfont when present in the Windows system directory.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">Something in the <paramref name="Fonts" /> array is invalid, check the soundfont handles.</exception>
        </member>
        <member name="P:ManagedBass.Midi.BassMidi.Compact">
            <summary>
            Automatically compact all soundfonts following a configuration change?
            compact (bool): If true, all soundfonts are compacted following a MIDI stream being freed, or a <see cref="M:ManagedBass.Midi.BassMidi.StreamSetFonts(System.Int32,ManagedBass.Midi.MidiFont[],System.Int32)"/> call.
            The compacting isn't performed immediately upon a MIDI stream being freed or <see cref="M:ManagedBass.Midi.BassMidi.StreamSetFonts(System.Int32,ManagedBass.Midi.MidiFont[],System.Int32)"/> being called.
            It's actually done 2 seconds later (in another thread), 
            so that if another MIDI stream starts using the soundfonts in the meantime, they aren't needlessly closed and reopened.
            Samples that have been preloaded by <see cref="M:ManagedBass.Midi.BassMidi.FontLoad(System.Int32,System.Int32,System.Int32)"/> are not affected by automatic compacting.
            Other samples that have been preloaded by <see cref="M:ManagedBass.Midi.BassMidi.StreamLoadSamples(System.Int32)"/> are affected though,
            so it is probably wise to disable this option when using that function.
            By default, this option is enabled.
            </summary>
        </member>
        <member name="P:ManagedBass.Midi.BassMidi.AutoFont">
            <summary>
            Automatically load matching soundfonts?
            If set to 1 (default), BASSMIDI will try to load a soundfont matching the MIDI file. If set to 2, the matching soundfont will also be used on all banks. 
            </summary>
        </member>
        <member name="P:ManagedBass.Midi.BassMidi.Voices">
            <summary>
            The maximum number of samples to play at a time (polyphony).
            voices (int): Maximum number of samples to play at a time... 1 (min) - 1000 (max).
            This setting determines the maximum number of samples that can play together in a single MIDI stream. 
            This isn't necessarily the same thing as the maximum number of notes, due to presets often layering multiple samples. 
            When there are no voices available to play a new sample, the voice with the lowest volume will be killed to make way for it.
            The more voices that are used, the more CPU that is required. 
            So this option can be used to restrict that, for example on a less powerful system. 
            The CPU usage of a MIDI stream can also be restricted via the <see cref="F:ManagedBass.ChannelAttribute.MidiCPU"/> attribute.
            Changing this setting only affects subsequently created MIDI streams, not any that have already been created. 
            The default setting is 128 voices.
            Platform-specific
            The default setting is 100, except on iOS, where it is 40.
            </summary>
        </member>
        <member name="P:ManagedBass.Midi.BassMidi.DefaultFont">
            <summary>
            Default soundfont usage
            filename (string): Filename of the default soundfont to use (null = no default soundfont).
            If the specified soundfont cannot be loaded, the default soundfont setting will remain as it is.
            On Windows, the default is to use one of the Creative soundfonts (28MBGM.SF2 or CT8MGM.SF2 or CT4MGM.SF2 or CT2MGM.SF2),
            if present in the windows system directory.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.BassMidi.Plugin">
            <summary>
            Use this library as a Plugin.
            </summary>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.CreateStream(System.String,System.Int64,System.Int64,ManagedBass.BassFlags,System.Int32)">
            <summary>Create a stream from file.</summary>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.CreateStream(System.IntPtr,System.Int64,System.Int64,ManagedBass.BassFlags,System.Int32)">
            <summary>Create a stream from Memory (IntPtr).</summary>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.CreateStream(System.Byte[],System.Int64,System.Int64,ManagedBass.BassFlags,System.Int32)">
            <summary>Create a stream from Memory (byte[]).</summary>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.CreateStream(ManagedBass.StreamSystem,ManagedBass.BassFlags,ManagedBass.FileProcedures,System.IntPtr,System.Int32)">
            <summary>Create a stream using User File Procedures.</summary>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.CreateStream(System.String,System.Int32,ManagedBass.BassFlags,ManagedBass.DownloadProcedure,System.IntPtr,System.Int32)">
            <summary>Create a stream from Url.</summary>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontCompact(System.Int32)">
            <summary>
            Compact a soundfont's memory usage.
            </summary>
            <param name="Handle">The soundfont to get info on (e.g. as returned by <see cref="M:ManagedBass.Midi.BassMidi.FontInit(System.String)" />)... 0 = all soundfonts.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Compacting involves freeing any samples that are currently loaded but unused.
            The amount of sample data currently loaded can be retrieved using <see cref="M:ManagedBass.Midi.BassMidi.FontGetInfo(System.Int32,ManagedBass.Midi.MidiFontInfo@)" />.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontFree(System.Int32)">
            <summary>
            Frees a soundfont.
            </summary>
            <param name="Handle">The soundfont handle to free (e.g. as returned by <see cref="M:ManagedBass.Midi.BassMidi.FontInit(System.String)" />).</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>When a soundfont is freed, it is automatically removed from any MIDI streams that are using it.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontGetInfo(System.Int32,ManagedBass.Midi.MidiFontInfo@)">
            <summary>
            Retrieves information on a soundfont.
            </summary>
            <param name="Handle">The soundfont to get info on (e.g. as returned by <see cref="M:ManagedBass.Midi.BassMidi.FontInit(System.String)" />).</param>
            <param name="Info">An instance of <see cref="T:ManagedBass.Midi.MidiFontInfo"/> structure to store the information into.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontGetInfo(System.Int32)">
            <summary>
            Retrieves information on a soundfont.
            </summary>
            <param name="Handle">The soundfont to get info on (e.g. as returned by <see cref="M:ManagedBass.Midi.BassMidi.FontInit(System.String)" />).</param>
            <returns>An instance of <see cref="T:ManagedBass.Midi.MidiFontInfo"/> structure is returned. Throws <see cref="T:ManagedBass.BassException"/> on Error.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontGetPreset(System.Int32,System.Int32,System.Int32)">
            <summary>
            Retrieves the name of a preset in a soundfont.
            </summary>
            <param name="Handle">The soundfont handle to get the preset name from.</param>
            <param name="Preset">Preset number to load... -1 = all presets (the first encountered).</param>
            <param name="Bank">Bank number to load... -1 = all banks (the first encountered).</param>
            <returns>If successful, the requested preset name is returned, else <see langword="null" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The soundfont does not contain the requested preset.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontGetPresets(System.Int32,System.Int32[])">
            <summary>
            Retrieves the presets in a soundfont.
            </summary>
            <param name="Handle">The soundfont handle to get the preset name from.</param>
            <param name="Presets">The array to receive the presets.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The presets are delivered with the preset number in the LOWORD and the bank number in the HIWORD, and in numerically ascending order.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontGetPresets(System.Int32)">
            <summary>
            Retrieves the presets in a soundfont.
            </summary>
            <param name="Handle">The soundfont handle to get the preset name from.</param>
            <returns>If successful, an array of presets is returned, else <see langword="null" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The presets are delivered with the preset number in the LOWORD and the bank number in the HIWORD, and in numerically ascending order.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontGetVolume(System.Int32)">
            <summary>
            Retrieves a soundfont's volume level.
            </summary>
            <param name="Handle">The soundfont to get the volume of.</param>
            <returns>If successful, the soundfont's volume level is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontInit(System.String)">
            <summary>
            Initializes a soundfont from a file (unicode).
            </summary>
            <param name="File">The file name of the sound font (e.g. an .sf2 file).</param>
            <returns>If successful, the soundfont's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            BASSMIDI uses SF2 and/or SFZ soundfonts to provide the sounds to use in the rendering of MIDI files.
            Several soundfonts can be found on the internet, including a couple on the BASS website.
            </para>
            <para>
            A soundfont needs to be initialized before it can be used to render MIDI streams.
            Once initialized, a soundfont can be assigned to MIDI streams using the <see cref="M:ManagedBass.Midi.BassMidi.StreamSetFonts(System.Int32,ManagedBass.Midi.MidiFont[],System.Int32)" /> function.
            A single soundfont can be shared by multiple MIDI streams.
            </para>
            <para>Information on the initialized soundfont can be retrieved using <see cref="M:ManagedBass.Midi.BassMidi.FontGetInfo(System.Int32,ManagedBass.Midi.MidiFontInfo@)" />.</para>
            <para>If a soundfont is initialized multiple times, each instance will have its own handle but share the same sample/etc data.</para>
            <para>
            Soundfonts use PCM sample data as standard, but BASSMIDI can accept any format that is supported by BASS or its add-ons.
            The FontPack function can be used to compress the sample data in SF2 files.
            SFZ samples are in separate files and can be compressed using standard encoding tools.
            </para>
            <para>Using soundfonts that are located somewhere other than the file system is possible via <see cref="M:ManagedBass.Midi.BassMidi.FontInit(ManagedBass.FileProcedures,System.IntPtr,ManagedBass.BassFlags)" />.</para>
            <para><b>SFZ support</b></para>
            <para>
            The following SFZ opcodes are supported: ampeg_attack, ampeg_decay, ampeg_delay, ampeg_hold, ampeg_release, ampeg_sustain, ampeg_vel2attack, ampeg_vel2decay, amplfo_delay/fillfo_delay/pitchlfo_delay, amplfo_depth, amplfo_freq/fillfo_freq/pitchlfo_freq, amp_veltrack, cutoff, effect1, effect2, end, fileg_attack/pitcheg_attack, fileg_decay/pitcheg_decay, fileg_delay/pitcheg_delay, fileg_depth, fileg_hold/pitcheg_hold, fileg_release/pitcheg_release, fileg_sustain/pitcheg_sustain, fileg_vel2depth, fillfo_depth, fil_veltrack, group, hikey, hivel, key, lokey, loop_end, loop_mode, loop_start, lovel, offset, off_by, pan, pitcheg_depth, pitchlfo_depth, pitch_keycenter, pitch_keytrack, pitch_veltrack, resonance, sample, seq_length, seq_position, transpose, tune, volume. 
            The fil_type opcode is also supported, but only to confirm that a low pass filter is wanted (the filter will be disabled otherwise). 
            The combined EG and LFO entries in the opcode list reflect that there is a shared EG for pitch/filter and a shared LFO for amplitude/pitch/filter, as is the case in SF2. 
            Information on these (and other) SFZ opcodes can be found at www.sfzformat.com.
            </para>
            <para><b>Platform-specific</b></para>
            <para>The <see cref="F:ManagedBass.BassFlags.MidiFontMemoryMap"/> option is not available on big-endian systems (eg. PowerPC) as a soundfont's little-endian sample data cannot be played directly from a mapping; its byte order needs to be reversed.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.FileOpen">The <paramref name="File" /> could not be opened.</exception>
            <exception cref="F:ManagedBass.Errors.FileFormat">The file's format is not recognised/supported.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontInit(ManagedBass.FileProcedures,System.IntPtr,ManagedBass.BassFlags)">
            <summary>
            Initializes a soundfont via user callback functions.
            </summary>
            <param name="Procedures">The user defined file function (see <see cref="T:ManagedBass.FileProcedures" />).</param>
            <param name="User">User instance data to pass to the callback functions.</param>
            <param name="Flags">Unused.</param>
            <returns>If successful, the soundfont's handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>The unbuffered file system (<see cref="F:ManagedBass.StreamSystem.NoBuffer"/>) is always used by this function.</remarks>
            <exception cref="F:ManagedBass.Errors.FileFormat">The file's format is not recognised/supported.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontLoad(System.Int32,System.Int32,System.Int32)">
            <summary>
            Preloads presets from a soundfont.
            </summary>
            <param name="Handle">The soundfont handle.</param>
            <param name="Preset">Preset number to load... -1 = all presets.</param>
            <param name="Bank">Bank number to load... -1 = all banks.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            Samples are normally loaded as they are needed while rendering a MIDI stream, which can result in CPU spikes, particularly with packed soundfonts.
            That generally won't cause any problems, but when smooth/constant performance is critical this function can be used to preload the samples before rendering, so avoiding the need to load them while rendering.
            </para>
            <para>When preloading samples to render a particular MIDI stream, it is more efficient to use <see cref="M:ManagedBass.Midi.BassMidi.StreamLoadSamples(System.Int32)" /> to preload the specific samples that the MIDI stream will use, rather than preloading the entire soundfont.</para>
            <para>Samples that are preloaded by this function are not affected by automatic compacting via the <see cref="P:ManagedBass.Midi.BassMidi.Compact" /> option, but can be compacted/unloaded manually with <see cref="M:ManagedBass.Midi.BassMidi.FontCompact(System.Int32)" />.</para>
            <para>A soundfont should not be preloaded while it's being used to render any MIDI streams, as that could delay the rendering.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Codec">The appropriate add-on to decode the samples is not loaded.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The soundfont does not contain the requested preset.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontSetVolume(System.Int32,System.Single)">
            <summary>
            Sets a soundfont's volume level.
            </summary>
            <param name="Handle">The soundfont to set the volume of.</param>
            <param name="Volume">The volume level... 0=silent, 1.0=normal/default.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            By default, some soundfonts may be louder than others, which could be a problem when mixing multiple soundfonts. 
            This function can be used to compensate for any differences, by raising the level of the quieter soundfonts or lowering the louder ones.
            <para>Changes take immediate effect in any MIDI streams that are using the soundfont.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontUnload(System.Int32,System.Int32,System.Int32)">
            <summary>
            Unloads presets from a soundfont.
            </summary>
            <param name="Handle">The soundfont handle.</param>
            <param name="Preset">Preset number to load... -1 = all presets.</param>
            <param name="Bank">Bank number to load... -1 = all banks.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            An unloaded preset will be loaded again when needed by a MIDI stream.
            Any samples that are currently being used by a MIDI stream will not be unloaded.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The soundfont does not contain the specified preset, or the soundfont is memory mapped.</exception>
        </member>
        <member name="M:ManagedBass.Midi.BassMidi.FontUnpack(System.Int32,System.String)">
            <summary>
            Produces a decompressed version of a packed soundfont.
            </summary>
            <param name="Handle">The soundfont to unpack.</param>
            <param name="OutFile">Filename for the unpacked soundfont.</param>
            <returns>If successful, the <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            To unpack a soundfont, the appropriate BASS add-on needs to be loaded (via <see cref="M:ManagedBass.Bass.PluginLoad(System.String)" />) to decode the samples. 
            For example, if the samples are FLAC encoded, BASSFLAC would need to be loaded. 
            BASS also needs to have been initialized, using <see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" />. 
            For just unpacking a soundfont, the <see cref="F:ManagedBass.Bass.NoSoundDevice"/> could be used.
            <para>
            A soundfont should not be unpacked while it is being used to render any MIDI streams, as that could delay the rendering.
            <see cref="M:ManagedBass.Midi.BassMidi.FontGetInfo(System.Int32,ManagedBass.Midi.MidiFontInfo@)" /> can be used to check if a soundfont is packed.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.NotAvailable">The soundfont is not packed.</exception>
            <exception cref="F:ManagedBass.Errors.Init"><see cref="M:ManagedBass.Bass.Init(System.Int32,System.Int32,ManagedBass.DeviceInitFlags,System.IntPtr,System.IntPtr)" /> has not been successfully called - it needs to be to decode the samples.</exception>
            <exception cref="F:ManagedBass.Errors.Codec">The appropriate add-on to decode the samples is not loaded.</exception>
            <exception cref="F:ManagedBass.Errors.Create">Couldn't create the output file, <paramref name="OutFile" />.</exception>
            <exception cref="F:ManagedBass.Errors.Unknown">Some other mystery problem!</exception>
        </member>
        <member name="T:ManagedBass.Midi.MidiEvent">
            <summary>
            Used with <see cref="M:ManagedBass.Midi.BassMidi.StreamEvents(System.Int32,ManagedBass.Midi.MidiEventsMode,ManagedBass.Midi.MidiEvent[],System.Int32)"/> to apply events and <see cref="M:ManagedBass.Midi.BassMidi.StreamGetEvents(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,ManagedBass.Midi.MidiEvent[])"/> to retrieve events, and <see cref="M:ManagedBass.Midi.BassMidi.CreateStream(ManagedBass.Midi.MidiEvent[],System.Int32,ManagedBass.BassFlags,System.Int32)"/> to play event sequences.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEvent.EventType">
            <summary>
            The Event Type
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEvent.Parameter">
            <summary>
            The Event Parameter
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEvent.Channel">
            <summary>
            The MIDI Channel of the event... 0 = channel 1
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEvent.Ticks">
            <summary>
            The Position of the event, in ticks
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiEvent.Position">
            <summary>
            The Position of the event, in bytes
            </summary>
        </member>
        <member name="T:ManagedBass.Midi.MidiFont">
            <summary>
            Used with <see cref="M:ManagedBass.Midi.BassMidi.StreamSetFonts(System.Int32,ManagedBass.Midi.MidiFont[],System.Int32)" /> and <see cref="M:ManagedBass.Midi.BassMidi.StreamGetFonts(System.Int32,ManagedBass.Midi.MidiFont[],System.Int32)" /> to set and retrieve soundfont configurations.
            </summary>
            <remarks>
            When using an individual preset from a soundfont, BASSMIDI will first look for the exact preset and bank match, but if that is not present, the first preset from the soundfont will be used.
            This is useful for single preset soundfonts.
            Individual presets can be assigned to program numbers beyond the standard 127 limit, up to 65535, which can then be accessed via <see cref="M:ManagedBass.Midi.BassMidi.StreamEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,System.Int32)"/>.
            <para>
            When using all presets in a soundfont, the bank member is a base number that is added to the soundfont's banks.
            For example, if bank=1 then the soundfont's bank 0 becomes bank 1, etc.
            Negative base numbers are allowed.
            </para>
            <para>For more flexible mapping of soundfont presets to MIDI programs, see the <see cref="T:ManagedBass.Midi.MidiFontEx" /> structure.</para>
            </remarks>
        </member>
        <member name="F:ManagedBass.Midi.MidiFont.Handle">
            <summary>
            Soundfont handle, previously inititialized with <see cref="M:ManagedBass.Midi.BassMidi.FontInit(System.String)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiFont.Preset">
            <summary>
            Preset number... 0-65535, -1 = use all presets in the soundfont.
            This determines what <see cref="F:ManagedBass.Midi.MidiEventType.Program"/> event value(s) the soundfont is used for.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiFont.Bank">
            <summary>
            Base bank number, or the bank number of the individual preset.
            This determines what <see cref="F:ManagedBass.Midi.MidiEventType.Bank"/> event value(s) the soundfont is used for.
            </summary>
        </member>
        <member name="T:ManagedBass.Midi.MidiFontEx">
            <summary>
            Used with <see cref="M:ManagedBass.Midi.BassMidi.StreamSetFonts(System.Int32,ManagedBass.Midi.MidiFontEx[],System.Int32)" /> and <see cref="M:ManagedBass.Midi.BassMidi.StreamGetFonts(System.Int32,ManagedBass.Midi.MidiFontEx[],System.Int32)" /> to set and retrieve soundfont configurations.
            </summary>
            <remarks>
            This is an extended version of the <see cref="T:ManagedBass.Midi.MidiFont" /> structure that allows more flexible mapping of soundfont presets to MIDI programs, including access to the bank LSB (eg. MIDI controller 32).
            <para>
            When using an individual preset from a soundfont, BASSMIDI will first look for the exact <see cref="F:ManagedBass.Midi.MidiFontEx.SoundFontPreset"/> and <see cref="F:ManagedBass.Midi.MidiFontEx.SoundFontBank"/> match, but if that is not present, the first preset from the soundfont will be used.
            This is useful for single preset soundfonts.
            Individual presets can be assigned to program numbers beyond the standard 127 limit, up to 65535, which can then be accessed via <see cref="M:ManagedBass.Midi.BassMidi.StreamEvent(System.Int32,System.Int32,ManagedBass.Midi.MidiEventType,System.Int32)" />.
            </para>
            <para>
            When using all presets from all banks in a soundfont, the <see cref="F:ManagedBass.Midi.MidiFontEx.DestinationBank"/> member is a base number that is added to the soundfont's banks.
            For example, if <see cref="F:ManagedBass.Midi.MidiFontEx.DestinationBank"/> = 1 then the soundfont's bank 0 becomes bank 1, etc.
            Negative base numbers are allowed, to lower a soundfont's bank numbers.
            </para>
            <para>
            The bank LSB raises the maximum number of melodic banks from 128 to 16384 (128 x 128).
            But, the SF2 soundfont format only supports 128 banks.
            So a soundfont that is set to be used on all banks (<see cref="F:ManagedBass.Midi.MidiFontEx.DestinationPreset"/> and <see cref="F:ManagedBass.Midi.MidiFontEx.DestinationBank"/> are -1) will still only apply to the single bank LSB specified by <see cref="F:ManagedBass.Midi.MidiFontEx.DestinationBankLSB"/>.
            </para>
            </remarks>
        </member>
        <member name="F:ManagedBass.Midi.MidiFontEx.Handle">
            <summary>
            Soundfont handle, previously inititialized with <see cref="M:ManagedBass.Midi.BassMidi.FontInit(System.String)" />.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiFontEx.SoundFontPreset">
            <summary>
            Soundfont preset number... 0-127, -1 = use all presets.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiFontEx.SoundFontBank">
            <summary>
            Soundfont bank number... 0-128, -1 = use all banks.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiFontEx.DestinationPreset">
            <summary>
            Destination preset/program number... 0-65535, -1 = all presets.
            This determines what <see cref="F:ManagedBass.Midi.MidiEventType.Program"/> event value(s) the soundfont is used for.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiFontEx.DestinationBank">
            <summary>
            Destination bank number, or a base bank number when using all presets from all banks.
            This determines what <see cref="F:ManagedBass.Midi.MidiEventType.Bank"/> event value(s) the soundfont is used for.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiFontEx.DestinationBankLSB">
            <summary>
            Destination bank number LSB.
            This is the <see cref="F:ManagedBass.Midi.MidiEventType.BankLSB"/> event value that the soundfont is used for.
            </summary>
        </member>
        <member name="T:ManagedBass.Midi.MidiFontInfo">
            <summary>
            Used with <see cref="M:ManagedBass.Midi.BassMidi.FontGetInfo(System.Int32,ManagedBass.Midi.MidiFontInfo@)" /> to retrieve information on a soundfont.
            </summary>
            <remarks>
            The <see cref="P:ManagedBass.Midi.MidiFontInfo.Name"/>, <see cref="P:ManagedBass.Midi.MidiFontInfo.Copyright"/> and <see cref="P:ManagedBass.Midi.MidiFontInfo.Comment"/> information might not be included in some SF2 files. 
            Only the <see cref="F:ManagedBass.Midi.MidiFontInfo.Presets"/>, <see cref="F:ManagedBass.Midi.MidiFontInfo.SampleDataLoaded"/> and <see cref="F:ManagedBass.Midi.MidiFontInfo.SampleDataType"/> members are available with SFZ files, with the <see cref="F:ManagedBass.Midi.MidiFontInfo.SampleDataType"/> value reflecting the most recently loaded encoded sample (it is possible for different samples to use different encoding).
            </remarks>
        </member>
        <member name="F:ManagedBass.Midi.MidiFontInfo.Presets">
            <summary>
            The number of presets/instruments in the soundfont.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiFontInfo.SampleDataSize">
            <summary>
            The total size (in bytes) of the sample data in the soundfont.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiFontInfo.SampleDataLoaded">
            <summary>
            The amount of sample data currently loaded... -1 = the soundfont is memory mapped.
            </summary>
        </member>
        <member name="F:ManagedBass.Midi.MidiFontInfo.SampleDataType">
            <summary>
            The <see cref="T:ManagedBass.ChannelType"/> format of the sample data if it's packed... -1 = Unknown format (appropriate BASS add-on not loaded), 0 = not packed.
            </summary>
        </member>
        <member name="P:ManagedBass.Midi.MidiFontInfo.Name">
            <summary>
            Name of the soundfont.
            </summary>
        </member>
        <member name="P:ManagedBass.Midi.MidiFontInfo.Copyright">
            <summary>
            Copyright notice.
            </summary>
        </member>
        <member name="P:ManagedBass.Midi.MidiFontInfo.Comment">
            <summary>
            Any comments.
            </summary>
        </member>
        <member name="T:ManagedBass.Midi.MidiMarker">
            <summary>
            Used with <see cref="M:ManagedBass.Midi.BassMidi.StreamGetMark(System.Int32,ManagedBass.Midi.MidiMarkerType,System.Int32,ManagedBass.Midi.MidiMarker@)" />, <see cref="F:ManagedBass.SyncFlags.MidiLyric" />, <see cref="F:ManagedBass.SyncFlags.MidiCue" /> and <see cref="F:ManagedBass.SyncFlags.MidiMarker" /> to retrieve markers.
            </summary>
        </member>
        <member name="P:ManagedBass.Midi.MidiMarker.Text">
            <summary>
            The marker, cue, lyric, keysig, timesig text.
            </summary>
            <remarks>
            If the lyric text begins with a '/' (slash) character, a new line should be started. 
            If it begins with a '\' (backslash) character, the display should be cleared.
            <para>
            For a key signature event (MIDI meta event 89).
            The marker text is in the form of "a b", where a is the number of sharps (if positive) or flats (if negative), and b signifies major (if 0) or minor (if 1).
            </para>
            <para>
            For a time signature events (MIDI meta event 88).
            The marker text is in the form of "a/b c d", where a is the numerator, b is the denominator, c is the metronome pulse, and d is the number of 32nd notes per MIDI quarter-note.
            </para>
            </remarks>
        </member>
        <member name="P:ManagedBass.Midi.MidiMarker.Track">
            <summary>
            The MIDI track (number) containing marker (0=first).
            </summary>
        </member>
        <member name="P:ManagedBass.Midi.MidiMarker.Position">
            <summary>
            The position (in bytes) of the marker.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.BassFx">
            <summary>
            Wraps BassFx: bassfx.dll
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.BassFx.Version">
            <summary>
            Gets the Version of BassFx that is loaded.
            </summary>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.TempoCreate(System.Int32,ManagedBass.BassFlags)">
            <summary>
            Creates a resampling stream from a decoding channel.
            </summary>
            <param name="Channel">Stream/music/wma/cd/any other supported add-on format using a decoding channel (use <see cref="F:ManagedBass.BassFlags.Decode"/> when creating the channel).</param>
            <param name="Flags">A combination of the <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, the tempo stream handle is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Multi-channels are supported.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Channel" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Decode">The <paramref name="Channel" /> is not a decoding channel. Make sure the channel was created using the <see cref="F:ManagedBass.BassFlags.Decode"/> flag.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The <paramref name="Channel" />'s format is not supported. Make sure the channel is either Stereo or Mono.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.TempoGetSource(System.Int32)">
            <summary>
            Get the source channel handle of the reversed stream.
            </summary>
            <param name="Channel">The handle of the reversed stream.</param>
            <returns>If successful, the handle of the source of the reversed stream is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Channel" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.TempoGetRateRatio(System.Int32)">
            <summary>
            Get the ratio of the resulting rate and source rate (the resampling ratio).
            </summary>
            <param name="Channel">Tempo stream (or source channel) handle.</param>
            <returns>If successful, the resampling ratio is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Channel" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.ReverseCreate(System.Int32,System.Single,ManagedBass.BassFlags)">
            <summary>
            Creates a reversed stream from a decoding channel.
            </summary>
            <param name="Channel">Stream/music/wma/cd/any other supported add-on format using a decoding channel.</param>
            <param name="DecodingBlockLength">Length of decoding blocks in seconds. Larger blocks means less seeking overhead but larger spikes.</param>
            <param name="Flags">A combination of <see cref="T:ManagedBass.BassFlags"/>.</param>
            <returns>If successful, the handle of the reversed stream is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            MODs are supported, if <see cref="F:ManagedBass.BassFlags.Prescan"/> flag was applied to a source handle.
            <para>For better MP3/2/1 reverse playback create the source stream using the <see cref="F:ManagedBass.BassFlags.Prescan"/> flag.</para>
            <para>
            Thes <see cref="F:ManagedBass.ChannelAttribute.ReverseDirection"/> attribute can either be applied to the reverse channel or the underlying decoding source channel.
            Note, that when playing the channel reverse, the end of a reverse stream is reached at the logial beginning of the stream (this also applies to <see cref="F:ManagedBass.SyncFlags.End"/>).
            By default stream's position will start from the end.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Channel" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Decode">The <paramref name="Channel" /> is not a decoding channel. Make sure the channel was created using the <see cref="F:ManagedBass.BassFlags.Decode"/> flag.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The <paramref name="Channel" />'s format is not supported. Make sure the channel is either Stereo or Mono.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.ReverseGetSource(System.Int32)">
            <summary>
            Get the source channel handle of the reversed stream.
            </summary>
            <param name="Channel">The handle of the reversed stream.</param>
            <returns>If successful, the handle of the source of the reversed stream is returned, else 0 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Channel" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.BPMDecodeGet(System.Int32,System.Double,System.Double,System.Int32,ManagedBass.BassFlags,ManagedBass.Fx.BPMProgressProcedure,System.IntPtr)">
            <summary>
            Get the original BPM of a decoding channel.
            </summary>
            <param name="Channel">Stream/music/wma/cd/any other supported add-on format using a decoding channel.</param>
            <param name="StartSec">Start detecting position in seconds (if less than 0 it uses the current position).</param>
            <param name="EndSec">End detecting position in seconds (greater than 0).</param>
            <param name="MinMaxBPM">Set min and max bpm, LowWord=Min, HighWord=Max. 0 = defaults to 45/230.</param>
            <param name="Flags">One of <see cref="F:ManagedBass.BassFlags.FxBpmBackground"/>, <see cref="F:ManagedBass.BassFlags.FXBpmMult2"/> and <see cref="F:ManagedBass.BassFlags.FxFreeSource"/>.</param>
            <param name="Procedure">User defined function to receive the process in percents, use <see langword="null" /> if not in use.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, the original BPM value is returned, else -1 is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            The BPM detection algorithm works by detecting repeating low-frequency (less than 250Hz) sound patterns and thus works mostly with most rock/pop music with bass or drum beat. 
            The BPM detection doesn't work on pieces such as classical music without distinct, repeating bass frequency patterns.
            Also pieces with varying tempo, varying bass patterns or very complex bass patterns (jazz, hiphop) may produce odd BPM readings.
            </para>
            <para>
            In cases when the bass pattern drifts a bit around a nominal beat rate (e.g. drummer is again drunken ;-), the BPM algorithm may report incorrect harmonic one-halft to one-thirdth of the correct BPM value.
            In such case the system could for example report BPM value of 50 or 100 instead of correct BPM value of 150.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Channel" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Decode">The <paramref name="Channel" /> is not a decoding channel. Make sure the channel was created using the <see cref="F:ManagedBass.BassFlags.Decode"/> flag.</exception>
            <exception cref="F:ManagedBass.Errors.SampleFormat">The <paramref name="Channel" />'s format is not supported. Make sure the channel is either Stereo or Mono.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">An illegal parameter was specified.</exception>
            <exception cref="F:ManagedBass.Errors.Already">BPM detection, for this <paramref name="Channel" /> is already in use.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.BPMCallbackSet(System.Int32,ManagedBass.Fx.BPMProcedure,System.Double,System.Int32,ManagedBass.BassFlags,System.IntPtr)">
            <summary>
            Enable getting BPM value by period of time in seconds.
            </summary>
            <param name="Handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <param name="Procedure">User defined function to receive the bpm value.</param>
            <param name="Period">Detection period in seconds.</param>
            <param name="MinMaxBPM">Set min and max bpm, LowWord=Min, HighWord=Max. 0 = defaults to 45/230.</param>
            <param name="Flags">Use <see cref="F:ManagedBass.BassFlags.FXBpmMult2"/> or <see cref="F:ManagedBass.BassFlags.Default"/>.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description></description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description></description></item>
            <item><term>BASS_ERROR_ALREADY</term><description></description></item>
            </list>
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">An illegal parameter was specified.</exception>
            <exception cref="F:ManagedBass.Errors.Already"><see cref="F:ManagedBass.BassFlags.FXBpmMult2"/> already used on this handle.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.BPMCallbackReset(System.Int32)">
            <summary>
            Reset the BPM buffers.
            </summary>
            <param name="Handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function flushes the internal buffers of the BPM callback.
            The BPM callback is automatically reset by <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" />, except when called from a <see cref="F:ManagedBass.SyncFlags.Mixtime"/> <see cref="T:ManagedBass.SyncProcedure" />.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.BPMFree(System.Int32)">
            <summary>
            Frees all resources used by a given handle.
            </summary>
            <param name="Handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Used together with <see cref="M:ManagedBass.Fx.BassFx.BPMDecodeGet(System.Int32,System.Double,System.Double,System.Int32,ManagedBass.BassFlags,ManagedBass.Fx.BPMProgressProcedure,System.IntPtr)" /> or <see cref="M:ManagedBass.Fx.BassFx.BPMCallbackSet(System.Int32,ManagedBass.Fx.BPMProcedure,System.Double,System.Int32,ManagedBass.BassFlags,System.IntPtr)" />.
            If <see cref="F:ManagedBass.BassFlags.FxFreeSource"/> was used, this will also free the underlying decoding channel as well.
            You can't set/get this flag with <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)" />/<see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" />.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.BPMBeatDecodeGet(System.Int32,System.Double,System.Double,ManagedBass.BassFlags,ManagedBass.Fx.BPMBeatProcedure,System.IntPtr)">
            <summary>
            Enable getting Beat position in seconds of the decoded channel using a callback function.
            </summary>
            <param name="Channel">Stream/music/wma/cd/any other supported add-on format using a decoding channel.</param>
            <param name="StartSec">Start detecting position in seconds.</param>
            <param name="EndSec">End detecting position in seconds (greater than 0).</param>
            <param name="Flags">Use one of <see cref="F:ManagedBass.BassFlags.FxBpmBackground"/> and <see cref="F:ManagedBass.BassFlags.FxFreeSource"/>.</param>
            <param name="Procedure">User defined function to receive the beat position values.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>This method works pretty much as a mix of <see cref="M:ManagedBass.Fx.BassFx.BPMBeatCallbackSet(System.Int32,ManagedBass.Fx.BPMBeatProcedure,System.IntPtr)" /> and <see cref="M:ManagedBass.Fx.BassFx.BPMDecodeGet(System.Int32,System.Double,System.Double,System.Int32,ManagedBass.BassFlags,ManagedBass.Fx.BPMProgressProcedure,System.IntPtr)" />.</remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Channel" /> is not valid.</exception>
            <exception cref="F:ManagedBass.Errors.Decode">The <paramref name="Channel" /> is not a decoding channel. Make sure the channel was created using the <see cref="F:ManagedBass.BassFlags.Decode"/> flag.</exception>
            <exception cref="F:ManagedBass.Errors.Parameter">An illegal parameter was specified.</exception>
            <exception cref="F:ManagedBass.Errors.Already">Beat detection, for this <paramref name="Channel" /> is already in use.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.BPMBeatCallbackSet(System.Int32,ManagedBass.Fx.BPMBeatProcedure,System.IntPtr)">
            <summary>
            Enable getting Beat position in seconds in real-time.
            </summary>
            <param name="Handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <param name="Procedure">User defined function to receive the beat position values.</param>
            <param name="User">User instance data to pass to the callback function.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This method works on real-time (buffered) as well as on decoding channels and might also be used together with Tempo channels.
            <para><see cref="M:ManagedBass.Fx.BassFx.BPMBeatFree(System.Int32)" /> must be called at the end to free the real-time beat position callback and resources.</para>
            <para>Note: You should call <see cref="M:ManagedBass.Fx.BassFx.BPMBeatCallbackReset(System.Int32)" /> after you have changed the position of the stream when called from a <see cref="F:ManagedBass.SyncFlags.Mixtime"/> <see cref="T:ManagedBass.SyncProcedure" />.</para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.BPMBeatCallbackReset(System.Int32)">
            <summary>
            Reset the BPM buffers.
            </summary>
            <param name="Handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            This function flushes the internal buffers of the BPM callback.
            The BPM callback is automatically reset by <see cref="M:ManagedBass.Bass.ChannelSetPosition(System.Int32,System.Int64,ManagedBass.PositionFlags)" />, except when called from a <see cref="F:ManagedBass.SyncFlags.Mixtime"/> <see cref="T:ManagedBass.SyncProcedure" />.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.BPMBeatSetParameters(System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Set new values for beat detection parameters.
            </summary>
            <param name="Handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <param name="Bandwidth">Bandwidth in Hz between 0 and samplerate/2 (-1.0f = leave current, default is 10Hz).</param>
            <param name="CenterFreq">The center-frequency in Hz of the band pass filter between 0 and samplerate/2 (-1.0f = leave current, default is 90Hz).</param>
            <param name="Beat_rTime">Beat release time in ms. (-1.0f = leave current, default is 20ms).</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Beat detection is using a Band Pass Filter.
            A band-pass filter is a device that passes frequencies within a certain range and rejects (attenuates) frequencies outside that range.
            So the <paramref name="Bandwidth" /> parameter defines the range around a center-frequency to include in the beat detection algo.
            The <paramref name="CenterFreq" /> parameter actually defines the center-frequency of the band pass filter.
            Once a beat is detected, the <paramref name="Beat_rTime" /> parameter defines the time in ms. in which no other beat will be detected after that just detected beat. 
            The background is, that often you have kind-of 'double beats' in a drum set.
            So the <paramref name="Beat_rTime" /> should avoid, that a second (quickly repeated beat) beat is detected.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.BPMBeatGetParameters(System.Int32,System.Single@,System.Single@,System.Single@)">
            <summary>
            Gets the current beat detection parameter values.
            </summary>
            <param name="Handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <param name="Bandwidth">Current bandwidth in Hz.</param>
            <param name="CenterFreq">Current center-frequency in Hz of the band pass filter.</param>
            <param name="Beat_rTime">Current beat release time in ms.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Beat detection is using a Band Pass Filter.
            A band-pass filter is a device that passes frequencies within a certain range and rejects (attenuates) frequencies outside that range.
            So the <paramref name="Bandwidth" /> parameter defines the range around a center-frequency to include in the beat detection algo.
            The <paramref name="CenterFreq" /> parameter actually defines the center-frequency of the band pass filter.
            Once a beat is detected, the <paramref name="Beat_rTime" /> parameter defines the time in ms. in which no other beat will be detected after that just detected beat. 
            The background is, that often you have kind-of 'double beats' in a drum set.
            So the <paramref name="Beat_rTime" /> should avoid, that a second (quickly repeated beat) beat is detected.
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="M:ManagedBass.Fx.BassFx.BPMBeatFree(System.Int32)">
            <summary>
            Free all resources used by a given handle (decode or callback beat).
            </summary>
            <param name="Handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <returns>If successful, <see langword="true" /> is returned, else <see langword="false" /> is returned. Use <see cref="P:ManagedBass.Bass.LastError" /> to get the error code.</returns>
            <remarks>
            Used together with <see cref="M:ManagedBass.Fx.BassFx.BPMBeatDecodeGet(System.Int32,System.Double,System.Double,ManagedBass.BassFlags,ManagedBass.Fx.BPMBeatProcedure,System.IntPtr)" /> or <see cref="M:ManagedBass.Fx.BassFx.BPMBeatCallbackSet(System.Int32,ManagedBass.Fx.BPMBeatProcedure,System.IntPtr)" />.
            <para>
            Note: If the <see cref="F:ManagedBass.BassFlags.FxFreeSource"/> flag is used, this will free the source decoding channel as well.
            You can't set/get this flag with <see cref="M:ManagedBass.Bass.ChannelFlags(System.Int32,ManagedBass.BassFlags,ManagedBass.BassFlags)" /> and <see cref="M:ManagedBass.Bass.ChannelGetInfo(System.Int32,ManagedBass.ChannelInfo@)" />.
            </para>
            </remarks>
            <exception cref="F:ManagedBass.Errors.Handle"><paramref name="Handle" /> is not valid.</exception>
        </member>
        <member name="T:ManagedBass.Fx.AutoWahParameters">
            <summary>
            Parameters for AutoWah Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.AutoWahParameters.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-2...+2). Default = 0.5.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.AutoWahParameters.fWetMix">
            <summary>
            Wet (affected) signal mix (-2...+2). Default = 1.5.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.AutoWahParameters.fFeedback">
            <summary>
            Feedback (-1...+1). Default = 0.5.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.AutoWahParameters.fRate">
            <summary>
            Rate of sweep in cycles per second (0&lt;...&lt;10). Default = 2.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.AutoWahParameters.fRange">
            <summary>
            Sweep range in octaves (0&lt;...&lt;10). Default = 4.3.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.AutoWahParameters.fFreq">
            <summary>
            Base frequency of sweep range (0&lt;...1000). Default = 50.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.AutoWahParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.AutoWahParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.BQFParameters">
            <summary>
            Parameters for BQF Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFParameters.lFilter">
            <summary>
            BQF Filter Type.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFParameters.fCenter">
            <summary>
            Cut-off frequency (Center in PEAKINGEQ and Shelving filters) in Hz (1...info.freq/2). Default = 200Hz.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFParameters.fGain">
            <summary>
            Gain in dB (-15...0...+15). Default 0dB (used only for PEAKINGEQ and Shelving filters).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFParameters.fBandwidth">
            <summary>
            Bandwidth in octaves (0.1...4...n), Q is not in use (<see cref="F:ManagedBass.Fx.BQFParameters.fBandwidth"/> has priority over <see cref="F:ManagedBass.Fx.BQFParameters.fQ"/>). Default = 1 (0=not in use).
            The bandwidth in octaves (between -3 dB frequencies for <see cref="F:ManagedBass.Fx.BQFType.BandPass"/> and <see cref="F:ManagedBass.Fx.BQFType.Notch"/> or between midpoint (dBgain/2) gain frequencies for PEAKINGEQ).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFParameters.fQ">
            <summary>
            EE kinda definition of Q (0.1...1...n), if <see cref="F:ManagedBass.Fx.BQFParameters.fBandwidth"/> is not in use. Default = 0.0 (0=not in use).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFParameters.fS">
            <summary>
            A shelf slope parameter (linear, used only with Shelving filters) (0...1...n). Default = 0.0.
            When 1, the shelf slope is as steep as you can get it and remain monotonically increasing or decreasing gain with frequency.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.BQFParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.ChorusParameters">
            <summary>
            Parameters for Chorus Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ChorusParameters.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-2...+2). Default = 0.9
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ChorusParameters.fWetMix">
            <summary>
            Wet (affected) signal mix (-2...+2). Default = 0.35.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ChorusParameters.fFeedback">
            <summary>
            Feedback (-1...+1). Default = 0.5.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ChorusParameters.fMinSweep">
            <summary>
            Minimum delay in ms (0&lt;...6000). Default = 1.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ChorusParameters.fMaxSweep">
            <summary>
            Maximum delay in ms (0&lt;...6000). Default = 400.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ChorusParameters.fRate">
            <summary>
            Rate in ms/s (0&lt;...1000). Default = 200.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ChorusParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.ChorusParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.CompressorParameters">
            <summary>
            Parameters for Compressor Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.CompressorParameters.fGain">
            <summary>
            Output gain in dB of signal after compression, in the range from -60 to 60. Default = 5.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.CompressorParameters.fThreshold">
            <summary>
            Point in dB at which compression begins, in decibels, in the range from -60 to 0. Default = -15.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.CompressorParameters.fRatio">
            <summary>
            Compression ratio, in the range from 1 to 100. Default = 3.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.CompressorParameters.fAttack">
            <summary>
            Time in ms before compression reaches its full value, in the range from 0.01 to 500. Default = 20.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.CompressorParameters.fRelease">
            <summary>
            Time (speed) in ms at which compression is stopped after Input drops below <see cref="F:ManagedBass.Fx.CompressorParameters.fThreshold"/>, in the range from 50 to 3000. Default = 200.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.CompressorParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.CompressorParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.DampParameters">
            <summary>
            Parameters for Damp Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DampParameters.fTarget">
            <summary>
            Target volume level (0&lt;...1, linear).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DampParameters.fQuiet">
            <summary>
            Quiet volume level (0...1, linear). 
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DampParameters.fRate">
            <summary>
            Amplification adjustment rate (0...1, linear).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DampParameters.fGain">
            <summary>
            Amplification level (0...1...n, linear). 
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DampParameters.fDelay">
            <summary>
            Delay in seconds before increasing level (0...n, linear).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DampParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.DampParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.DistortionParameters">
            <summary>
            Parameters for Distortion Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DistortionParameters.fDrive">
            <summary>
            Distortion Drive (0...5).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DistortionParameters.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-5...+5).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DistortionParameters.fWetMix">
            <summary>
            Wet (affected) signal mix (-5...+5).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DistortionParameters.fFeedback">
            <summary>
            Feedback (-1...+1).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DistortionParameters.fVolume">
            <summary>
            Distortion volume (0...+2).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.DistortionParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.DistortionParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.EchoParameters">
            <summary>
            Parameters for Echo Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.EchoParameters.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-2...+2). 
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.EchoParameters.fWetMix">
            <summary>
            Wet (affected) signal mix (-2...+2). 
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.EchoParameters.fFeedback">
            <summary>
            Feedback (-1...+1).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.EchoParameters.fDelay">
            <summary>
            Delay in seconds (0+...6).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.EchoParameters.bStereo">
            <summary>
            Echo adjoining channels to each other? Default is disabled.
            </summary>
            <remarks>Only allowed with even number of channels!
            <para>If enabled and a stream has an even number of channels then, each even channels will be echoed to each other.</para>
            </remarks>
        </member>
        <member name="F:ManagedBass.Fx.EchoParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.EchoParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.PeakEQParameters">
            <summary>
            Parameters for PeakEQ Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PeakEQParameters.lBand">
            <summary>
            Number of bands (0...n), more bands means more memory and cpu usage. Default = 0.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PeakEQParameters.fBandwidth">
            <summary>
            Bandwidth in octaves (0.1...4...n), <see cref="F:ManagedBass.Fx.PeakEQParameters.fQ"/> is not in use (<see cref="F:ManagedBass.Fx.PeakEQParameters.fBandwidth"/> has priority over <see cref="F:ManagedBass.Fx.PeakEQParameters.fQ"/>). Default = 1 (0=not in use).
            <para>In most cases users should use the minimum of 0.5 octave.</para>
            <para>The bandwidth in octaves (between -3 dB frequencies for BPF and notch or between midpoint (dBgain/2) gain frequencies for peaking EQ).</para>
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PeakEQParameters.fQ">
            <summary>
            EE kinda definition of Q (0.1...1...n), if bandwidth is not in use. Default = 0.0 (0=not in use).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PeakEQParameters.fCenter">
            <summary>
            Center frequency in Hz (1Hz...nHz). Default = 1000 (max. is 1/2 of the samplerate).
            </summary>
            <remarks>Use 'oldcenter * freq / oldfreq' to update the <see cref="F:ManagedBass.Fx.PeakEQParameters.fCenter"/> after changing the samplerate.</remarks>
        </member>
        <member name="F:ManagedBass.Fx.PeakEQParameters.fGain">
            <summary>
            Gain in dB (-15...0...+15). Default 0dB.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PeakEQParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.PeakEQParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.PhaserParameters">
            <summary>
            Parameters for Phaser Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PhaserParameters.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PhaserParameters.fWetMix">
            <summary>
            Wet (affected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PhaserParameters.fFeedback">
            <summary>
            Feedback (-1...+1). Default = 0.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PhaserParameters.fRate">
            <summary>
            Rate of sweep in cycles per second (0&lt;...&lt;10). Default = 0.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PhaserParameters.fRange">
            <summary>
            Sweep range inoctaves (0&lt;...&lt;10). Default = 0.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PhaserParameters.fFreq">
            <summary>
            Base frequency of sweep range (0&lt;...1000). Default = 0.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PhaserParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.PhaserParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.PitchShiftParameters">
            <summary>
            Parameters for PitchShift Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PitchShiftParameters.fPitchShift">
            <summary>
            A factor value which is between 0.5 (one octave down) and 2 (one octave up) (1 won't change the pitch, default).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PitchShiftParameters.fSemitones">
            <summary>
            Semitones (0 won't change the pitch). Default = 0.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.PitchShiftParameters.lFFTsize">
            <summary>
            Defines the FFT frame size used for the processing. Typical values are 1024, 2048 (default) and 4096, max is 8192.
            </summary>
            <remarks>It may be any value up to 8192 but it MUST be a power of 2.</remarks>
        </member>
        <member name="F:ManagedBass.Fx.PitchShiftParameters.lOsamp">
            <summary>
            Is the STFT oversampling factor which also determines the overlap between adjacent STFT frames. Default = 8.
            </summary>
            <remarks>It should at least be 4 for moderate scaling ratios. A value of 32 is recommended for best quality (better quality = higher CPU usage).</remarks>
        </member>
        <member name="F:ManagedBass.Fx.PitchShiftParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.PitchShiftParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.ReverbParameters">
            <summary>
            Parameters for Reverb Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ReverbParameters.fDryMix">
            <summary>
            Dry (unaffected) signal mix (0.0...1.0, def. 0).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ReverbParameters.fWetMix">
            <summary>
            Wet (affected) signal mix (0.0...3.0, def. 1.0).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ReverbParameters.fRoomSize">
            <summary>
            Room size (0.0...1.0, def. 0.5).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ReverbParameters.fDamp">
            <summary>
            Damping factor (0.0...1.0, def. 0.5).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ReverbParameters.fWidth">
            <summary>
            Stereo width (0.0...1.0, def. 1.0).
            </summary>
            <remarks>It should at least be 4 for moderate scaling ratios. A value of 32 is recommended for best quality (better quality = higher CPU usage).</remarks>
        </member>
        <member name="F:ManagedBass.Fx.ReverbParameters.lMode">
            <summary>
            Mode: 0 = no freeze or 1 = freeze, def. 0 (no freeze).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.ReverbParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.ReverbParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.RotateParameters">
            <summary>
            Parameters for Rotate Effect.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.RotateParameters.fRate">
            <summary>
            Rotation rate/speed in Hz (A negative rate can be used for reverse direction).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.RotateParameters.lChannel">
            <summary>
            A <see cref="T:ManagedBass.FXChannelFlags" /> flag to define on which channels to apply the effect. Default: <see cref="F:ManagedBass.FXChannelFlags.All"/>
            </summary>
        </member>
        <member name="P:ManagedBass.Fx.RotateParameters.FXType">
            <summary>
            Gets the <see cref="T:ManagedBass.EffectType"/>.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.BQFType">
            <summary>
            BassFx BiQuad filter type. Defines within the <see cref="T:ManagedBass.Fx.BQFParameters" /> structure which BiQuad filter should be used.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFType.LowPass">
            <summary>
            BiQuad Lowpass filter.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFType.HighPass">
            <summary>
            BiQuad Highpass filter.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFType.BandPass">
            <summary>
            BiQuad Bandpass filter (constant 0 dB peak gain).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFType.BandPassQ">
            <summary>
            BiQuad Bandpass Q filter (constant skirt gain, peak gain = Q).
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFType.Notch">
            <summary>
            BiQuad Notch filter.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFType.AllPass">
            <summary>
            BiQuad All-Pass filter.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFType.PeakingEQ">
            <summary>
            BiQuad Peaking EQ filter.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFType.LowShelf">
            <summary>
            BiQuad Low-Shelf filter.
            </summary>
        </member>
        <member name="F:ManagedBass.Fx.BQFType.HighShelf">
            <summary>
            BiQuad High-Shelf filter.
            </summary>
        </member>
        <member name="T:ManagedBass.Fx.BPMBeatProcedure">
            <summary>
            User defined callback function, to get the Beat position in seconds.
            </summary>
            <param name="Channel">Handle that the <see cref="M:ManagedBass.Fx.BassFx.BPMBeatCallbackSet(System.Int32,ManagedBass.Fx.BPMBeatProcedure,System.IntPtr)" /> or <see cref="M:ManagedBass.Fx.BassFx.BPMBeatDecodeGet(System.Int32,System.Double,System.Double,ManagedBass.BassFlags,ManagedBass.Fx.BPMBeatProcedure,System.IntPtr)" /> has applied to.</param>
            <param name="BeatPosition">The exact beat position in seconds.</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.Fx.BassFx.BPMBeatCallbackSet(System.Int32,ManagedBass.Fx.BPMBeatProcedure,System.IntPtr)" /> or <see cref="M:ManagedBass.Fx.BassFx.BPMBeatDecodeGet(System.Int32,System.Double,System.Double,ManagedBass.BassFlags,ManagedBass.Fx.BPMBeatProcedure,System.IntPtr)" /> was called.</param>
        </member>
        <member name="T:ManagedBass.Fx.BPMProcedure">
            <summary>
            User defined callback function, to auto get the BPM after each period of time in seconds.
            </summary>
            <param name="Channel">Handle that the <see cref="M:ManagedBass.Fx.BassFx.BPMCallbackSet(System.Int32,ManagedBass.Fx.BPMProcedure,System.Double,System.Int32,ManagedBass.BassFlags,System.IntPtr)" /> applies to.</param>
            <param name="BPM">The new original bpm value.</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.Fx.BassFx.BPMCallbackSet(System.Int32,ManagedBass.Fx.BPMProcedure,System.Double,System.Int32,ManagedBass.BassFlags,System.IntPtr)" /> was called.</param>
        </member>
        <member name="T:ManagedBass.Fx.BPMProgressProcedure">
            <summary>
            User defined callback function, to get the bpm detection process in percents.
            </summary>
            <param name="Channel">Channel that the <see cref="M:ManagedBass.Fx.BassFx.BPMDecodeGet(System.Int32,System.Double,System.Double,System.Int32,ManagedBass.BassFlags,ManagedBass.Fx.BPMProgressProcedure,System.IntPtr)" /> applies to.</param>
            <param name="Percent">The progress of the process in percent (0%..100%).</param>
            <param name="User">The user instance data given when <see cref="M:ManagedBass.Fx.BassFx.BPMDecodeGet(System.Int32,System.Double,System.Double,System.Int32,ManagedBass.BassFlags,ManagedBass.Fx.BPMProgressProcedure,System.IntPtr)" /> was called.</param>
        </member>
    </members>
</doc>
